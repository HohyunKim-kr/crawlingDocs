# https://socket.io/blog

## npm package provenance

## Socket.IO monorepo

## Three new adapters

## Chat platform

## Socket.IO on Azure

## Redis Streams adapter

## Socket.IO server for Deno

## Socket.IO 4.5.0

## Socket.IO 4.4.0

## Socket.IO 4.3.0

Hello everyone!

We are happy to announce that Socket.IO packages will now be published with a provenance statement.

Hello everyone!

We are happy to announce that the Socket.IO codebase has been merged into a monorepo.

Hello everyone!

I'm happy to announce that we provide 3 new official adapters:

Any feedback is welcome!

Hello everyone!

A new sample project is available: the Chat platform.

The source code can be found here.

Hello developers,

Since we put up an invitation to participate in a user study, we collected hundreds of responses and had the chance to speak in depth with several Socket.IO users. Thank you for your interest in the user study and helping us understand your experience.

In this post, I am going to share with you some notable learnings from the study. It’s our hope that such sharing can shed light on how we can build a stronger community as Socket.IO users, contributors, and cloud providers.

Hello everyone!

There is a new official adapter for Socket.IO: the Redis Streams adapter.

Hello everyone!

I'm happy to announce that Socket.IO is now compatible with Deno, which is a runtime for JavaScript and TypeScript written in Rust.

Usage:

And then run with:

Next steps:

Feedback is welcome!

Hello everyone!

We have just published a new minor version of Socket.IO: 4.5.0

Hello everyone!

We have just published a new minor version of Socket.IO: 4.4.0

Hello everyone!

We have just published a new minor version of Socket.IO: 4.3.0

- the Google Cloud Pub/Sub adapter
- the AWS SQS adapter
- the Azure Service Bus adapter
- Overview of Socket.IO support on Azure
- Quickstarts of hosting a Socket.IO app on Azure
- client implementation
- compatibility with the Node.js ecosystem (msgpack parser, adapters, admin UI, ...)
- Source code: https://github.com/socketio/socket.io-deno
- Module: https://deno.land/x/socket_io
```js
import { serve } from "https://deno.land/std@0.150.0/http/server.ts";import { Server } from "https://deno.land/x/socket_io@0.1.1/mod.ts";const io = new Server();io.on("connection", (socket) => {  console.log(`socket ${socket.id} connected`);  socket.emit("hello", "world");  socket.on("disconnect", (reason) => {    console.log(`socket ${socket.id} disconnected due to ${reason}`);  });});await serve(io.handler(), {  port: 3000,});
```

```js
$ deno run --allow-net index.ts
```

```js
import { serve } from "https://deno.land/std@0.150.0/http/server.ts";import { Server } from "https://deno.land/x/socket_io@0.1.1/mod.ts";const io = new Server();io.on("connection", (socket) => {  console.log(`socket ${socket.id} connected`);  socket.emit("hello", "world");  socket.on("disconnect", (reason) => {    console.log(`socket ${socket.id} disconnected due to ${reason}`);  });});await serve(io.handler(), {  port: 3000,});
```

```js
$ deno run --allow-net index.ts
```

```js
4.5.0
```

```js
4.4.0
```

```js
4.3.0
```

# https://socket.io/blog/admin-ui-first-release

# Socket.IO Admin UI

Hi everyone!

We have published a first release of the Socket.IO Admin UI:

Current features:

The installation steps can be found here.

The source code can be found here: https://github.com/socketio/socket.io-admin-ui/

If you have any feedback / suggestions, do not hesitate!

- overview of the servers and the clients that are currently connected
- details of each socket instance (active transport, handshake, rooms, ...)
- details of each room
- administrative operations (join, leave, disconnect)
# https://socket.io/blog/archive

### 2014

### 2015

### 2016

### 2017

### 2020

### 2021

### 2022

### 2023

### 2024

- May 28, 2014 - Introducing Socket.IO 1.0
- September 21, 2015 - Socket.IO 1.3.7
- July 15, 2015 - Socket.IO 1.3.6
- July 14, 2015 - Socket.IO P2P
- April 13, 2015 - Socket.IO C++
- March 9, 2015 - Socket.IO on iOS
- March 3, 2015 - Socket.IO 1.3.5
- February 14, 2015 - Socket.IO 1.3.4
- February 4, 2015 - Socket.IO 1.3.3
- January 20, 2015 - Native Socket.IO and Android
- January 27, 2016 - Socket.IO 1.4.5
- January 11, 2016 - Socket.IO 1.4.4
- January 8, 2016 - Socket.IO 1.4.1, 1.4.2 and 1.4.3
- January 6, 2016 - Socket.IO 1.4.0
- June 24, 2017 - Socket.IO 2.0.1, 2.0.2 and 2.0.3
- May 15, 2017 - Socket.IO is on Open Collective
- May 13, 2017 - Socket.IO 2.0.0
- November 23, 2020 - Monthly update #2
- November 12, 2020 - Redis Adapter v6.0.0
- November 5, 2020 - Socket.IO 3 Release
- October 3, 2020 - Monthly update #1
- October 2, 2020 - Socket.IO client 2.3.1
- September 10, 2020 - Engine.IO 4 Release
- November 18, 2021 - Socket.IO 4.4.0
- October 15, 2021 - Socket.IO 4.3.0
- July 8, 2021 - Monthly update #5
- May 14, 2021 - Socket.IO 4.1.0
- May 6, 2021 - Monthly update #4
- April 16, 2021 - Socket.IO Admin UI
- April 7, 2021 - Monthly update #3
- March 10, 2021 - Socket.IO 4.0.0
- January 15, 2021 - Socket.IO 3.1.0
- January 5, 2021 - Socket.IO 2.4.0
- September 13, 2022 - Socket.IO server for Deno
- April 23, 2022 - Socket.IO 4.5.0
- August 23, 2023 - Socket.IO on Azure
- April 7, 2023 - Redis Streams adapter
- July 25, 2024 - npm package provenance
- July 12, 2024 - Socket.IO monorepo
- March 29, 2024 - Three new adapters
- January 12, 2024 - Chat platform
# https://socket.io/blog/chat-platform

# Chat platform

## Goal​

## How to use​

## Features​

## Tools​

## Roadmap​

### Channel-based messages​

### Private messages​

### Server​

### Client​

Hello everyone!

A new sample project is available: the Chat platform.

The source code can be found here.

Socket.IO is a library that enables low-latency, bidirectional and event-based communication between a client and a server.

To achieve this, it automatically selects the best available low-level transport between WebTransport, WebSocket and HTTP long-polling, based on the capabilities of the client platform and the network.

The goal of this project is to provide a full-blown project based on Socket.IO with:

The source code is provided with a permissive MIT license, so that you can use it/extend it to your will.

Check out the code here and follow the instructions in the README.

The server is written in plain JavaScript, with the express, express-session and passport packages. The database is PostgreSQL.

The client is a Vue.js single-page application, with the vue-router and pinia packages. It uses Bootstrap v5 for the styles.

Any additional suggestion is welcome!

- authentication/user registration
- public and private messaging
- proper reconnection management
- presence management
- React client (link)
- MongoDB server (link)
```js
express
```

```js
express-session
```

```js
passport
```

```js
vue-router
```

```js
pinia
```

# https://socket.io/blog/engine-io-4-release

# Engine.IO 4 Release

## Major breaking changes​

## Other changes​

## How to upgrade​

## What's next​

## Let's discuss!​

### Heartbeat mechanism reversal​

### Packet encoding​

### CORS handling​

### No cookie by default​

### The default value of maxHttpBufferSize was decreased​

### perMessageDeflate is now disabled by default​

### Support for Node.js 8 was dropped​

We are happy to announce the release of Engine.IO v4, the low-level engine that powers Socket.IO.

We have received a lot of reports from users that experience random disconnects due to ping timeout, even though their Internet connection is up and the remote server is reachable. It should be noted that in that case the client reconnects right away, but still it was an annoying issue.

After analysis, it seems to be caused by delayed timers on the client-side. Those timers are used in the ping-pong mechanism which helps to ensure the connection between the server and the client is still healthy. A delay on the client-side meant the client sent the ping packet too late, and the server considered that the connection was closed.

That's why the ping packets will now be sent by the server, and the client will respond with a pong packet.

We have also changed the way the data is encoded. It previously relied on the string length in Javascript, which meant it was harder to implement clients in other programming languages that do not share the same encoding (more details here).

Technically speaking, it impacts the way an array of packets is encoded when using XHR polling (WebSocket is not affected, as each packet is sent in its own WebSocket frame).

You can find more details about the updates to the protocol here.

We now use the cors package to handle the CORS configuration. The handlePreflightRequest option was removed:

Please see here for all available options.

In Engine.IO v3, the io cookie was sent by default. This cookie can be used to enable sticky-session, which is required when you have several servers (more information here).

However, this cookie is not needed in some cases (i.e. single server deployment, sticky-session based on IP) so it must now be explicitly enabled:

All other options (domain, maxAge, sameSite, ...) are now supported. Please see here for the complete list of options.

This option defines how many bytes or characters a message can be, before closing the connection. It was reduced from 100MB to 1MB.

This option defines whether the WebSocket permessage-deflate extension is enabled or not. This feature, while useful in some cases, adds some extra memory overhead for each WebSocket connection, and could result in huge memory usage in production deployments. It is now disabled by default.

We are dropping support for Node.js 8, which is now End-of-Life. It will not be tested in the CI anymore, so please upgrade as soon as possible!

As detailed in the Major breaking changes section, this release contains several backward incompatible changes, and as such v3 clients will not be able to connect to a v4 server (and vice versa).

In order to upgrade a live production environment, you will need to have both a group of v3 servers and v4 servers in parallel, and route the traffic based on either:

So that it shall be a seamless migration for your end users.

This release will be included in Socket.IO v3 in the near future. We will publish a more detailed roadmap in the next blog post.

Besides, I (@darrachequesne) am glad to announce that I will be dedicated full time to the project for the next months. This is possible thanks to our awesome sponsors.

Again, a big shout out to Pia Mancini and all the team behind the Open Collective platform, which helps making Open Source Software sustainable in the long term.

The project is now part of the beta of Github Discussions. Depending on the feedback of the community, it might replace the Slack channel in the future.

If you have any question about the release, let's discuss about it here.

Stay safe!

- the EIO query parameter
- the path (by using a different path for the v4 servers)
- or the domain if you use a different domain for the v4 servers
```js
socket.send("€€");socket.send("й");// v3 encoding output"3:4€€2:4й"// 3        "4€€".length (the JS specific part, 6 bytes)// :        separator// 4        the "message" packet type// €€       the content of the first packet// 2        "4й".length (again, the JS specific part)// :        separator// 4        the "message" packet type// й        the content of the second packet// v4 encoding output"4€€\x1e4й"// 4        the "message" packet type// €€       the content of the first packet// \x1e     separator// 4        the "message" packet type// й        the content of the second packet
```

```js
const { Server } = require('engine.io');// beforenew Server({  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": 'https://example.com',      "Access-Control-Allow-Methods": 'GET',      "Access-Control-Allow-Headers": 'Authorization',      "Access-Control-Allow-Credentials": true    });    res.end();  }});// afternew Server({  cors: {    origin: "https://example.com",    methods: ["GET"],    allowedHeaders: ["Authorization"],    credentials: true  }});
```

```js
const { Server } = require('engine.io');// beforenew Server({  cookieName: "io",  cookieHttpOnly: false,  cookiePath: "/custom"});// afternew Server({  cookie: {    name: "test",    httpOnly: false,    path: "/custom"  }});
```

```js
const { Server } = require('engine.io');new Server({  maxHttpBufferSize: 1e8 // defaults to 1e6});
```

```js
const { Server } = require('engine.io');new Server({  perMessageDeflate: true // defaults to false});
```

```js
socket.send("€€");socket.send("й");// v3 encoding output"3:4€€2:4й"// 3        "4€€".length (the JS specific part, 6 bytes)// :        separator// 4        the "message" packet type// €€       the content of the first packet// 2        "4й".length (again, the JS specific part)// :        separator// 4        the "message" packet type// й        the content of the second packet// v4 encoding output"4€€\x1e4й"// 4        the "message" packet type// €€       the content of the first packet// \x1e     separator// 4        the "message" packet type// й        the content of the second packet
```

```js
handlePreflightRequest
```

```js
const { Server } = require('engine.io');// beforenew Server({  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": 'https://example.com',      "Access-Control-Allow-Methods": 'GET',      "Access-Control-Allow-Headers": 'Authorization',      "Access-Control-Allow-Credentials": true    });    res.end();  }});// afternew Server({  cors: {    origin: "https://example.com",    methods: ["GET"],    allowedHeaders: ["Authorization"],    credentials: true  }});
```

```js
const { Server } = require('engine.io');// beforenew Server({  cookieName: "io",  cookieHttpOnly: false,  cookiePath: "/custom"});// afternew Server({  cookie: {    name: "test",    httpOnly: false,    path: "/custom"  }});
```

```js
100MB
```

```js
1MB
```

```js
const { Server } = require('engine.io');new Server({  maxHttpBufferSize: 1e8 // defaults to 1e6});
```

```js
const { Server } = require('engine.io');new Server({  perMessageDeflate: true // defaults to false});
```

```js
EIO
```

```js
path
```

# https://socket.io/blog/introducing-socket-io-1-0

# Introducing Socket.IO 1.0

## New engine​

## Binary support​

## Automated Testing​

## Scalability​

## Integration​

## Better debugging​

## CDN delivery​

## Future innovation​

## Credits​

### socket.io-stream​

### Tooling​

### New languages and frameworks​

The first version of Socket.IO was created shortly after Node.JS made its first appearance. I had been looking for a framework that easily enabled me to push data from a server to a client for a long time, and even had tried other approaches to server-side JavaScript.

Socket.IO has thus become the EventEmitter of the web. Today I want to talk about the work that has gone into 1.0 to round up this vision.

There's a lot to say about Socket.IO 1.0, so if you're short in time, feel free to jump to the parts that are most interesting to you:

The benefits of this particular modularization can't be understated:

This separation has also allowed us to innovate and perfect the transport layer. One of my favorite improvements was introducing the idea of what I call transport feature detection.

For example, simply checking that the JSON global is present does not mean that JSON.stringify works, or even exists. It could have simply meant that the user defined a JSON global of their own, or the environment could have a broken JSON implementation.

Socket.IO never assumes that WebSocket will just work, because in practice there's a good chance that it won't. Instead, it establishes a connection with XHR or JSONP right away, and then attempts to upgrade the connection to WebSocket. Compared to the fallback method which relies on timeouts, this means that none of your users will have a degraded experience.

Users have been asking for the ability to send binary data for a while, especially after WebSocket added support for it.

Socket.IO now supports emitting Buffer (from Node.JS), Blob, ArrayBuffer and even File, as part of any datastructure:

To test how useful it would be to support binary in this particular way (and as a virtualization geek), I decided to replicate the Twitch Plays Pokemon experiment 100% in JavaScript. Using a JavaScript gameboy emulator, node-canvas, socket.io we came up with a server-rendered collaborative game that even works on IE8. Check it out on https://weplay.io (source code here).

The relevant code that sends the image data is:

The next experiment was to run an instance of QEMU running an image of Windows XP, in honor of its retirement. Every player gets a 15 second turn to control the machine. Check out the demo on http://socket.computer. Here's a video of your typical inception scenario:

A key part of putting together this demo was connecting to the QEMU VNC server and implementing the RFB protocol. As it's usually the case with Node.JS, the solution was a npm search rfb away.

Essentially, in order to minimize latency and have the best performance, it's best to notify clients only of the pieces of the screen that changed. For example, if you move your mouse around, only little pieces of the screen that surround the cursor are broadcasted. The node-rfb2 module gives us a rect event with objects like the following:

It then became clear to me that our support for binary data would be genuinely useful. All I had to do was call io.emit to pass that object around, and let Socket.IO do the rest.

Just for fun, I also installed and ran one of my favorite first person shooters:

Every commit to the Socket.IO codebase now triggers a testing matrix totaling to 25 browsers, including Android and iOS.

We accomplish this by having make test seamlessly set up a reverse tunnel to ephemeral ports in your computer (thus making it accessible from the outside world), and have them execute on the Sauce Labs cloud, which is in charge of virtualizing and executing browsers on all the environments we care about.

We simplified the approach towards rooms and multi-node scalability dramatically. Instead of storing and/or replicating data across nodes, Socket.IO is now only concerned with passing events around.

If you want to scale out Socket.IO to multiple nodes, it now comes down to two simple steps:

This leads directly into our next goal: integration with other backends.

Chances are good that your existing application deployments are written in a variety of languages and frameworks, and are not just limited to Node.JS. Even if it was all Node.JS, you probably at some point want to separate concerns of your application into different processes.

One of the processes might be in charge of hosting the Socket.IO server, accepting connections, performing authentication, etc, and then another part of your backend might end up in charge of producing messages.

To that end we're introducing the socket.io-emitter project which hooks into socket.io-redis to easily allow you to emit events to browsers from anywhere:

Tony Kovanen already created a PHP implementation:

This makes it really easy to turn any existing application into a realtime application!

Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called debug by TJ Holowaychuk.

In the past, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), and violates the Rule of Silence of the Unix Philosophy:

You can see it in action for example on our homepage:

The socket.io module now exports the attachment function directly (previously .listen).
It's even easier now to attach socket.io to a HTTP server:

or to make it listen on some port:

Before, to refer to everyone connected you had to use io.sockets. Now you can call directly on io:

One of the best decisions we made early on was that implementing a Socket.IO server would not only give you access to the realtime protocol, but Socket.IO itself would also serve the client.

Normally, all you have to do is to include a snippet like this:

If you want to optimize access to the client by serving it near your users, provide the maximum level of gzip compression (thanks to Google's zopfli and proper support for caching, you can now use our CDN. It's free, forever, and has built-in SSL support:

The core Socket.IO projects will continue to improve with lots of more frequent releases, with the sole goal of improving reliability, speed and making the codebase smaller and easier to maintain. Socket.IO 2.0 will probably see us ditching support for some older browsers, and not bundling some modules like the JSON serializer.

Most of the innovation in the Socket.IO world will happen outside of the core codebases. The most important projects that I'll be closely watching are the following:

By adding this plugin, you'll be able to send Stream objects so that you can write memory-efficient programs. In the first example we loaded a file into memory prior to emitting it, but the following should be possible:

And on the client side you'll receive a Stream object that emits data events.

When you use Socket.IO you don't care about transports, packets, frames, TCP or WebSocket. You care about what events are sent back and forth.

Our goal is to have plugins for Web Inspector, Firefox Developer Tools that allow you to easily introspect what events are being sent, when, and what their parameters are.

This project is being led by the talented Nick LaGrow (Github), Samaan Ghani (Github) and David Cummings (Twitter).

A lot of effort has gone into specing and documenting the Engine.IO protocol and Socket.IO protocol.

The main goal behind this is that the Node.JS servers and clients become the reference implementations for many other languages and frameworks. Interoperability within the larger ecosystem is one of our biggest goals for 2014 and beyond.

This release has been a big team effort. Special thanks go out to our new core team:

Tony Kovanen (Github / Twitter) for his amazing work on Engine.IO binary support and research into a variety of workarounds to support all versions of iOS and Internet Explorer, his help in putting together this website and rounding up the docs.

Kevin Roark (Github) for the entire development of the new Socket.IO parser on top of Engine, the Socket.IO Computer demo, and help with docs, issues and pull requests.

Roman Shtylman (Github / Twitter) for his work on zuul and localtunnel, crucial to our testing architecture and our mission of reliability.

And in no particular order:

Jay Borenstein (LinkedIn) for selecting Socket.IO as one of the projects to mentor students on Open Source engineering as part of the Open Academy project.

Michael Srb (Github), Mark Mokryn (Github), Eugen Dueck (Github), Afshin Mehrabani (Github), Christoph Dorn (Github) and Mikito Takada (Github) for several key Engine.IO patches.

Grant Timmerman (Github / Twitter) for his outstanding work on the new Socket.IO example chat application, and multiple patches and issues investigation.

Jxck (Github / Twitter) for his work on translation, documentations and patches. ありがとう

Arnout Kazemier (Github / Twitter) for his multiple contributions to Engine.IO and Socket.IO

Sauce Labs (Github / Twitter) for supporting open source projects with free testing infrastructure.

Shihui Song (Github), Qiming Fang (Github) and Erluo Li for their work on testing infrastructure.

Julian Salazar (Github) and Tianyiu Liu (Github) for their work on reconnection and ongoing research into resource sharing between browser tabs and messages synchronization.

Gal Koren (Github) for his fantastic work into modularization of the codebases.

Matt Walker (Twitter) for the beautiful Socket.IO logo.

Finally, I'm very grateful to my company Automattic for being a great home to Open Source innovation.

- New engine
- Binary support
- Automated testing
- Scalability
- Integration
- Better debugging
- CDN delivery
- Future innovation
- Credits
- For the Socket.IO end user, nothing changes. Just drop-in the new version!
- A tremendous simplification in terms of codebase size and testing surfaceThe Socket.IO Server is now only 1234 lines of code.The Socket.IO Client is now only 976 lines of code.
- The Socket.IO Server is now only 1234 lines of code.
- The Socket.IO Client is now only 976 lines of code.
- Future-proof flexibilityIf WebSocket is the only transport you want to support moving forward, Engine.IO (with all its browser hacks and workarounds) can be seamlessly removed.Alternative transports such as vanilla Node.JS TCP Sockets or Google Chrome Sockets can be trivially implemented.
- If WebSocket is the only transport you want to support moving forward, Engine.IO (with all its browser hacks and workarounds) can be seamlessly removed.
- Alternative transports such as vanilla Node.JS TCP Sockets or Google Chrome Sockets can be trivially implemented.
- Turn on sticky load balancing (for example by origin IP address). This ensures that long-polling connections for example always route requests to the same node where buffers of messages could be stored.
- Implement the socket.io-redis adapter.
- Tony Kovanen (Github / Twitter) for his amazing work on Engine.IO binary support and research into a variety of workarounds to support all versions of iOS and Internet Explorer, his help in putting together this website and rounding up the docs.
- Kevin Roark (Github) for the entire development of the new Socket.IO parser on top of Engine, the Socket.IO Computer demo, and help with docs, issues and pull requests.
- Roman Shtylman (Github / Twitter) for his work on zuul and localtunnel, crucial to our testing architecture and our mission of reliability.
- Jay Borenstein (LinkedIn) for selecting Socket.IO as one of the projects to mentor students on Open Source engineering as part of the Open Academy project.
- Michael Srb (Github), Mark Mokryn (Github), Eugen Dueck (Github), Afshin Mehrabani (Github), Christoph Dorn (Github) and Mikito Takada (Github) for several key Engine.IO patches.
- Grant Timmerman (Github / Twitter) for his outstanding work on the new Socket.IO example chat application, and multiple patches and issues investigation.
- Jxck (Github / Twitter) for his work on translation, documentations and patches. ありがとう
- Arnout Kazemier (Github / Twitter) for his multiple contributions to Engine.IO and Socket.IO
- Sauce Labs (Github / Twitter) for supporting open source projects with free testing infrastructure.
- Shihui Song (Github), Qiming Fang (Github) and Erluo Li for their work on testing infrastructure.
- Julian Salazar (Github) and Tianyiu Liu (Github) for their work on reconnection and ongoing research into resource sharing between browser tabs and messages synchronization.
- Gal Koren (Github) for his fantastic work into modularization of the codebases.
- Matt Walker (Twitter) for the beautiful Socket.IO logo.
```js
var socket = new WebSocket('ws://localhost');socket.binaryType = 'arraybuffer';socket.send(new ArrayBuffer);
```

```js
var fs = require('fs');var io = require('socket.io')(3000);io.on('connection', function(socket){  fs.readFile('image.png', function(err, buf){    // it's possible to embed binary data    // within arbitrarily-complex objects    socket.emit('image', { image: true, buffer: buf });  });});
```

```js
self.canvas.toBuffer(function(err, buf){  if (err) throw err;  io.emit('frame', buf);});
```

```js
{  x: 103,  y: 150,  width: 200,  height: 250,  data: Buffer}
```

```js
var io = require('socket.io')(3000);var redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
var io = require('socket.io-emitter')();setInterval(function(){  io.emit('time', new Date);}, 5000);
```

```js
<?php$emitter = new SocketIOEmitter(array('port' => '6379', 'host' => '127.0.0.1'));$emitter->emit('event', 'wow');?>
```

```js
var srv = require('http').Server();var io = require('socket.io')(srv);
```

```js
var io = require('socket.io')(8080);
```

```js
io.on('connection', function(socket){  socket.emit('hi');});io.emit('hi everyone');
```

```js
<script src="/socket.io/socket.io.js"></script>
```

```js
<script src="https://cdn.socket.io/socket.io-1.0.0.js"></script>
```

```js
var fs = require('fs');var io = require('socket.io')(3000);require('socket.io-stream')(io);io.on('connection', function(socket){  io.emit(fs.createReadStream('file.jpg'));});
```

```js
WebSocket
```

```js
EventEmitter
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
var socket = new WebSocket('ws://localhost');socket.binaryType = 'arraybuffer';socket.send(new ArrayBuffer);
```

```js
Buffer
```

```js
Blob
```

```js
ArrayBuffer
```

```js
File
```

```js
var fs = require('fs');var io = require('socket.io')(3000);io.on('connection', function(socket){  fs.readFile('image.png', function(err, buf){    // it's possible to embed binary data    // within arbitrarily-complex objects    socket.emit('image', { image: true, buffer: buf });  });});
```

```js
self.canvas.toBuffer(function(err, buf){  if (err) throw err;  io.emit('frame', buf);});
```

```js
npm search rfb
```

```js
rect
```

```js
{  x: 103,  y: 150,  width: 200,  height: 250,  data: Buffer}
```

```js
io.emit
```

```js
make test
```

```js
var io = require('socket.io')(3000);var redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
Socket#set
```

```js
Socket#get
```

```js
var io = require('socket.io-emitter')();setInterval(function(){  io.emit('time', new Date);}, 5000);
```

```js
<?php$emitter = new SocketIOEmitter(array('port' => '6379', 'host' => '127.0.0.1'));$emitter->emit('event', 'wow');?>
```

```js
socket.io
```

```js
.listen
```

```js
var srv = require('http').Server();var io = require('socket.io')(srv);
```

```js
var io = require('socket.io')(8080);
```

```js
io.sockets
```

```js
io.on('connection', function(socket){  socket.emit('hi');});io.emit('hi everyone');
```

```js
<script src="/socket.io/socket.io.js"></script>
```

```js
<script src="https://cdn.socket.io/socket.io-1.0.0.js"></script>
```

```js
Stream
```

```js
var fs = require('fs');var io = require('socket.io')(3000);require('socket.io-stream')(io);io.on('connection', function(socket){  io.emit(fs.createReadStream('file.jpg'));});
```

```js
Stream
```

```js
data
```

# https://socket.io/blog/monorepo

# Socket.IO monorepo

## Modular architecture​

## Workspaces​

## Git history​

## GitHub issues​

Hello everyone!

We are happy to announce that the Socket.IO codebase has been merged into a monorepo.

A monorepo is a single repository containing multiple distinct projects, with well-defined relationships.

More info here

As part of the work towards v1.0 ten years ago (!), the Socket.IO codebase was split into several packages, each with its own responsibility:

At the time, tools like lerna or pnpm workspaces that make it easier to develop and publish multiple JavaScript packages from the same repository did not exist yet, so the codebase was split into multiple GitHub repositories:

However, this structure has several downsides:

That's why we have made the decision to merge all repositories into a single one. The source codes for the different packages are now located in the packages/ directory:

To manage the packages, we use npm workspaces which were introduced in npm v7 (bundled with Node.js v15). The package.json file at the root of the repository lists all packages and their development dependencies:

After cloning the repository, running npm install will fetch all necessary dependencies and create the links between the packages:

And finally, running npm test --workspaces (or npm test -ws) will run the tests on all workspaces, ensuring that any change is properly tested over the whole codebase.

Our contributing guide has been updated accordingly.

Obviously, losing 10 years of git history from the other repositories was not an option. The repositories have thus been merged with the --allow-unrelated-histories option, in order to include their history in the monorepo:

Reference: https://git-scm.com/docs/git-merge#Documentation/git-merge.txt---allow-unrelated-histories

Similarly, it was not conceivable to lose the list of open GitHub issues across all repositories, since it is our most valuable source of user feedback, so they have been moved to the main repository: https://github.com/socketio/socket.io/issues

Hopefully, this change should make it easier for anyone to contribute to the project in the future.

That's all folks, thanks for reading!

- https://github.com/socketio/socket.io
- https://github.com/socketio/socket.io-client
- https://github.com/socketio/socket.io-parser
- ...
- it's harder for newcomers to dig into the codebase and understand what's going on under the hood
- a change that affects multiple repositories is more difficult to test
- mundane tasks like configuring CI or updating development dependencies must be replicated across all repositories
```js
packages/├── engine.io├── engine.io-client├── engine.io-parser├── socket.io├── socket.io-adapter├── socket.io-client└── socket.io-parser
```

```js
{  "private": true,  "workspaces": [    "packages/engine.io-parser",    "packages/engine.io",    "packages/engine.io-client",    "packages/socket.io-adapter",    "packages/socket.io-parser",    "packages/socket.io-client",    "packages/socket.io"  ],  "devDependencies": {    // [...]  }}
```

```js
$ npm lssocket.io@ /git/socket.io└─┬ socket.io@4.7.5 -> ./packages/socket.io  ├── accepts@1.3.8  ├── base64id@2.0.0  ├── cors@2.8.5  ├── debug@4.3.5  ├── engine.io@6.6.0 -> ./packages/engine.io  ├─┬ socket.io-adapter@2.5.5 -> ./packages/socket.io-adapter  │ ├── debug@4.3.5 deduped  │ └── ws@8.17.1 overridden  └─┬ socket.io-parser@4.2.4 -> ./packages/socket.io-parser    ├── @socket.io/component-emitter@3.1.2 -> ./packages/socket.io-component-emitter    └── debug@4.3.5 deduped
```

```js
lerna
```

```js
packages/
```

```js
packages/├── engine.io├── engine.io-client├── engine.io-parser├── socket.io├── socket.io-adapter├── socket.io-client└── socket.io-parser
```

```js
package.json
```

```js
{  "private": true,  "workspaces": [    "packages/engine.io-parser",    "packages/engine.io",    "packages/engine.io-client",    "packages/socket.io-adapter",    "packages/socket.io-parser",    "packages/socket.io-client",    "packages/socket.io"  ],  "devDependencies": {    // [...]  }}
```

```js
npm install
```

```js
$ npm lssocket.io@ /git/socket.io└─┬ socket.io@4.7.5 -> ./packages/socket.io  ├── accepts@1.3.8  ├── base64id@2.0.0  ├── cors@2.8.5  ├── debug@4.3.5  ├── engine.io@6.6.0 -> ./packages/engine.io  ├─┬ socket.io-adapter@2.5.5 -> ./packages/socket.io-adapter  │ ├── debug@4.3.5 deduped  │ └── ws@8.17.1 overridden  └─┬ socket.io-parser@4.2.4 -> ./packages/socket.io-parser    ├── @socket.io/component-emitter@3.1.2 -> ./packages/socket.io-component-emitter    └── debug@4.3.5 deduped
```

```js
npm test --workspaces
```

```js
npm test -ws
```

```js
--allow-unrelated-histories
```

# https://socket.io/blog/monthly-update-1

# Monthly update #1

## Socket.IO v3 (WIP)​

## Engine.IO v4​

## Protocol documentation​

## GitHub discussions​

## Minor bumps​

## Going forward​

Hi everyone!

Here's the #1 edition of our Monthly update. This is a new experiment, we will try to stick to this frequency in order to keep you updated of the work that is in progress and the directions the project is taking.

So, what's new in the Socket.IO ecosystem?

The work on Socket.IO v3 has started (let's be honest and not say resumed).

This major version bump is mandated by several necessary changes in the Engine.IO protocol. You can find more information about these changes in the Engine.IO v4 release notes.

We will also take advantage of this new version to migrate the codebase to Typescript, so the typings which are currently hosted in the DefinitelyTyped will now always be in sync with the actual code.

You can follow the progress here.

If you have any feedback/feature that you would like to see included, please comment here.

As part of the work towards Socket v3, Engine.IO v4 has been released.

The list of breaking changes can be found in the release notes.

The documentation of the Engine.IO and the Socket.IO protocols has been edited with additional details/examples.

This should help greatly when implementing a client in another programming language.

If you find that something is not clear/is missing, please open an issue in the repository.

For reference, here's the current list of clients in other languages:

The project is now part of the beta of Github Discussions. Depending on the feedback of the community, it might replace the Slack channel in the future.

So, let's discuss!

socket.io-client@2.3.1 (release notes)

socket.io-json-parser@2.1.1

socket.io-msgpack-parser@2.2.1

More information about how to use those custom parsers can be found here.

As announced at the bottom of the Engine.IO v4 release notes, I (@darrachequesne) am now dedicated full time to the project since the beginning of September. This wouldn't be possible without our sponsors, so again, a big thanks to them!

Stay safe!

- Java: https://github.com/socketio/socket.io-client-java
- C++: https://github.com/socketio/socket.io-client-cpp
- Swift: https://github.com/socketio/socket.io-client-swift
- Dart: https://github.com/rikulo/socket.io-client-dart
- Python: https://github.com/miguelgrinberg/python-socketio
- .Net: https://github.com/Quobject/SocketIoClientDotNet
- socket.io-client@2.3.1 (release notes)engine.io-parser@2.2.1 (included in socket.io-client{% raw %}@{% endraw %}2.3.1)engine.io-client@3.4.4 (included in socket.io-client{% raw %}@{% endraw %}2.3.1)socket.io-parser@3.3.1 (included in socket.io-client{% raw %}@{% endraw %}2.3.1)
- engine.io-parser@2.2.1 (included in socket.io-client{% raw %}@{% endraw %}2.3.1)
- engine.io-client@3.4.4 (included in socket.io-client{% raw %}@{% endraw %}2.3.1)
- socket.io-parser@3.3.1 (included in socket.io-client{% raw %}@{% endraw %}2.3.1)
- socket.io-json-parser@2.1.1
- socket.io-msgpack-parser@2.2.1
```js
socket.io-client{% raw %}@{% endraw %}2.3.1
```

```js
socket.io-client{% raw %}@{% endraw %}2.3.1
```

```js
socket.io-client{% raw %}@{% endraw %}2.3.1
```

# https://socket.io/blog/monthly-update-2

# Monthly update #2

## Socket.IO v3​

## Redis Adapter v6​

## Documentation​

## Minor bumps​

## What's next​

Hi everyone!

Here's the #2 edition of our Monthly update. This is a new experiment, we will try to stick to this frequency in order to keep you updated of the work in progress and the directions the project is taking.

So, what's new in the Socket.IO ecosystem?

As announced in the previous monthly update, Socket.IO v3 has been released a few days ago.

This major version bump is mandated by several necessary changes in the Engine.IO protocol. You can find more information about these changes in the Engine.IO v4 release notes.

You can find the release notes here and the migration guide here.

Let's discuss about this release here: https://github.com/socketio/socket.io/discussions/3674

Following the release of Socket.IO v3.0.0, the Redis Adapter was updated and a new release is out: 6.0.0

You can find the release notes here.

The documentation has always been a weak point of the project, leading to a lot of issues opened on GitHub and questions on StackOverflow.

Now that v3 is out, we will focus on this. The following pages have already been created:

If you find a typo, please open an issue here: https://github.com/socketio/socket.io-website

socket.io@3.0.3 (release notes)

socket.io-client@3.0.3

socket.io-redis@6.0.1

socket.io-msgpack-parser@3.0.1

More information about how to use those custom parsers can be found here.

the client implementations in other languages will be updated as well

a big focus on the documentation (additional code examples, extended guide, ...)

additional tooling around Socket.IO

Stay safe!

- Emitting events
- Broadcasting events
- The Socket instance / server-side
- Middlewares
- Handling CORS
- socket.io@3.0.3 (release notes)engine.io-parser@4.0.1 (included in socket.io{% raw %}@{% endraw %}3.0.3)engine.io@4.0.4 (included in socket.io{% raw %}@{% endraw %}3.0.3)socket.io-parser@4.0.1 (included in socket.io{% raw %}@{% endraw %}3.0.3)
- engine.io-parser@4.0.1 (included in socket.io{% raw %}@{% endraw %}3.0.3)
- engine.io@4.0.4 (included in socket.io{% raw %}@{% endraw %}3.0.3)
- socket.io-parser@4.0.1 (included in socket.io{% raw %}@{% endraw %}3.0.3)
- socket.io-client@3.0.3engine.io-parser@4.0.1 (included in socket.io-client{% raw %}@{% endraw %}3.0.3)engine.io-client@4.0.4 (included in socket.io-client{% raw %}@{% endraw %}3.0.3)socket.io-parser@4.0.1 (included in socket.io-client{% raw %}@{% endraw %}3.0.3)
- engine.io-parser@4.0.1 (included in socket.io-client{% raw %}@{% endraw %}3.0.3)
- engine.io-client@4.0.4 (included in socket.io-client{% raw %}@{% endraw %}3.0.3)
- socket.io-parser@4.0.1 (included in socket.io-client{% raw %}@{% endraw %}3.0.3)
- socket.io-redis@6.0.1
- socket.io-msgpack-parser@3.0.1
- the client implementations in other languages will be updated as well
- a big focus on the documentation (additional code examples, extended guide, ...)
- additional tooling around Socket.IO
```js
socket.io{% raw %}@{% endraw %}3.0.3
```

```js
socket.io{% raw %}@{% endraw %}3.0.3
```

```js
socket.io{% raw %}@{% endraw %}3.0.3
```

```js
socket.io-client{% raw %}@{% endraw %}3.0.3
```

```js
socket.io-client{% raw %}@{% endraw %}3.0.3
```

```js
socket.io-client{% raw %}@{% endraw %}3.0.3
```

# https://socket.io/blog/monthly-update-3

# Monthly update #3

## Socket.IO v4​

## Redis Adapter v6.1.0 and Redis Emitter v4.0.0​

## Documentation​

## New versions​

## What's next​

Hi everyone!

Here's the #3 edition of our Monthly update.

So, what's new in the Socket.IO ecosystem?

Wait, already v4?

The most important breaking change is related to broadcasting: calling to() or any other broadcast modifier will now return an immutable object.

Previously, the modifiers were saved on the io instance directly, which could lead to surprising behaviors:

You were also not able to reuse the operator:

Even more surprising, with asynchronous code:

Starting with v4.0.0, you can now use io.to() safely:

This release also brings some interesting new features, like the fetchSockets() method.

Please check the migration guide here.

The Redis adapter (for broadcasting packets with multiple Socket.IO servers) and the Redis emitter (for broadcasting packets from another Node.js process) have been updated in order to support the new features of the v4 release.

For example, the socketsJoin method will work across Socket.IO servers:

More information can be found here.

The documentation continues to be improved.

A new example project has been added in the "Get started" section, with middlewares and rooms: Private messaging

As usual, if you find a typo or think that some details are missing, please open an issue here: https://github.com/socketio/socket.io-website

socket.io@4.0.1 (release notes)

socket.io-client@4.0.1

socket.io-redis@6.1.0

@socket.io/redis-emitter@4.0.0

Stay safe!

- Socket.IO v4
- Redis Adapter v6.1.0 and Redis Emitter v4.0.0
- Documentation
- New versions
- What's next
- socket.io@4.0.1 (release notes)engine.io-parser@4.0.2 (included in socket.io{% raw %}@{% endraw %}4.0.1)engine.io@5.0.0 (included in socket.io{% raw %}@{% endraw %}4.0.1)socket.io-parser@4.0.4 (included in socket.io{% raw %}@{% endraw %}4.0.1)
- engine.io-parser@4.0.2 (included in socket.io{% raw %}@{% endraw %}4.0.1)
- engine.io@5.0.0 (included in socket.io{% raw %}@{% endraw %}4.0.1)
- socket.io-parser@4.0.4 (included in socket.io{% raw %}@{% endraw %}4.0.1)
- socket.io-client@4.0.1engine.io-parser@4.0.2 (included in socket.io-client{% raw %}@{% endraw %}4.0.1)engine.io-client@5.0.1 (included in socket.io-client{% raw %}@{% endraw %}4.0.1)socket.io-parser@4.0.4 (included in socket.io-client{% raw %}@{% endraw %}4.0.1)
- engine.io-parser@4.0.2 (included in socket.io-client{% raw %}@{% endraw %}4.0.1)
- engine.io-client@5.0.1 (included in socket.io-client{% raw %}@{% endraw %}4.0.1)
- socket.io-parser@4.0.4 (included in socket.io-client{% raw %}@{% endraw %}4.0.1)
- socket.io-redis@6.1.0
- @socket.io/redis-emitter@4.0.0
- a continuous focus on the documentation (additional code examples, extended guide, ...)
- additional tooling around Socket.IO
```js
io.to("room1");// and then laterio.to("room2").emit(/* ... */); // also sent to room1
```

```js
const operator = io.to("room1");operator.emit(/* ... */); // to room1 (assuming synchronous call)operator.emit(/* ... */); // to all clients
```

```js
io.to("room3").emit("details", await fetchDetails()); // unspecified behavior: maybe in room3, maybe to all clients
```

```js
const operator = io.to("room1").except("room2");operator.emit(/* ... */);operator.emit(/* ... */);
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");
```

```js
to()
```

```js
io.to("room1");// and then laterio.to("room2").emit(/* ... */); // also sent to room1
```

```js
const operator = io.to("room1");operator.emit(/* ... */); // to room1 (assuming synchronous call)operator.emit(/* ... */); // to all clients
```

```js
io.to("room3").emit("details", await fetchDetails()); // unspecified behavior: maybe in room3, maybe to all clients
```

```js
io.to()
```

```js
const operator = io.to("room1").except("room2");operator.emit(/* ... */);operator.emit(/* ... */);
```

```js
fetchSockets()
```

```js
socketsJoin
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");
```

```js
socket.io{% raw %}@{% endraw %}4.0.1
```

```js
socket.io{% raw %}@{% endraw %}4.0.1
```

```js
socket.io{% raw %}@{% endraw %}4.0.1
```

```js
socket.io-client{% raw %}@{% endraw %}4.0.1
```

```js
socket.io-client{% raw %}@{% endraw %}4.0.1
```

```js
socket.io-client{% raw %}@{% endraw %}4.0.1
```

# https://socket.io/blog/monthly-update-4

# Monthly update #4

## A new Admin UI​

## A new guide​

## Version updates​

## What's next​

Hi everyone!

Here's the #4 edition of our Monthly update.

So, what's new in the Socket.IO ecosystem?

Following our focus on tooling, we have published a first release of the Socket.IO Admin UI:

This Admin UI is meant to give you an overview of your Socket.IO deployment.

Here is the list of the current features:

And the features which will be added in the near future:

The installation steps can be found here.

The source code can be found here: https://github.com/socketio/socket.io-admin-ui/

If you have any feedback / suggestions, do not hesitate!

Please note that the Admin UI does support a cluster of several Socket.IO servers too.

We have added a new guide (here), using Socket.IO to create a basic CRUD application.

Happy coding!

- A new Admin UI
- A new guide
- Version updates
- What's next
- overview of the servers and the clients that are currently connected
- details of each socket instance (active transport, handshake, rooms, ...)
- details of each room
- administrative operations (join, leave, disconnect)
- overview of the number of packets/bytes sent and received per second
- emitting an event to all clients, a room or a particular Socket instance
- socket.io@4.0.2
- socket.io-client@4.0.2
- a continuous focus on the documentation (additional code examples, extended guide, ...)
- additional tooling around Socket.IO
# https://socket.io/blog/monthly-update-5

# Monthly update #5

## New official adapters​

## Additional documentation​

## Version updates​

## What's next​

Hi everyone!

Here's the #5 edition of our Monthly update.

So, what's new in the Socket.IO ecosystem?

This feature had been requested for quite some time, it is now implemented in release 4.1.0. It allows to broadcast events between your Socket.IO servers.

The syntax is very similar to the existing one, except it's for server-to-server communication:

And on the receiving side:

Acknowledgements are supported too:

You can find the complete release notes here.

Historically, the Redis adapter was the only official adapter when scaling to multiple nodes.

There are now three additional official adapters:

Note: the first two were inspired from existing adapters maintained by the community and were updated to support Socket.IO v3.

All of them supports the utility methods that were added in v4, including the serverSideEmit() method described above.

Happy coding!

- New official adapters
- Additional documentation
- Version updates
- What's next
- the MongoDB adapter
- the Postgres adapter
- the cluster adapter
- usage with bundlers like webpack for the client and the server
- usage with PM2
- socket.io@4.1.2
- socket.io-client@4.1.2
- a continuous focus on the documentation (additional code examples, extended guide, ...)
- additional tooling around Socket.IO
```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
serverSideEmit()
```

# https://socket.io/blog/native-socket-io-and-android

# Native Socket.IO and Android

## Introduction​

## Installing the Dependencies​

## Using socket in Activity and Fragment​

## Emitting events​

## Listening on events​

## Managing Socket State​

## Further reading​

In this tutorial well learn how to create a chat client that communicates with a Socket.IO Node.JS chat server, with our native Android Client! If you want to jump straight to the code, it's on GitHub. Otherwise, read on!

To follow along, start by cloning the repository: socket.io-android-chat.

The app has the following features:

The first step is to install the Java Socket.IO client with Gradle.

For this app, we just add the dependency to build.gradle:

We must remember adding the internet permission to AndroidManifest.xml.

Now we can use Socket.IO on Android!

First, we have to initialize a new instance of Socket.IO as follows:

IO.socket() returns a socket for http://chat.socket.io with the default options. Notice that the method caches the result, so you can always get a same Socket instance for an url from any Activity or Fragment.
And we explicitly call connect() to establish the connection here (unlike the JavaScript client). In this app, we use onCreate lifecycle callback for that, but it actually depends on your application.

Sending data looks as follows. In this case, we send a string but you can do JSON data too with the org.json package, and even binary data is supported as well!

Like I mentioned earlier, Socket.IO is bidirectional, which means we can send events to the server, but also at any time during the communication the server can send events to us.

We then can make the socket listen an event on onCreate lifecycle callback.

With this we listen on the new message event to receive messages from other users.

This is what onNewMessage looks like. A listener is an instance of Emitter.Listener and must be implemented the call method. Youll notice that inside of call() is wrapped by Activity#runOnUiThread(), that is because the callback is always called on another thread from Android UI thread, thus we have to make sure that adding a message to view happens on the UI thread.

Since an Android Activity has its own lifecycle, we should carefully manage the state of the socket also to avoid problems like memory leaks. In this app, we’ll close the socket connection and remove all listeners on onDestroy callback of Activity.

Calling off() removes the listener of the new message event.

If you want to explore more, I recommend you look into:

Other features of this app. They are just implemented with emit(), on() and off().

The documentation of the Java Socket.IO client

Many other great Socket.IO implementations created by the community!

- Sending a message to all users joining to the room.
- Notifies when each user joins or leaves.
- Notifies when an user start typing a message.
- Other features of this app. They are just implemented with emit(), on() and off().
- The documentation of the Java Socket.IO client
- Many other great Socket.IO implementations created by the community!
```js
dependencies {    implementation ('io.socket:socket.io-client:2.0.0') {        exclude group: 'org.json', module: 'json'    }}
```

```js
<!-- app/AndroidManifest.xml --><manifest xmlns:android="http://schemas.android.com/apk/res/android">    <uses-permission android:name="android.permission.INTERNET" />    ...</manifest>
```

```js
import io.socket.client.IO;import io.socket.client.Socket;private Socket mSocket;{    try {        mSocket = IO.socket("http://chat.socket.io");    } catch (URISyntaxException e) {}}@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    mSocket.connect();}
```

```js
private EditText mInputMessageView;private void attemptSend() {    String message = mInputMessageView.getText().toString().trim();    if (TextUtils.isEmpty(message)) {        return;    }    mInputMessageView.setText("");    mSocket.emit("new message", message);}
```

```js
@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    mSocket.on("new message", onNewMessage);    mSocket.connect();}
```

```js
import io.socket.emitter.Emitter;private Emitter.Listener onNewMessage = new Emitter.Listener() {    @Override    public void call(final Object... args) {        getActivity().runOnUiThread(new Runnable() {            @Override            public void run() {                JSONObject data = (JSONObject) args[0];                String username;                String message;                try {                    username = data.getString("username");                    message = data.getString("message");                } catch (JSONException e) {                    return;                }                // add the message to view                addMessage(username, message);            }        });    }};
```

```js
@Overridepublic void onDestroy() {    super.onDestroy();    mSocket.disconnect();    mSocket.off("new message", onNewMessage);}
```

```js
build.gradle
```

```js
dependencies {    implementation ('io.socket:socket.io-client:2.0.0') {        exclude group: 'org.json', module: 'json'    }}
```

```js
AndroidManifest.xml
```

```js
<!-- app/AndroidManifest.xml --><manifest xmlns:android="http://schemas.android.com/apk/res/android">    <uses-permission android:name="android.permission.INTERNET" />    ...</manifest>
```

```js
import io.socket.client.IO;import io.socket.client.Socket;private Socket mSocket;{    try {        mSocket = IO.socket("http://chat.socket.io");    } catch (URISyntaxException e) {}}@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    mSocket.connect();}
```

```js
IO.socket()
```

```js
http://chat.socket.io
```

```js
Socket
```

```js
connect()
```

```js
onCreate
```

```js
private EditText mInputMessageView;private void attemptSend() {    String message = mInputMessageView.getText().toString().trim();    if (TextUtils.isEmpty(message)) {        return;    }    mInputMessageView.setText("");    mSocket.emit("new message", message);}
```

```js
onCreate
```

```js
@Overridepublic void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    mSocket.on("new message", onNewMessage);    mSocket.connect();}
```

```js
new message
```

```js
import io.socket.emitter.Emitter;private Emitter.Listener onNewMessage = new Emitter.Listener() {    @Override    public void call(final Object... args) {        getActivity().runOnUiThread(new Runnable() {            @Override            public void run() {                JSONObject data = (JSONObject) args[0];                String username;                String message;                try {                    username = data.getString("username");                    message = data.getString("message");                } catch (JSONException e) {                    return;                }                // add the message to view                addMessage(username, message);            }        });    }};
```

```js
onNewMessage
```

```js
Emitter.Listener
```

```js
call
```

```js
call()
```

```js
Activity#runOnUiThread()
```

```js
onDestroy
```

```js
@Overridepublic void onDestroy() {    super.onDestroy();    mSocket.disconnect();    mSocket.off("new message", onNewMessage);}
```

```js
off()
```

```js
new message
```

```js
emit()
```

```js
on()
```

```js
off()
```

# https://socket.io/blog/npm-package-provenance

# npm package provenance

## Notes​

## First verified version​

## Conclusion​

### Workflow trigger​

### Compilation step​

Hello everyone!

We are happy to announce that Socket.IO packages will now be published with a provenance statement.

Package provenance is a npm feature which was introduced last year to increase trust in the npm supply chain.

The idea is that the package is published and signed from a trusted CI/CD platform (such as GitHub Actions), so the code that ends up in the registry cannot be tampered with.

More info: https://github.blog/security/supply-chain-security/introducing-npm-package-provenance/

Starting today, new Socket.IO versions will be published directly from GitHub Actions and no longer from a maintainer machine.

The publication workflow can be found here: publish.yml

There are a few notable differences from the reference workflow:

The workflow is triggered when pushing a tag to GitHub:

The expected format is <package>@<version>, for example:

The <package> part is then used to select the right workspace (since we are using a monorepo):

Reference: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions

A TypeScript compilation step is necessary, since some packages depend on the types of other packages:

The latest version of the engine.io-parser package has been released this way.

On the npmjs.com website, you can find:

You can also verify the attestations of your dependencies:

This is a big step forward in increasing trust in the JS ecosystem, congratulations to the npm team!

Some big names have already joined the club:

That's all folks, thanks for reading!

- socket.io@1.2.3
- @socket.io/redis-adapter@3.4.5 (hence the ** to match the / char)
- the details of the build, at the bottom of the page:
- a checked badge, in the "Versions" tab
- axios
- next
- vite
```js
on:  push:    tags:      - '**@*'
```

```js
jobs:  publish:    steps:      # [...]      - name: Publish package        run: npm publish --workspace=${GITHUB_REF_NAME%@*} --provenance --access public        env:          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

```js
jobs:  publish:    steps:      # [...]      - name: Compile each package        run: npm run compile --workspaces --if-present      - name: Publish package      # [...]
```

```js
$ npm i socket.ioadded 22 packages, and audited 23 packages in 853msfound 0 vulnerabilities$ npm audit signaturesaudited 22 packages in 1s22 packages have verified registry signatures1 package has a verified attestation # <-- it's a good start!
```

```js
publish.yml
```

```js
on:  push:    tags:      - '**@*'
```

```js
<package>@<version>
```

```js
socket.io@1.2.3
```

```js
@socket.io/redis-adapter@3.4.5
```

```js
<package>
```

```js
jobs:  publish:    steps:      # [...]      - name: Publish package        run: npm publish --workspace=${GITHUB_REF_NAME%@*} --provenance --access public        env:          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
```

```js
jobs:  publish:    steps:      # [...]      - name: Compile each package        run: npm run compile --workspaces --if-present      - name: Publish package      # [...]
```

```js
engine.io-parser
```

```js
$ npm i socket.ioadded 22 packages, and audited 23 packages in 853msfound 0 vulnerabilities$ npm audit signaturesaudited 22 packages in 1s22 packages have verified registry signatures1 package has a verified attestation # <-- it's a good start!
```

# https://socket.io/blog/page/2

## Monthly update #5

## Socket.IO 4.1.0

## Monthly update #4

## Socket.IO Admin UI

## Monthly update #3

## Socket.IO 4.0.0

## Socket.IO 3.1.0

## Socket.IO 2.4.0

## Monthly update #2

## Redis Adapter v6.0.0

Hi everyone!

Here's the #5 edition of our Monthly update.

Hello everyone!

We have just published a new minor version of Socket.IO: 4.1.0

Hi everyone!

Here's the #4 edition of our Monthly update.

Hi everyone!

We have published a first release of the Socket.IO Admin UI:

Hi everyone!

Here's the #3 edition of our Monthly update.

Hello everyone!

We just published a new major version of Socket.IO: 4.0.0

Hello everyone!

We just published a new version of Socket.IO: 3.1.0

Happy New Year everyone!

We just published a new minor version in the 2.x branch!

Hi everyone!

Here's the #2 edition of our Monthly update. This is a new experiment, we will try to stick to this frequency in order to keep you updated of the work in progress and the directions the project is taking.

Following the release of Socket.IO v3.0.0, the Redis Adapter was updated and a new release is out: 6.0.0

# https://socket.io/blog/page/3

## Socket.IO 3 Release

## Monthly update #1

## Socket.IO client 2.3.1

## Engine.IO 4 Release

## Socket.IO 2.0.1, 2.0.2 and 2.0.3

## Socket.IO is on Open Collective

## Socket.IO 2.0.0

## Socket.IO 1.4.5

## Socket.IO 1.4.4

## Socket.IO 1.4.1, 1.4.2 and 1.4.3

We are happy to announce the release of Socket.IO v3!

Hi everyone!

Here's the #1 edition of our Monthly update. This is a new experiment, we will try to stick to this frequency in order to keep you updated of the work that is in progress and the directions the project is taking.

Hi everyone!

We have published a minor version of the client: 2.3.1

We are happy to announce the release of Engine.IO v4, the low-level engine that powers Socket.IO.

We published three minor releases right after 2.0.0, so please be sure to use the latest version!

Open Collective provides a transparent, sustainable, and secure way for people to support and sponsor open source projects. We are joining other great projects (you may have heard about MochaJS, GulpJS or webpack, among lots of other awesome projects) in the quest to ensure the project's sustainability.

Socket.IO 2.0.0 is finally here!

We just published some quick fixes!

We just published two fixes for socket.io-client:

Building with browserify or webpack is now completely straightforward. No need to exclude/ignore or noParse/externals the ws module.

Improved the JSONP transport when socket.io-client or engine.io-client are lazily evaluated or the <script> tag that included them gets removed.

We published three minor releases right after 1.4.0 addressing build issues in different environments.

- Building with browserify or webpack is now completely straightforward. No need to exclude/ignore or noParse/externals the ws module.
- Improved the JSONP transport when socket.io-client or engine.io-client are lazily evaluated or the <script> tag that included them gets removed.
```js
2.0.0
```

```js
socket.io-client
```

```js
browserify
```

```js
webpack
```

```js
exclude/ignore
```

```js
noParse/externals
```

```js
socket.io-client
```

```js
engine.io-client
```

```js
<script>
```

```js
1.4.0
```

# https://socket.io/blog/page/4

## Socket.IO 1.4.0

## Socket.IO 1.3.7

## Socket.IO 1.3.6

## Socket.IO P2P

## Socket.IO C++

## Socket.IO on iOS

## Socket.IO 1.3.5

## Socket.IO 1.3.4

## Socket.IO 1.3.3

## Native Socket.IO and Android

Socket.IO 1.4.0 ship with new features like automatic compression for XHR and WebSockets, lots of bug fixes and significant performance and memory improvements.

Socket.IO 1.3.7 includes support for io.js and Node.JS 4.0.0.

Socket.IO 1.3.6 addresses a build issue with the ws module on Windows.

Today were very happy to introduce Socket.IO P2P, the easiest way to establish a bidirectional events channel between two peers with a server fallback to provide maximum reliability.

I'm really proud to announce the first release of the Socket.IO C++ Client on GitHub!

We are pleased to announce the immediate availability of the Socket.IO Swift Client! Youll now be able to write code that runs natively on iOS and OSX, while maintaining the simplicity and expressiveness of the JavaScript client!

Socket.IO 1.3.5 addresses a parser issue. Upgrade recommended. Completely backwards-compatible.

Socket.IO 1.3.4 corrects the 1.3.3 build that included extra unused code.

Socket.IO 1.3.3 is a backwards-compatible recommended upgrade for everyone.

It addresses a bug in the parser that could break the decoder with maliciously-crafted binary packets.

We now warn about errors in the console if you dont manually specify an error event handler for Socket objects on the server.

As usual, you can grab the latest client from the CDN!

In this tutorial well learn how to create a chat client that communicates with a Socket.IO Node.JS chat server, with our native Android Client! If you want to jump straight to the code, it's on GitHub. Otherwise, read on!

- It addresses a bug in the parser that could break the decoder with maliciously-crafted binary packets.
- We now warn about errors in the console if you dont manually specify an error event handler for Socket objects on the server.
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.7/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.4/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.3/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.7/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
```

```js
1.3.3
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.4/socket.io.min.js"></script>
```

```js
error
```

```js
Socket
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.3/socket.io.min.js"></script>
```

# https://socket.io/blog/page/5

## Introducing Socket.IO 1.0

The first version of Socket.IO was created shortly after Node.JS made its first appearance. I had been looking for a framework that easily enabled me to push data from a server to a client for a long time, and even had tried other approaches to server-side JavaScript.

# https://socket.io/blog/socket-io-1-3-3

# Socket.IO 1.3.3

Socket.IO 1.3.3 is a backwards-compatible recommended upgrade for everyone.

It addresses a bug in the parser that could break the decoder with maliciously-crafted binary packets.

We now warn about errors in the console if you dont manually specify an error event handler for Socket objects on the server.

As usual, you can grab the latest client from the CDN!

- It addresses a bug in the parser that could break the decoder with maliciously-crafted binary packets.
- We now warn about errors in the console if you dont manually specify an error event handler for Socket objects on the server.
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.3/socket.io.min.js"></script>
```

```js
error
```

```js
Socket
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.3/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-1-3-4

# Socket.IO 1.3.4

Socket.IO 1.3.4 corrects the 1.3.3 build that included extra unused code.

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.4/socket.io.min.js"></script>
```

```js
1.3.3
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.4/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-1-3-5

# Socket.IO 1.3.5

Socket.IO 1.3.5 addresses a parser issue. Upgrade recommended. Completely backwards-compatible.

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.5/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-1-3-6

# Socket.IO 1.3.6

Socket.IO 1.3.6 addresses a build issue with the ws module on Windows.

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-1-3-7

# Socket.IO 1.3.7

Socket.IO 1.3.7 includes support for io.js and Node.JS 4.0.0.

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.7/socket.io.min.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.7/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-1-4-0

# Socket.IO 1.4.0

Socket.IO 1.4.0 ship with new features like automatic compression for XHR and WebSockets, lots of bug fixes and significant performance and memory improvements.

Compression is enabled by default, as it’s highly beneficial for most application payloads. The following example shows the savings for a realtime stream of tweets.

The compression gains will vary by transport. For example, WebSocket defaults to a window size of 32kb when DEFLATE compression is enabled. Repeated occurrences of strings within that window will be compressed.
The following demo (inspired by Julia Evans work) will highlight what the LZ77 algorithm de-duplicates from the traffic sent by the Twitter stream that matches javascript.

How this demo works: we re-implemented a part of LZ77 in JavaScript. A React component then renders the compressed strings.

The longer the string, the darker the shade of yellow displayed.

In addition to this default behavior, we’ve introduced the capability to perform selective per-message compression, by introducing the compress flag when emitting an event.

To configure the defaults, we’ve introduced the following two options that you can pass to socket.io (and engine.io) when starting the server:

perMessageDeflate – options to customize WebSocket compression (see here) or true for defaults (true).

httpCompression – options to customize compression for HTTP polling transports or true for defaults (true)

The memory overhead when compression is enabled is not inexistent, however. Make sure to account for a 300kb~ overhead per connection in terms of memory allocation. Read here about the parameters you can customize to change how much memory is allocated and how aggressively data is compressed.

The following improvements have been made to the server:

The following improvements have been made to the client:

We've also released socket.io-redis 0.2.0 with significant performance improvements.

Special thanks to Damien Arrachequesne, Naoyuki Kanezawa and Jérémy Lal for their amazing and continued contributions that made this release possible.

- perMessageDeflate – options to customize WebSocket compression (see here) or true for defaults (true).
- httpCompression – options to customize compression for HTTP polling transports or true for defaults (true)
- Assume 443 port when passing https:// to the origins parameter – Evan Lucas
- Improve detection of binary data inside events (in the has-binary module) – Gunther Brunner
- Warn about missing error event handlers on sockets to prevent silent hard-to-debug situations
- Allow a custom function for the allowRequest function for origins verification
- Fixes for “use strict” environments – Naoyuki Kanezawa
- Prevent users calling the ack function multiple times – Kevin Jose Martin
- Fixed potential memory leaks with open sockets when upgrade fails – Naoyuki Kanezawa
- Fix lingering requests when a polling error occurs – Naoyuki Kanezawa
- Drastically more memory efficient when keeping track of clients – Damien Arrachequesne
- Drastically more memory efficient when keeping track of rooms – Jérémy Lal
- Trigger callback if the client is already in the given room when join is called – Damien Arrachequesne
- Minor parser fixes and performance improvements.
- Fix for specifying custom ports when connecting
- 2 or more connections to the same namespace now create new sockets, instead of reusing a single one.
- Added new reserved ping and pong events when a heartbeat is emitted and received.
- Add support for environments that extend Object.prototype – Damien Arrachequesne
- Fixes for “use strict” environments – Naoyuki Kanezawa
- Added an extraHeaders feature for custom headers in HTTP transports (non-WebSocket)
- Fix handling of disconnection while in the opening state.
- Improved error handling for unmatched acknowledgements.
- Parser fixes and improvements.
```js
socket.compress(true).emit(‘hi’, { some: ‘data’ });
```

```js
compress
```

```js
socket.compress(true).emit(‘hi’, { some: ‘data’ });
```

```js
perMessageDeflate
```

```js
true
```

```js
true
```

```js
httpCompression
```

```js
true
```

```js
true
```

```js
https://
```

```js
origins
```

```js
has-binary
```

```js
error
```

```js
allowRequest
```

```js
join
```

```js
ping
```

```js
pong
```

```js
extraHeaders
```

```js
opening
```

```js
0.2.0
```

# https://socket.io/blog/socket-io-1-4-1-1-4-2-and-1-4-3

# Socket.IO 1.4.1, 1.4.2 and 1.4.3

We published three minor releases right after 1.4.0 addressing build issues in different environments.

Socket.IO-client now includes the latest version of engine.io-client

Fixed an issue that was preventing bundling with webpack.

Socket.IO now adds support for NativeScript!

- Socket.IO-client now includes the latest version of engine.io-client
- Fixed an issue that was preventing bundling with webpack.
- Socket.IO now adds support for NativeScript!
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.3/socket.io.min.js"></script>
```

```js
1.4.0
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.3/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-1-4-4

# Socket.IO 1.4.4

We just published two fixes for socket.io-client:

Building with browserify or webpack is now completely straightforward. No need to exclude/ignore or noParse/externals the ws module.

Improved the JSONP transport when socket.io-client or engine.io-client are lazily evaluated or the <script> tag that included them gets removed.

Get the latest client from the CDN:

- Building with browserify or webpack is now completely straightforward. No need to exclude/ignore or noParse/externals the ws module.
- Improved the JSONP transport when socket.io-client or engine.io-client are lazily evaluated or the <script> tag that included them gets removed.
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.4/socket.io.min.js"></script>
```

```js
socket.io-client
```

```js
browserify
```

```js
webpack
```

```js
exclude/ignore
```

```js
noParse/externals
```

```js
socket.io-client
```

```js
engine.io-client
```

```js
<script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.4/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-1-4-5

# Socket.IO 1.4.5

We just published some quick fixes!

Get the latest client from the CDN:

- Fixed socket.io-client usage with NativeScript.
- Fixed graceful close of the attached http Server of socket.io and engine.io.
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.5/socket.io.min.js"></script>
```

```js
socket.io-client
```

```js
Server
```

```js
socket.io
```

```js
engine.io
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/1.4.5/socket.io.min.js"></script>
```

# https://socket.io/blog/socket-io-2-0-0

# Socket.IO 2.0.0

Socket.IO 2.0.0 is finally here!

This major release brings several performance improvements:

uws is now the default Websocket engine. It should bring significant improvement in performance (particularly in terms of memory consumption) (release note of Engine.IO)

the Engine.IO and Socket.IO handshake packets were merged, reducing the number of roundtrips necessary to establish a connection. (#2833)

it is now possible to provide a custom parser according to the needs of your application (#2829). Please take a look at the example for more information.

Please note that this release is not backward-compatible, due to:

a breaking change related to utf-8 encoding in engine.io-parser

an update to make the socket id on the client match the id on the server-side (#1058)

Related packages were updated accordingly:

socket.io-redis version 5.x

socket.io-emitter version 3.x

Get the latest client from the CDN:

- uws is now the default Websocket engine. It should bring significant improvement in performance (particularly in terms of memory consumption) (release note of Engine.IO)
- the Engine.IO and Socket.IO handshake packets were merged, reducing the number of roundtrips necessary to establish a connection. (#2833)
- it is now possible to provide a custom parser according to the needs of your application (#2829). Please take a look at the example for more information.
- a breaking change related to utf-8 encoding in engine.io-parser
- an update to make the socket id on the client match the id on the server-side (#1058)
- socket.io-redis version 5.x
- socket.io-emitter version 3.x
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"></script>
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.1/socket.io.js"></script>
```

# https://socket.io/blog/socket-io-2-0-1-2-0-2-and-2-0-3

# Socket.IO 2.0.1, 2.0.2 and 2.0.3

We published three minor releases right after 2.0.0, so please be sure to use the latest version!

Including:

A fix for a race condition within middleware: Issue #2935

A fix for a potential race condition when emitting to a room: Issue #2962

A fix for the query option in the client: Issue #1086

Get the latest client from the CDN:

- A fix for a race condition within middleware: Issue #2935
- A fix for a potential race condition when emitting to a room: Issue #2962
- A fix for the query option in the client: Issue #1086
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
```

```js
2.0.0
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
```

# https://socket.io/blog/socket-io-2-3-1

# Socket.IO client 2.3.1

### Bug Fixes​

Hi everyone!

We have published a minor version of the client: 2.3.1

The debug dependency has been reverted to ~3.1.0, as the newer versions contains ES6 syntax which breaks in IE browsers.

Please note that this only applied to users that bundle the Socket.IO client in their application, with webpack for example, as the "official" bundles (in the dist/ folder) were already transpiled with babel.

For webpack users, you can also take a look at the webpack-remove-debug plugin.

Get the latest client from the CDN:

For an explanation between the different bundles, please see here.

Stay safe!

- fix reconnection after opening socket asynchronously (#1253) (050108b)
```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.1/socket.io.slim.js"></script>
```

```js
debug
```

```js
~3.1.0
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.1/socket.io.slim.js"></script>
```

# https://socket.io/blog/socket-io-2-4-0

# Socket.IO 2.4.0

### Features​

### Bug Fixes​

Happy New Year everyone!

We just published a new minor version in the 2.x branch!

Please note that this release contains a breaking change regarding Cross-Origin Resource Sharing (CORS).

UPDATE: this change was reverted in 2.4.1, because it did not follow semantic versioning and broke some deployments (discussed here). Please make sure you are properly securing your application, and upgrade to Socket.IO v3 as soon as possible.

Previously, CORS was enabled by default, which meant that a Socket.IO server sent the necessary CORS headers (Access-Control-Allow-xxx) to any domain. This will not be the case anymore, and you now have to explicitly enable it.

Please note that you are not impacted if:

This change also removes the support for '*' matchers and protocol-less URL:

To restore the previous behavior (please use with caution):

A big thanks to @ni8walk3r for the detailed security report.

See also:

Stay safe!

- you are using Socket.IO v2 and the origins option to restrict the list of allowed domains
- you are using Socket.IO v3 (disabled by default)
- https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS
- https://socket.io/docs/v2/handling-cors/
- add support for all cookie options (19cc582)
- disable perMessageDeflate by default (5ad2736)
- security: do not allow all origins by default (f78a575)
- properly overwrite the query sent in the handshake (d33a619)
```js
io.origins('https://example.com:443'); => io.origins(['https://example.com']);io.origins('localhost:3000');          => io.origins(['http://localhost:3000']);io.origins('http://localhost:*');      => io.origins(['http://localhost:3000']);io.origins('*:3000');                  => io.origins(['http://localhost:3000']);
```

```js
io.origins((_, callback) => {  callback(null, true);});
```

```js
Access-Control-Allow-xxx
```

```js
origins
```

```js
io.origins('https://example.com:443'); => io.origins(['https://example.com']);io.origins('localhost:3000');          => io.origins(['http://localhost:3000']);io.origins('http://localhost:*');      => io.origins(['http://localhost:3000']);io.origins('*:3000');                  => io.origins(['http://localhost:3000']);
```

```js
io.origins((_, callback) => {  callback(null, true);});
```

# https://socket.io/blog/socket-io-3-1-0

# Socket.IO 3.1.0

### Features​

### Bug Fixes​

Hello everyone!

We just published a new version of Socket.IO: 3.1.0

In order to ease the migration to Socket.IO v3, the v3 server is now able to communicate with v2 clients:

This should make the migration easier for existing deployments:

Note: If you are using the Redis adapter to broadcast packets between nodes, you must use socket.io-redis@5 with socket.io@2 and socket.io-redis@6 with socket.io@3. Please note that both versions are compatible, so you can update each server one by one (no big bang is needed).

This step may actually take some time, as some clients may still have a v2 client in cache.

You can check the version of the connection with:

This matches the value of the EIO query parameter in the HTTP requests.

With allowEIO3 set to false, v2 clients will now receive an HTTP 400 error (Unsupported protocol version) when connecting.

The migration guide was updated accordingly.

- first, update the servers with allowEIO3 set to true
- then, update the clients
- and finally, once every client was updated, set allowEIO3 to false (which is the default value)
- confirm a weak but matching ETag (#3485) (161091d)
- esm: export the Namespace and Socket class (#3699) (233650c)
- add support for Socket.IO v2 clients (9925746)
- add room events (155fa63)
- typings: make Manager#opts public (#1437) (fe97243)
- allow integers as event names (1c220dd)
```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
io.on("connection", (socket) => {  const version = socket.conn.protocol; // either 3 or 4});
```

```js
const io = require("socket.io")({  allowEIO3: false});
```

```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
allowEIO3
```

```js
true
```

```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
socket.io-redis@5
```

```js
socket.io@2
```

```js
socket.io-redis@6
```

```js
socket.io@3
```

```js
io.on("connection", (socket) => {  const version = socket.conn.protocol; // either 3 or 4});
```

```js
EIO
```

```js
allowEIO3
```

```js
false
```

```js
const io = require("socket.io")({  allowEIO3: false});
```

```js
allowEIO3
```

```js
false
```

```js
Unsupported protocol version
```

# https://socket.io/blog/socket-io-3-release

# Socket.IO 3 Release

## Migration guide​

## Why Socket.IO in 2020?​

## What's next​

## Let's discuss!​

We are happy to announce the release of Socket.IO v3!

This release contains a few non backward compatible changes.

We have published a dedicated migration guide with all necessary details.

That's an excellent question actually. Depending on your use case, it might make sense to use plain WebSocket directly:

What Socket.IO brings:

To be honest, this feature was awesome 10 years ago, when most browsers didn't support WebSocket, but this is not the case anymore. That's still a great safety net though.

Using plain WebSocket, you can take a look at robust-websocket.

Which also works when scaling to several Socket.IO servers (more information here).

an ecosystem of compatible clients in other languages

the Redis adapter (used when broadcasting across Socket.IO servers) will be updated in order to be compatible with Socket.IO v3 (update: done!)

the client implementations in other languages will be updated as well

a big focus on the documentation (additional code examples, extended guide, ...)

additional tooling around Socket.IO

The project is now part of the beta of Github Discussions. Depending on the feedback of the community, it might replace the Slack channel in the future.

If you have any question about the release, let's discuss here.

Stay safe!

- client: MDN, Can I use?
- server: ws or eiows in the Node.JS ecosystem
- a fallback to HTTP long-polling, in case the WebSocket connection cannot be established
- auto-reconnection
- a way to broadcast data to a given set of clients: Rooms
- a way to split your application logic into distinct modules (for more complex applications): Namespaces
- an ecosystem of compatible clients in other languagesJava: https://github.com/socketio/socket.io-client-javaC++: https://github.com/socketio/socket.io-client-cppSwift: https://github.com/socketio/socket.io-client-swiftDart: https://github.com/rikulo/socket.io-client-dartPython: https://github.com/miguelgrinberg/python-socketio.Net: https://github.com/Quobject/SocketIoClientDotNet
- Java: https://github.com/socketio/socket.io-client-java
- C++: https://github.com/socketio/socket.io-client-cpp
- Swift: https://github.com/socketio/socket.io-client-swift
- Dart: https://github.com/rikulo/socket.io-client-dart
- Python: https://github.com/miguelgrinberg/python-socketio
- .Net: https://github.com/Quobject/SocketIoClientDotNet
- the Redis adapter (used when broadcasting across Socket.IO servers) will be updated in order to be compatible with Socket.IO v3 (update: done!)
- the client implementations in other languages will be updated as wellJava client: done!C++ client: done!Swift: done!
- Java client: done!
- C++ client: done!
- Swift: done!
- a big focus on the documentation (additional code examples, extended guide, ...)
- additional tooling around Socket.IO
```js
// on one sidesocket.emit("updateitem", "1", { name: "updated" }, (response) => {  console.log(response.status); // ok});// on the othersocket.on("updateitem", (arg1, arg2, callback) => {  console.log(arg1); // 1  console.log(arg2); // { name: "updated" }  callback({    status: "ok"  });});
```

```js
// server-sideio.on("connection", (socket) => {  socket.join("room1");  io.to("room1").emit("hello!");});
```

```js
// server-sideconst adminNamespace = io.of("/admin");adminNamespace.use((socket, next) => {  // ensure the socket is authorized});adminNamespace.on((socket) => {  socket.on("delete project", (id) => {    // in all handlers, we are sure that the socket is authorized  });});adminNamespace.emit("hello!"); // broadcast to admin only
```

```js
// on one sidesocket.emit("updateitem", "1", { name: "updated" }, (response) => {  console.log(response.status); // ok});// on the othersocket.on("updateitem", (arg1, arg2, callback) => {  console.log(arg1); // 1  console.log(arg2); // { name: "updated" }  callback({    status: "ok"  });});
```

```js
// server-sideio.on("connection", (socket) => {  socket.join("room1");  io.to("room1").emit("hello!");});
```

```js
// server-sideconst adminNamespace = io.of("/admin");adminNamespace.use((socket, next) => {  // ensure the socket is authorized});adminNamespace.on((socket) => {  socket.on("delete project", (id) => {    // in all handlers, we are sure that the socket is authorized  });});adminNamespace.emit("hello!"); // broadcast to admin only
```

# https://socket.io/blog/socket-io-4-1-0

# Socket.IO 4.1.0

## New features​

### Add support for inter-server communication​

### Emit an event when a namespace is created​

### Add a way to customize the response headers​

### Add a way to get access to the reason of a connection error​

### Add a way to ignore the beforeunload event​

Hello everyone!

We have just published a new minor version of Socket.IO: 4.1.0

This feature might be useful in a multi-server setup: you can now broadcast events between your Socket.IO servers.

Syntax:

And on the receiving side:

Acknowledgements are supported too:

A few notes:

the connection, connect and new_namespace (see below) strings are reserved and cannot be used in your application.

you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)

Example:

The Redis adapter and its associated emitter have been updated to support this new functionality.

The new_namespace event will be emitted by the Server instance when a new namespace is created:

This can be useful for example:

The underlying Engine.IO server, which manages the low-level connection (HTTP long-polling and/or WebSocket), will now emit two additional events:

Like the name suggests, the initial_headers event will be emitted only for the first HTTP request of the session, while the headers event will be emitted for each HTTP request (including the WebSocket upgrade).

Example:

Note: it was previously possible to achieve this by listening to the "request" event, but this should be easier with those new events:

The underlying Engine.IO server will also emit a new event: connection_error.

Syntax:

Here is the list of possible error codes:

A few months ago, a user reported a weird behavior when reloading a page: on Firefox, the Socket instance would emit a disconnect event, but not on Chrome or Safari.

We have published a fix for this issue in socket.io-client@3.1.1, by silently closing the connection when receiving a beforeunload event from the browser.

Unfortunately, this fix had unintended consequences: if you relied on the beforeunload event to prompt the user for confirmation ("your last modifications are not saved yet, do you really want to leave?"), the Socket.IO connection would now be closed, even if the user decided to stay on the page.

That's why we have added the closeOnBeforeunload option, to give you total control over this behavior:

That's all for this release, thanks for reading!

- Add support for inter-server communication
- Emit an event when a namespace is created
- Add a way to customize the response headers
- Add a way to get access to the reason of a connection error
- Add a way to ignore the beforeunload event
- the events are specific to each namespace
- the connection, connect and new_namespace (see below) strings are reserved and cannot be used in your application.
- you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)
- to attach a shared middleware to each namespace
- to track the dynamically created namespaces
- initial_headers
- headers
- closeOnBeforeunload: true (the default value) will make all browsers behave the same (no disconnect event when reloading the page)
- closeOnBeforeunload: false will ignore the beforeunload event, but you will get a disconnect event on Firefox
```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
// server Aio.of("/custom").serverSideEmit("sync");// server Bio.of("/custom").on("sync", () => {  // ...});
```

```js
io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
io.on("new_namespace", (namespace) => {  // ...});
```

```js
io.on("new_namespace", (namespace) => {  namespace.use(myMiddleware);});
```

```js
io.of(/\/nsp-\w+/);io.on("new_namespace", (namespace) => {  console.log(namespace.name);});
```

```js
io.engine.on("initial_headers", (headers, req) => {  headers["test"] = "123";  headers["set-cookie"] = "mycookie=456";});io.engine.on("headers", (headers, req) => {  headers["test"] = "789";});
```

```js
const httpServer = require("http").createServer();const { Server } = require("socket.io");const io = new Server(httpServer);httpServer.prependListener("request", (req, res) => {  res.setHeader("test", "789");});
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
const socket = io("/", {  closeOnBeforeunload: false // defaults to true})
```

```js
beforeunload
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
// server Aio.of("/custom").serverSideEmit("sync");// server Bio.of("/custom").on("sync", () => {  // ...});
```

```js
connection
```

```js
connect
```

```js
new_namespace
```

```js
JSON.stringify
```

```js
io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
new_namespace
```

```js
io.on("new_namespace", (namespace) => {  // ...});
```

```js
io.on("new_namespace", (namespace) => {  namespace.use(myMiddleware);});
```

```js
io.of(/\/nsp-\w+/);io.on("new_namespace", (namespace) => {  console.log(namespace.name);});
```

```js
initial_headers
```

```js
headers
```

```js
initial_headers
```

```js
headers
```

```js
io.engine.on("initial_headers", (headers, req) => {  headers["test"] = "123";  headers["set-cookie"] = "mycookie=456";});io.engine.on("headers", (headers, req) => {  headers["test"] = "789";});
```

```js
const httpServer = require("http").createServer();const { Server } = require("socket.io");const io = new Server(httpServer);httpServer.prependListener("request", (req, res) => {  res.setHeader("test", "789");});
```

```js
connection_error
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
beforeunload
```

```js
disconnect
```

```js
socket.io-client@3.1.1
```

```js
beforeunload
```

```js
beforeunload
```

```js
closeOnBeforeunload
```

```js
const socket = io("/", {  closeOnBeforeunload: false // defaults to true})
```

```js
closeOnBeforeunload: true
```

```js
disconnect
```

```js
closeOnBeforeunload: false
```

```js
beforeunload
```

```js
disconnect
```

# https://socket.io/blog/socket-io-4-3-0

# Socket.IO 4.3.0

### Links​

Hello everyone!

We have just published a new minor version of Socket.IO: 4.3.0

An ESM bundle is now provided:

The bundle size has been greatly reduced, thanks to:

And finally, the Socket.IO client is now compatible with Vite (#1492).

Size of the bundles:

That's all for this release, thanks for reading!

- the migration to rollup
- the cleanup of some unused code
- the removal of debug calls from the bundle (explanation here)
- Server: Release notes / Diff
- Client: Release notes / Diff
- ws version: ~8.2.3 (diff)
```js
<script type="module">  import { io } from "https://cdn.socket.io/4.3.0/socket.io.esm.min.js";  const socket = io();  socket.emit("hello", "world");</script>
```

```js
4.3.0
```

```js
<script type="module">  import { io } from "https://cdn.socket.io/4.3.0/socket.io.esm.min.js";  const socket = io();  socket.emit("hello", "world");</script>
```

```js
~8.2.3
```

# https://socket.io/blog/socket-io-4-4-0

# Socket.IO 4.4.0

## Support for µWebSockets.js​

## Emit with timeout​

## socket.data can now be typed​

## Links​

Hello everyone!

We have just published a new minor version of Socket.IO: 4.4.0

After a big focus on the client in the latest release, this release is more oriented towards the server.

Why should one choose between performance and reliability? Starting with socket.io@4.4.0, you can now use the HTTP/WebSocket server provided by the µWebSockets.js package:

It acts as a replacement for both the default Node.js HTTP server and the WebSocket server provided by the ws package, and should improve the memory footprint and the latency of your application. Benchmarks coming soon!

There is a new socket.timeout() method available on both sides:

For TypeScript users, the socket.data can now be typed:

This release also includes some bug fixes, please see the complete diff below.

Size of the bundles:

That's all for this release, thanks for reading!

- Server: GitHub release / Diff / npm
- Client: GitHub release / Diff / npm
```js
const { App } = require("uWebSockets.js");const { Server } = require("socket.io");const app = new App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the other side did not acknowledge the event in the given delay  }});
```

```js
interface SocketData {  name: string;  age: number;}const io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>();io.on("connection", (socket) => {  socket.data.name = "john";  socket.data.age = 42;});
```

```js
4.4.0
```

```js
socket.io@4.4.0
```

```js
µWebSockets.js
```

```js
const { App } = require("uWebSockets.js");const { Server } = require("socket.io");const app = new App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
socket.timeout()
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the other side did not acknowledge the event in the given delay  }});
```

```js
socket.data
```

```js
socket.data
```

```js
interface SocketData {  name: string;  age: number;}const io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>();io.on("connection", (socket) => {  socket.data.name = "john";  socket.data.age = 42;});
```

# https://socket.io/blog/socket-io-4-5-0

# Socket.IO 4.5.0

## Catch-all listeners for outgoing packets​

## Multiple acknowledgements when broadcasting​

## Limit the number of packets sent in HTTP long-polling mode​

## Disconnection details​

## Links​

Hello everyone!

We have just published a new minor version of Socket.IO: 4.5.0

Here are the new features in this release:

This is similar to onAny(), but for outgoing packets.

Syntax:

This feature can be used on both sides, and will also work when broadcasting events:

You can now broadcast an event to multiple clients and expect an acknowledgement:

The server will now include the value of the maxHttpBufferSize in the handshake, so the clients will now be able to decide how many packets they have to send to stay under this value.

Here is what the handshake will now look like:

More information here.

The "disconnect" event on the client side will now include additional details to help debugging if anything has gone wrong.

Example when sticky session is not enabled:

This release also includes some bug fixes, please see the complete diff below.

Size of the bundles:

That's all for this release, thanks for reading!

- Server: GitHub release / Diff / npm
- Client: GitHub release / Diff / npm
```js
socket.onAnyOutgoing((event, ...args) => {  console.log(event);});
```

```js
io.on("connection", (socket) => {  socket.onAnyOutgoing((event, ...args) => {    console.log(event); // prints "some event"  });  io.emit("some event");});
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
0{"sid":"lv_VI97HAXpY6yYWAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000,"maxPayload":1000000}
```

```js
socket.on("disconnect", (reason, details) => {  console.log(details.context.status); // 400  console.log(details.context.responseText); // '{"code":1,"message":"Session ID unknown"}'});
```

```js
4.5.0
```

```js
onAny()
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(event);});
```

```js
io.on("connection", (socket) => {  socket.onAnyOutgoing((event, ...args) => {    console.log(event); // prints "some event"  });  io.emit("some event");});
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
maxHttpBufferSize
```

```js
0{"sid":"lv_VI97HAXpY6yYWAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000,"maxPayload":1000000}
```

```js
socket.on("disconnect", (reason, details) => {  console.log(details.context.status); // 400  console.log(details.context.responseText); // '{"code":1,"message":"Session ID unknown"}'});
```

# https://socket.io/blog/socket-io-4-release

# Socket.IO 4.0.0

### Bug Fixes (server)​

### Bug Fixes (client)​

### Features (server)​

### Features (client)​

Hello everyone!

We just published a new major version of Socket.IO: 4.0.0

Please see the associated migration guide.

Apart from this, the Socket.IO protocol was not updated, so a v3 client will be able to reach a v4 server and vice-versa. Besides, the compatibility mode (allowEIO3: true) is still available between a Socket.IO v2 client and a Socket.IO v4 server.

- make io.to(...) immutable (ac9e8ca)
- set default protocol version to 3 (#616) (868d891) (Engine.IO)
- bundle: restore support for JS modules (43613d1)
- add some utility methods (b25495c)
- add support for typed events (#3822) (0107510)
- allow to exclude specific rooms when broadcasting (#3789) (7de2e87)
- allow to pass an array to io.to(...) (085d1de)
- increase the default value of pingTimeout (5a7fa13) (Engine.IO)
- remove dynamic require() with wsEngine (edb7343) (Engine.IO)
- add autoUnref option (6abfa1f)
- add support for typed events (5902365)
- listen to the "offline" event (c361bc6) (Engine.IO client)
```js
allowEIO3: true
```

# https://socket.io/blog/socket-io-cpp

# Socket.IO C++

## Introduction​

## Creating a QT GUI Application​

## Importing an SioClient​

## Importing Boost​

## Create the Main Window UI​

## Add Slots in the Main Window​

## Connect the UI Event Signal and Slots​

## Adding UI Refresh Signals/Slots​

## Setting up the Socket​

## Managing Connection State​

I'm really proud to announce the first release of the Socket.IO C++ Client on GitHub!

Based on Boost and WebSocket++, this full-featured Socket.IO 1.0 client has the fundamental advantage of working on multiple platforms. Check out the directory of examples. It contains examples of iOS, QT, and CLI chat clients!

To learn how to use this client, I put together a QT chat example that communicates using a Socket.IO Node.JS chat server. Keep reading for step-by-step instructions.

If you’d like to follow along, begin by cloning the socket.io-client-cpp repository using the following:

The app includes the following features:

Before you get started, visit the QT community to download and install QT.

Launch the QT Creator.

On the welcome page, select New Project, then create a QT Widget Application. Name it SioChatDemo.

The project structure should look like this:

Lets copy the SioClient into the QT project under the subfolder sioclient.

Edit SioChatDemo.pro to configure paths and compile options by simply adding:

Add two additional compile options:

The no_keywords flag prevents qmake from treating some function names as emit as the keyword for the signal-slot mechanism.

Use c++11 to ask for C++11 support.

We now have our boost headers and a fat boost static lib named libboost.a(non-win32) or boost.lib(win32).

To import them, we need to edit SioChatDemo.pro again by adding a header including the following:

Linker options:

Create a simple UI by dragging and dropping a widget from the widget box on the left-hand side.

It contains the following:

The following slots need to be added in the mainwindow class to handle UI events:

Insert the following code into the MainWindow class in mainwindow.h:

Open mainwindow.ui in the design mode. Switch to the signals/slots mode using Menu->Edit->Edit Signals/Slots.

Click and hold the widget and drag it to the window (the cursor will become an electrical ground symbol) to open the connection editor.

In the connection editor, edit the main window slots on the right side. Add the slot function names added in mainwindow.h before.

Then we can connect the event signal to the widget with our own slots. The result should look like this:

The sio::client callbacks are not in the UI thread. However, the UI must be updated with those callbacks, so we need a signal for the non-UI thread to request the slots functions in the UI thread. To signal that QListWidgetItem has been added, insert the following:

Then connect them in the MainWindow constructor.

For single-window applications, simply let MainWindow class hold the sio::client object by declaring a unique_ptr member of the sio::client and several event handling functions in mainwindow.h.

Initialize sio::client and setup event bindings for the default socket in the MainWindow constructor.

We also need to handle connectivity and disconnect events.

Add the following to the MainWindow constructor:

We have several connection listeners for connection events.

First, we want to send a login message when were connected; we get the default socket from the client to do that.

If the connection closes or fails, we need to restore the UI before we connect.

- Send messages to all users joining the room.
- Receive a notification when users join or leave the room.
- Receive notifications when a user starts typing a message.
- A QLineEdit at the top to input a nickname: nickNameEdit
- A QPushButton at the top right for login: loginBtn
- A QListWidget in the center for showing messages: listView
- A QLineEdit at the bottom for typing messages: messageEdit
- A QPushButton at the bottom right for sending messages: sendBtn
- Click ‘Login’ button
- Click ‘Send Message’ button
- Text change in message editing (to show typing status)
- Return message editing (for sending responses)
```js
git clone --recurse-submodules https://github.com/socketio/socket.io-client-cpp.git
```

```js
SioChatDemo    |__ SioChatDemo.pro    |__Headers    |   |__mainwindow.h    |__Sources    |   |__main.cpp    |   |__mainwindow.cpp    |__Forms        |__mainwindow.ui
```

```js
SOURCES += ./sioclient/src/sio_client.cpp           ./sioclient/src/sio_packet.cppHEADERS  += ./sioclient/src/sio_client.h            ./sioclient/src/sio_message.hINCLUDEPATH += $$PWD/sioclient/lib/rapidjson/includeINCLUDEPATH += $$PWD/sioclient/lib/websocketpp
```

```js
CONFIG+=no_keywordsCONFIG+=c++11
```

```js
INCLUDEPATH += `our boost headers folder`
```

```js
win32:CONFIG(release, debug|release): LIBS += -L`our Win32 boost static lib folder` -lboostelse:win32:CONFIG(debug, debug|release): LIBS += -L`our Win32 boost static lib folder` -lboostelse:unix: LIBS += -L`our osx boost static lib folder` -lboost
```

```js
public Q_SLOTS:    void SendBtnClicked();    void TypingChanged();    void LoginClicked();    void OnMessageReturn();
```

```js
// in mainwindow.hQ_SIGNALS:    void RequestAddListItem(QListWidgetItem *item);private Q_SLOTS:    void AddListItem(QListWidgetItem *item);
```

```js
//In mainwindow.cppvoid MainWindow::AddListItem(QListWidgetItem* item){    this->findChild<QListWidget*>("listView")->addItem(item);}
```

```js
connect(this,SIGNAL(RequestAddListItem(QListWidgetItem*)),this,SLOT(AddListItem(QListWidgetItem*)));
```

```js
private:    void OnNewMessage(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnUserJoined(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnUserLeft(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnTyping(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnStopTyping(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnLogin(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnConnected();    void OnClosed(client::close_reason const& reason);    void OnFailed();    std::unique_ptr<client> _io;
```

```js
MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow),    _io(new client()){    ui->setupUi(this);    using std::placeholders::_1;    using std::placeholders::_2;    using std::placeholders::_3;    using std::placeholders::_4;    socket::ptr sock = _io->socket();    sock->on("new message",std::bind(&MainWindow::OnNewMessage,this,_1,_2,_3,_4));    sock->on("user joined",std::bind(&MainWindow::OnUserJoined,this,_1,_2,_3,_4));    sock->on("user left",std::bind(&MainWindow::OnUserLeft,this,_1,_2,_3,_4));    sock->on("typing",std::bind(&MainWindow::OnTyping,this,_1,_2,_3,_4));    sock->on("stop typing",std::bind(&MainWindow::OnStopTyping,this,_1,_2,_3,_4));    sock->on("login",std::bind(&MainWindow::OnLogin,this,_1,_2,_3,_4));    //default socket opened, also we have "set_open_listener" for monitoring physical connection opened.    _io->set_socket_open_listener(std::bind(&MainWindow::OnConnected,this,std::placeholders::_1));    //physical connection closed or drop.    _io->set_close_listener(std::bind(&MainWindow::OnClosed,this,_1));    //physical connection fail to establish.    _io->set_fail_listener(std::bind(&MainWindow::OnFailed,this));    connect(this,SIGNAL(RequestAddListItem(QListWidgetItem*)),this,SLOT(AddListItem(QListWidgetItem*)));}
```

```js
void MainWindow::OnConnected(){    QByteArray bytes = m_name.toUtf8();    std::string nickName(bytes.data(),bytes.length());    _io->socket()->emit("add user", nickName);}
```

```js
void MainWindow::OnClosed(client::close_reason const& reason){    //restore UI to pre-login state}void MainWindow::OnFailed(){    //restore UI to pre-login state}```If we exit the `MainWindow`, we need to clear the event bindings and listeners.The `sio::client` object will be destroyed using `unique_ptr`.```cppMainWindow::~MainWindow(){    _io->socket()->off_all();    _io->socket()->off_error();    delete ui;}```## Handling Socket.IO EventsWe'll need to handle socket.io events in our functions they are bound to.For example, we need to show received messages in the list view.```cppvoid MainWindow::OnNewMessage(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp){    if(data->get_flag() == message::flag_object)    {        std::string msg = data->get_map()["message"]->get_string();        std::string name = data->get_map()["username"]->get_string();        QString label = QString::fromUtf8(name.data(),name.length());        label.append(':');        label.append(QString::fromUtf8(msg.data(),msg.length()));        QListWidgetItem *item= new QListWidgetItem(label);        //emit RequestAddListItem signal        //so that 'AddListItem' will be executed in UI thread.        Q_EMIT RequestAddListItem(item);    }}```## Wrapping Up: Sending the MessageWhen `sendBtn` is clicked, we need to send the text in `messageEdit` to the chatroom.Add the following code to `SendBtnClicked()`:```cppvoid MainWindow::SendBtnClicked(){    QLineEdit* messageEdit = this->findChild<QLineEdit*>("messageEdit");    QString text = messageEdit->text();    if(text.length()>0)    {        QByteArray bytes = text.toUtf8();        std::string msg(bytes.data(),bytes.length());        _io->socket()->emit("new message",msg);//emit new message        text.append(":You");        QListWidgetItem *item = new QListWidgetItem(text);        item->setTextAlignment(Qt::AlignRight);        Q_EMIT RequestAddListItem(item);        messageEdit->clear();    }}```## Further ReadingYou can run the <a href="https://github.com/socketio/socket.io-client-cpp/tree/master/examples/QT/SioChatDemo">demo project</a> to get a closer look. Before you run it, please follow the <a href="https://github.com/socketio/socket.io-client-cpp#-with-cmake">instructions</a> to make the Socket.io client library.Don't forget to <a href="https://github.com/socketio/socket.io-client-cpp">star the project</a> on GitHub to get updates!
```

```js
git clone --recurse-submodules https://github.com/socketio/socket.io-client-cpp.git
```

```js
New Project
```

```js
QT Widget Application.
```

```js
SioChatDemo.
```

```js
SioChatDemo    |__ SioChatDemo.pro    |__Headers    |   |__mainwindow.h    |__Sources    |   |__main.cpp    |   |__mainwindow.cpp    |__Forms        |__mainwindow.ui
```

```js
sioclient.
```

```js
SioChatDemo.pro
```

```js
SOURCES += ./sioclient/src/sio_client.cpp           ./sioclient/src/sio_packet.cppHEADERS  += ./sioclient/src/sio_client.h            ./sioclient/src/sio_message.hINCLUDEPATH += $$PWD/sioclient/lib/rapidjson/includeINCLUDEPATH += $$PWD/sioclient/lib/websocketpp
```

```js
CONFIG+=no_keywordsCONFIG+=c++11
```

```js
no_keywords
```

```js
qmake
```

```js
emit
```

```js
c++11
```

```js
headers
```

```js
static lib
```

```js
libboost.a
```

```js
boost.lib
```

```js
SioChatDemo.pro
```

```js
INCLUDEPATH += `our boost headers folder`
```

```js
win32:CONFIG(release, debug|release): LIBS += -L`our Win32 boost static lib folder` -lboostelse:win32:CONFIG(debug, debug|release): LIBS += -L`our Win32 boost static lib folder` -lboostelse:unix: LIBS += -L`our osx boost static lib folder` -lboost
```

```js
QLineEdit
```

```js
nickNameEdit
```

```js
QPushButton
```

```js
loginBtn
```

```js
QListWidget
```

```js
listView
```

```js
QLineEdit
```

```js
messageEdit
```

```js
QPushButton
```

```js
sendBtn
```

```js
mainwindow
```

```js
MainWindow
```

```js
mainwindow.h
```

```js
public Q_SLOTS:    void SendBtnClicked();    void TypingChanged();    void LoginClicked();    void OnMessageReturn();
```

```js
mainwindow.ui
```

```js
signals/slots
```

```js
Menu->Edit->Edit Signals/Slots
```

```js
mainwindow.h
```

```js
sio::client
```

```js
slots
```

```js
QListWidgetItem
```

```js
// in mainwindow.hQ_SIGNALS:    void RequestAddListItem(QListWidgetItem *item);private Q_SLOTS:    void AddListItem(QListWidgetItem *item);
```

```js
//In mainwindow.cppvoid MainWindow::AddListItem(QListWidgetItem* item){    this->findChild<QListWidget*>("listView")->addItem(item);}
```

```js
MainWindow
```

```js
connect(this,SIGNAL(RequestAddListItem(QListWidgetItem*)),this,SLOT(AddListItem(QListWidgetItem*)));
```

```js
MainWindow
```

```js
sio::client
```

```js
unique_ptr
```

```js
sio::client
```

```js
mainwindow.h
```

```js
private:    void OnNewMessage(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnUserJoined(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnUserLeft(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnTyping(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnStopTyping(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnLogin(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp);    void OnConnected();    void OnClosed(client::close_reason const& reason);    void OnFailed();    std::unique_ptr<client> _io;
```

```js
sio::client
```

```js
socket
```

```js
MainWindow
```

```js
MainWindow
```

```js
MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow),    _io(new client()){    ui->setupUi(this);    using std::placeholders::_1;    using std::placeholders::_2;    using std::placeholders::_3;    using std::placeholders::_4;    socket::ptr sock = _io->socket();    sock->on("new message",std::bind(&MainWindow::OnNewMessage,this,_1,_2,_3,_4));    sock->on("user joined",std::bind(&MainWindow::OnUserJoined,this,_1,_2,_3,_4));    sock->on("user left",std::bind(&MainWindow::OnUserLeft,this,_1,_2,_3,_4));    sock->on("typing",std::bind(&MainWindow::OnTyping,this,_1,_2,_3,_4));    sock->on("stop typing",std::bind(&MainWindow::OnStopTyping,this,_1,_2,_3,_4));    sock->on("login",std::bind(&MainWindow::OnLogin,this,_1,_2,_3,_4));    //default socket opened, also we have "set_open_listener" for monitoring physical connection opened.    _io->set_socket_open_listener(std::bind(&MainWindow::OnConnected,this,std::placeholders::_1));    //physical connection closed or drop.    _io->set_close_listener(std::bind(&MainWindow::OnClosed,this,_1));    //physical connection fail to establish.    _io->set_fail_listener(std::bind(&MainWindow::OnFailed,this));    connect(this,SIGNAL(RequestAddListItem(QListWidgetItem*)),this,SLOT(AddListItem(QListWidgetItem*)));}
```

```js
socket
```

```js
client
```

```js
void MainWindow::OnConnected(){    QByteArray bytes = m_name.toUtf8();    std::string nickName(bytes.data(),bytes.length());    _io->socket()->emit("add user", nickName);}
```

```js
void MainWindow::OnClosed(client::close_reason const& reason){    //restore UI to pre-login state}void MainWindow::OnFailed(){    //restore UI to pre-login state}```If we exit the `MainWindow`, we need to clear the event bindings and listeners.The `sio::client` object will be destroyed using `unique_ptr`.```cppMainWindow::~MainWindow(){    _io->socket()->off_all();    _io->socket()->off_error();    delete ui;}```## Handling Socket.IO EventsWe'll need to handle socket.io events in our functions they are bound to.For example, we need to show received messages in the list view.```cppvoid MainWindow::OnNewMessage(std::string const& name,message::ptr const& data,bool hasAck,message::ptr &ack_resp){    if(data->get_flag() == message::flag_object)    {        std::string msg = data->get_map()["message"]->get_string();        std::string name = data->get_map()["username"]->get_string();        QString label = QString::fromUtf8(name.data(),name.length());        label.append(':');        label.append(QString::fromUtf8(msg.data(),msg.length()));        QListWidgetItem *item= new QListWidgetItem(label);        //emit RequestAddListItem signal        //so that 'AddListItem' will be executed in UI thread.        Q_EMIT RequestAddListItem(item);    }}```## Wrapping Up: Sending the MessageWhen `sendBtn` is clicked, we need to send the text in `messageEdit` to the chatroom.Add the following code to `SendBtnClicked()`:```cppvoid MainWindow::SendBtnClicked(){    QLineEdit* messageEdit = this->findChild<QLineEdit*>("messageEdit");    QString text = messageEdit->text();    if(text.length()>0)    {        QByteArray bytes = text.toUtf8();        std::string msg(bytes.data(),bytes.length());        _io->socket()->emit("new message",msg);//emit new message        text.append(":You");        QListWidgetItem *item = new QListWidgetItem(text);        item->setTextAlignment(Qt::AlignRight);        Q_EMIT RequestAddListItem(item);        messageEdit->clear();    }}```## Further ReadingYou can run the <a href="https://github.com/socketio/socket.io-client-cpp/tree/master/examples/QT/SioChatDemo">demo project</a> to get a closer look. Before you run it, please follow the <a href="https://github.com/socketio/socket.io-client-cpp#-with-cmake">instructions</a> to make the Socket.io client library.Don't forget to <a href="https://github.com/socketio/socket.io-client-cpp">star the project</a> on GitHub to get updates!
```

# https://socket.io/blog/socket-io-deno

# Socket.IO server for Deno

Hello everyone!

I'm happy to announce that Socket.IO is now compatible with Deno, which is a runtime for JavaScript and TypeScript written in Rust.

Usage:

And then run with:

Next steps:

Feedback is welcome!

- client implementation
- compatibility with the Node.js ecosystem (msgpack parser, adapters, admin UI, ...)
- Source code: https://github.com/socketio/socket.io-deno
- Module: https://deno.land/x/socket_io
```js
import { serve } from "https://deno.land/std@0.150.0/http/server.ts";import { Server } from "https://deno.land/x/socket_io@0.1.1/mod.ts";const io = new Server();io.on("connection", (socket) => {  console.log(`socket ${socket.id} connected`);  socket.emit("hello", "world");  socket.on("disconnect", (reason) => {    console.log(`socket ${socket.id} disconnected due to ${reason}`);  });});await serve(io.handler(), {  port: 3000,});
```

```js
$ deno run --allow-net index.ts
```

```js
import { serve } from "https://deno.land/std@0.150.0/http/server.ts";import { Server } from "https://deno.land/x/socket_io@0.1.1/mod.ts";const io = new Server();io.on("connection", (socket) => {  console.log(`socket ${socket.id} connected`);  socket.emit("hello", "world");  socket.on("disconnect", (reason) => {    console.log(`socket ${socket.id} disconnected due to ${reason}`);  });});await serve(io.handler(), {  port: 3000,});
```

```js
$ deno run --allow-net index.ts
```

# https://socket.io/blog/socket-io-is-on-open-collective

# Socket.IO is on Open Collective

## What is an Open Collective?​

## What would Socket.IO do with my sponsorship?​

## How can I help?​

Open Collective provides a transparent, sustainable, and secure way for people to support and sponsor open source projects. We are joining other great projects (you may have heard about MochaJS, GulpJS or webpack, among lots of other awesome projects) in the quest to ensure the project's sustainability.

From their website:

An Open Collective is a group of people with a shared mission that operates in full transparency.

That allows both individuals and companies to sponsor our mission at Socket.IO (with potential tax benefits).

That will enable the core contributors to spend more time assuring the maintenance of the project. That includes:

triaging issues and pull requests

answering questions on Slack and Stackoverflow (which have been somewhat neglected recently)

updating the documentation (I think a lot has been done recently, but there is still room for improvement!)

Personally I would like to be able to devote a few days a month to the project (I mean a whole day of work, not a few hours taken here and there, usually late in the evening).

The goals in the near future:

To become a sponsor or backer, visit our open collective page and follow the instructions for becoming a part of our collective. Please also take the time to explore the other awesome collectives that people are supporting.

And finally, a big thanks to Pia Mancini and her partners for making this possible.

- triaging issues and pull requests
- answering questions on Slack and Stackoverflow (which have been somewhat neglected recently)
- updating the documentation (I think a lot has been done recently, but there is still room for improvement!)
- keep the 2.0 version as stable as possible
- provide a complete documentation
- add more examples, besides the classic chat
# https://socket.io/blog/socket-io-on-azure-preview

# Socket.IO on Azure

## Socket.IO is used in a wide range of app scenarios​

## Some users seem to have doubts about Socket.IO’s viability for large projects​

## Scaling out a Socket.IO is where developers report the most pain​

Hello developers,

Since we put up an invitation to participate in a user study, we collected hundreds of responses and had the chance to speak in depth with several Socket.IO users. Thank you for your interest in the user study and helping us understand your experience.

In this post, I am going to share with you some notable learnings from the study. It’s our hope that such sharing can shed light on how we can build a stronger community as Socket.IO users, contributors, and cloud providers.

We were pleasantly surprised by the variety of applications built using Socket.IO. Although a fair number of users reported building chat apps using Socket.IO, many shared that they use Socket.IO for identity management to limit the number of active browser tabs, for robotics to control the movement of mobile robots, for multi-player mobile games and for collaborative apps where users can track work items in real-time.

Users new to Socket.IO seem to have the impression that Socket.IO is for small-scale and toy projects and it would be necessary to find alternatives when an app needs to scale. I am happy to report that impression doesn’t reflect the reality; a few Socket.IO users shared that their apps handled 10s of thousand concurrent connections well, powered by running multiple Socket.IO instances behind a load balancer.

Scaling out a Socket.IO app requires a multi-server setup. Essentially, client connections are spread across several Socket.IO server instances. To emit an event to clients connected with different server instances, there needs to be a component to coordinate the message passing. While simple in broad-stroke description, implementation is not particularly straight-forward or familiar to most users. Deploying and maintaining a separate adapter component add additional complexity to the task.

This is an area where we studied the most and thought we could bring the most value to developers. I am happy to share with you that with the input from the open-source community, we brought support for Socket.IO on Azure. With this support, Azure hosts and manages client connections; in other words, developers don’t need an “adapter” component.

- Overview of Socket.IO support on Azure
- Quickstarts of hosting a Socket.IO app on Azure
- Overview of Socket.IO support on Azure
- Quickstarts of hosting a Socket.IO app on Azure
# https://socket.io/blog/socket-io-on-ios

# Socket.IO on iOS

## Overview​

## Introduction​

## Setting up the Project​

### Adding Our Code​

### Handlers​

### Emitting Events​

### Sending JSON​

### Sending Binary​

### Requesting Acks​

### A Note About Multitasking in iOS​

We are pleased to announce the immediate availability of the Socket.IO Swift Client! Youll now be able to write code that runs natively on iOS and OSX, while maintaining the simplicity and expressiveness of the JavaScript client!

To show how you can use it in a real project, Ill show you how to create a small Tic Tac Toe app like the one shown above.

In this tutorial well look at creating a small iOS app that demonstrates socket.io and iOS. If you learn better from looking at code you can look at it here. The point of the tutorial is not to explain developing an iOS app, but to demonstrate how you can incorporate socket.io-client-swift into your projects! So it is assumed you have a basic knowledge of XCode.
Note: This example uses Swift 1.2. However, 1.2 isnt much different from Swift 1.1, and the library has branches for Swift 1.1 and 1.2. The only difference in this guide is I use 1.2s expanded if let construct to avoid nesting.
Note 2: While this library is written in, and meant for, Swift applications, it can be used with Objective-C projects, but will require some extra work (youll probably need to create a Swift class that can interface with your Objective-C code, as not all methods in the client will be available to Objective-C i.e emit, onAny). See this for more information.

I designed socket.io-client-swift to be as close to socket.io-client as I could. So many of the ways you do things in socket.io-client look similar here! This is not a step-by-step tutorial for making a Tic Tac Toe app, only adding the socket.io-client part of it.

From Xcode, create a new project with the layout of single-view iOS application. You can name it whatever you like, Ill be naming mine TicTacIOiOS.
The next step is getting the code for socket.io-client-swift, you can either use git to clone the repo to a directory, or simply download a release. Either way you get it, the process of adding it to your project is the same. Simply drag the folder named SwiftIO to the same place you copied SocketRocket! (Again making sure you select copy.)
And thats it, the hardest part of putting our app together is done! At this point, if you want to test that its setup properly, try building and running the app, it should compile.

Now, assuming youve created your user interface. Its time to add the code that will interface with our socket.io server!
In our demo application we have one UIViewController subclass, named ViewController. All of our code will be added there. First, we need to add a member named socket of type SocketIOClient to our ViewController.

Now, in our overridden viewDidLoad method we want to add two things, a method call that will add our handlers to our socket, and a call to connect our socket.

Now that we have our method calls, its time to implement the method that adds the handlers!

The next handler that well add is the one that tells the app that the game has started.

Now to explain some things. [weak self] is a capture list. It tells the compiler that the reference to self in this closure should not add to the reference count of self. This is so when the socket object goes out of scope, the capture made in the closure doesnt keep it from being deallocated. The first parameter in all .on callbacks is an optional NSArray, it will contain all the data received with the event, or nil. The second parameter in the callback is an optional with the type of AckEmitter. AckEmitter is simply a typealias of (AnyObject...) -&gt; Void. Well see this used later.
The next handler well add is the one for a win.

As mentioned before, this is new syntax for if let introduced in Swift 1.2. It simplifies optional unwrapping (pyramid of doom). The important thing to gather from this handler is that you do not need to force unwrap the array to get the object. Also note that a JSON object will be exposed to Swift as an NSDictionary.
Another thing to note is that for almost all your handlers that have data, youll be doing some kind of optional unwrapping and type casting. This is an unfortunate consequence of working with JavaScript.
The final handler that Ill demonstrate here is the one that handles whether the player wants to play again.

In this simplified example, we simply send an acknowledgement to the server that we dont ever want to play again. Remember that AckEmitter has a variadic definition, so you can send multiple things at once if you wanted.

The next thing you'll probably want to know is how to send events from the client. Youll be pleased to know that it has a form almost exactly the same as socket.io-client!
In our ViewController we have a method that handles when a user wants to make a move. Without going into the logic of that, well show how we send the data to the server.

Thats all you need to do for sending data!
Some other examples of sending which arent covered in our demo are:

As mentioned before, JSON in Swift is best represent as a Dictionary. Thankfully for you, you dont need to worry about turning it into something socket.io will understand, thats all done under-the-hood.

Binary data is also handled by the client, so you dont need to worry about it.

The client can also request that the server send an ack for an event. This is done by using the emitWithAck method which returns an object to which you can add a handler.

As you probably know, iOS is very picky about what you can do in the background. As such, dont expect that your socket connection will survive in the background! Youll probably stop receiving events within seconds of the app going into the background. So its better to create a task that will gracefully close the connection when it enters the background (via AppDelegate), and then reconnect the socket when the app comes back into the foreground.
If you want to learn more about the client, check out the README! We also invite you to contribute by submitting issues, patches, documentation and examples.

```js
import Foundationlet socket = SocketIOClient(socketURL: "localhost:8880")socket.on("important message") {data, ack in    println("Message for you! \(data?[0])")    ack?("I got your message, and I'll send my response")    socket.emit("response", "Hello!")}socket.connect()
```

```js
let socket = SocketIOClient(socketURL: "localhost:8900")
```

```js
self.addHandlers()self.socket.connect()
```

```js
func addHandlers() {    // Our socket handlers go here}
```

```js
// Using a shorthand parameter name for closuresself.socket.onAny {println("Got event: \($0.event), with items: \($0.items)")}
```

```js
self.socket.on("startGame") {[weak self] data, ack in    self?.handleStart()    return}
```

```js
self.socket.on("win") {[weak self] data, ack in    if let name = data?[0] as? String, typeDict = data?[1] as? NSDictionary {        self?.handleWin(name, type: typeDict)    }}
```

```js
self.socket.on("gameReset") {data, ack in    ack?(false)}
```

```js
@IBAction func btnClicked(btn:UIButton) {    let coord:(x:Int, y:Int)    // Long switch statement that determines what coord should be    self.socket.emit("playerMove", coord.x, coord.y)}
```

```js
let myJSON = [    "name": "bob"]socket.emit("jsonTest", myJSON)
```

```js
let data = "Hello, ".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!let data2 = "World".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!socket.emit("dataTest", data, ["world": data2])
```

```js
socket.emitWithAck("needsAck", "test").onAck {data in    println("got ack with data: (data)")}
```

```js
import Foundationlet socket = SocketIOClient(socketURL: "localhost:8880")socket.on("important message") {data, ack in    println("Message for you! \(data?[0])")    ack?("I got your message, and I'll send my response")    socket.emit("response", "Hello!")}socket.connect()
```

```js
socket.io-client-swift
```

```js
if let
```

```js
socket.io-client-swift
```

```js
socket.io-client
```

```js
TicTacIOiOS
```

```js
socket.io-client-swift
```

```js
git
```

```js
socket
```

```js
SocketIOClient
```

```js
let socket = SocketIOClient(socketURL: "localhost:8900")
```

```js
viewDidLoad
```

```js
self.addHandlers()self.socket.connect()
```

```js
func addHandlers() {    // Our socket handlers go here}
```

```js
socket.io-client-swift
```

```js
// Using a shorthand parameter name for closuresself.socket.onAny {println("Got event: \($0.event), with items: \($0.items)")}
```

```js
self.socket.on("startGame") {[weak self] data, ack in    self?.handleStart()    return}
```

```js
[weak self]
```

```js
.on
```

```js
(AnyObject...) -&gt; Void
```

```js
self.socket.on("win") {[weak self] data, ack in    if let name = data?[0] as? String, typeDict = data?[1] as? NSDictionary {        self?.handleWin(name, type: typeDict)    }}
```

```js
if let
```

```js
self.socket.on("gameReset") {data, ack in    ack?(false)}
```

```js
@IBAction func btnClicked(btn:UIButton) {    let coord:(x:Int, y:Int)    // Long switch statement that determines what coord should be    self.socket.emit("playerMove", coord.x, coord.y)}
```

```js
let myJSON = [    "name": "bob"]socket.emit("jsonTest", myJSON)
```

```js
let data = "Hello, ".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!let data2 = "World".dataUsingEncoding(NSUTF8StringEncoding, allowLossyConversion: false)!socket.emit("dataTest", data, ["world": data2])
```

```js
emitWithAck
```

```js
socket.emitWithAck("needsAck", "test").onAck {data in    println("got ack with data: (data)")}
```

# https://socket.io/blog/socket-io-p2p

# Socket.IO P2P

## Usage​

## The Chat example​

Today were very happy to introduce Socket.IO P2P, the easiest way to establish a bidirectional events channel between two peers with a server fallback to provide maximum reliability.

Socket.IO P2P provides an easy and reliable way to setup a WebRTC connection between peers and communicate using the socket.io-protocol.

Socket.IO is used to transport signaling data and as a fallback for clients where the WebRTC PeerConnection is not supported. Adding a simple piece of middleware to your socket.io setup enables this – no need to hand roll your own signaling exchange or set up, deploy and scale new servers.

It only takes a few lines of code to set up the server and client.

Server:

Client:

There are various options for the advanced user. Once signaling data has been exchanged an upgrade event is triggered and an optional callback is called.

We will build a simple chat application, as our tradition dictates, but with P2P capabilities! In this application:

All code from this example is included in the main repository.

We first setup the client with autoUpgrade set to false so that clients can upgrade the connection themselves. Set numClients to 10 to allow up to 10 clients to connect with each other.

Setup the event listeners:

In this example, we want any clients connecting to the server to exchange signaling data with each other. We can use the server component as a simple middleware. Clients will connect on the root namespace.

If we wanted clients to exchange signalling data in rooms, rather than on a whole namespace, we could use the server module upon connection like this.

We then setup listeners to pass messages between clients and to broadcast the go-private event.

Thats all you need: add a little markup we are off! Heres the demo application in action:

Thanks to Guillermo Rauch (@rauchg) for the advice, testing and patience, Harrison Harnisch (@hharnisc) for bug fixes and to Feross Aboukhadijeh (@feross) for providing the underlying WebRTC abstraction simple-peer.

Pull requests, issues, comments and general rantings are all welcome over at the GitHub repo.

- Clients can send text messages to each other. Messages display in a timeline
- Clients connect to each other over socket.io and initially send messages via the server
- Clients can choose to go private – switching the transport to WebRTC
- All clients connected to the server can connect via WebRTC up to a maximum of 10 clients
```js
var io = require('socket.io')(server);var p2p = require('socket.io-p2p-server').Server;io.use(p2p);
```

```js
var P2P = require('socket.io-p2p');var io = require('socket.io-client');var socket = io();var p2p = new P2P(socket);p2p.on('peer-msg', function (data) {  console.log('From a peer %s', data);});
```

```js
var opts = { numClients: 10 }; // connect up to 10 clients at a timevar p2p = new P2P(socket, opts, function(){  console.log('We all speak WebRTC now');});
```

```js
var opts = {autoUpgrade: false, numClients: 10};var p2psocket = new P2P(socket, opts)
```

```js
p2psocket.on('peer-msg', function(data) {  // append message to list});p2psocket.on('go-private', function () {  p2psocket.upgrade(); // upgrade to peerConnection});
```

```js
var server = require('http').createServer();var p2pserver = require('socket.io-p2p-server').Servervar io = require('socket.io')(server);server.listen(3030)io.use(p2pserver);
```

```js
io.on('connection', function(socket) {  socket.on('peer-msg', function(data) {    console.log('Message from peer: %s', data);    socket.broadcast.emit('peer-msg', data);  })  socket.on('go-private', function(data) {    socket.broadcast.emit('go-private', data);  });});
```

```js
PeerConnection
```

```js
var io = require('socket.io')(server);var p2p = require('socket.io-p2p-server').Server;io.use(p2p);
```

```js
var P2P = require('socket.io-p2p');var io = require('socket.io-client');var socket = io();var p2p = new P2P(socket);p2p.on('peer-msg', function (data) {  console.log('From a peer %s', data);});
```

```js
upgrade
```

```js
var opts = { numClients: 10 }; // connect up to 10 clients at a timevar p2p = new P2P(socket, opts, function(){  console.log('We all speak WebRTC now');});
```

```js
autoUpgrade
```

```js
numClients
```

```js
var opts = {autoUpgrade: false, numClients: 10};var p2psocket = new P2P(socket, opts)
```

```js
p2psocket.on('peer-msg', function(data) {  // append message to list});p2psocket.on('go-private', function () {  p2psocket.upgrade(); // upgrade to peerConnection});
```

```js
var server = require('http').createServer();var p2pserver = require('socket.io-p2p-server').Servervar io = require('socket.io')(server);server.listen(3030)io.use(p2pserver);
```

```js
go-private
```

```js
io.on('connection', function(socket) {  socket.on('peer-msg', function(data) {    console.log('Message from peer: %s', data);    socket.broadcast.emit('peer-msg', data);  })  socket.on('go-private', function(data) {    socket.broadcast.emit('go-private', data);  });});
```

# https://socket.io/blog/socket-io-redis-adapter-6-release

# Redis Adapter v6.0.0

## Notable changes​

### All the requests (for inter-node communication) now return a Promise instead of accepting a callback​

### customHook and customRequest methods were removed​

Following the release of Socket.IO v3.0.0, the Redis Adapter was updated and a new release is out: 6.0.0

For reference, the Redis Adapter is used when broadcasting packets across a set of Socket.IO servers. It relies on Redis Pub/Sub mechanism.

More information about how it works: https://github.com/socketio/socket.io-redis/#how-does-it-work-under-the-hood

The release notes can be found here: https://github.com/socketio/socket.io-redis/releases/tag/6.0.0

Please note that the new release is not compatible with Socket.IO v2, and previous versions are not compatible with Socket.IO v3 (compatibility table).

The Redis Adapter exposes additional methods for managing sockets and rooms in a multi-node setup:

Those methods used to accept a callback argument, they will now return a Promise.

Before:

After:

- RedisAdapter.sockets(): returns the list of Socket IDs
- RedisAdapter.allRooms(): returns the list of all rooms.
- RedisAdapter.remoteJoin(id, room): make the socket join the room
- RedisAdapter.remoteLeave(id, room): make the socket leave the room
- RedisAdapter.remoteDisconnect(id, close): disconnect the socket with the given id
```js
io.of('/').adapter.allRooms((err, rooms) => {  console.log(rooms); // an array containing all rooms (across all nodes)});
```

```js
const rooms = await io.of('/').adapter.allRooms();console.log(rooms); // a Set containing all rooms (across all nodes)
```

```js
RedisAdapter.sockets()
```

```js
RedisAdapter.allRooms()
```

```js
RedisAdapter.remoteJoin(id, room)
```

```js
RedisAdapter.remoteLeave(id, room)
```

```js
RedisAdapter.remoteDisconnect(id, close)
```

```js
io.of('/').adapter.allRooms((err, rooms) => {  console.log(rooms); // an array containing all rooms (across all nodes)});
```

```js
const rooms = await io.of('/').adapter.allRooms();console.log(rooms); // a Set containing all rooms (across all nodes)
```

# https://socket.io/blog/socket-io-redis-streams-adapter

# Redis Streams adapter

Hello everyone!

There is a new official adapter for Socket.IO: the Redis Streams adapter.

An Adapter is a server-side component which is responsible for forwarding packets within a cluster of Socket.IO servers.

More information here.

The adapter will use a Redis stream to forward packets between the Socket.IO servers.

The main difference with the existing Redis adapter (which use the Redis Pub/Sub mechanism) is that this adapter will properly handle any temporary disconnection to the Redis server and resume the stream without losing any packets.

See also:

If you have any feedback, feel free to open an issue in the repository.

- Installation steps
- Source code
# https://socket.io/blog/three-new-adapters

# Three new adapters

Hello everyone!

I'm happy to announce that we provide 3 new official adapters:

Any feedback is welcome!

- the Google Cloud Pub/Sub adapter
- the AWS SQS adapter
- the Azure Service Bus adapter
# https://socket.io/demos/chat

https://socketio-chat-h9jt.herokuapp.com/View source code

# https://socket.io/demos/whiteboard

https://socketio-whiteboard-zmx4.herokuapp.com/View source code

# https://socket.io/get-started

## Examples​

## Sample projects​

## Front-end frameworks​

## How to...​

If you are new to Socket.IO, we recommend checking out our tutorial.

- Chat platform
- React
- React Native
- Vue 3
- Next.js
- Nuxt
- NW.js
- deal with cookies
- use with pkg
- use with express-session
- check the latency of the Socket.IO connection
- upload a file
- register a global middleware
- build a basic Socket.IO client
- implement a subscription model
- handle EADDRINUSE errors
- use with Passport.js
- use with JWT
- use with Postman
- get the IP address of the client
- count the number of connected clients
- count the number of connected users
- disconnect a specific client
- Examples
- Sample projects
- Front-end frameworks
- How to...
```js
pkg
```

```js
express-session
```

# https://socket.io/get-started/basic-crud-application

# Basic CRUD application

## Installation​

## Running the frontend​

## Running the server​

## How it works​

## Next steps​

### Server structure​

### Initialization​

### Event handler​

### Tests​

While using Socket.IO (or plain WebSockets) for a basic CRUD application might sound a bit overkill, the ability to easily notify all users is really powerful.

In this guide we will create a basic CRUD (standing for Create/Read/Update/Delete) application, based on the awesome TodoMVC project:

We will cover the following topics:

Let's start!

The code can be found in the examples directory of the main repository:

You should see two directories:

The project is a basic Angular application which was created with the Angular CLI.

To run it:

Then if you open http://localhost:4200 in your browser, you should see:

So far, so good.

Let's focus on the server now:

You can now open several tabs, and the list of todos should magically be synced between them:

Let's detail the duty of each file:

First, let's focus on the createApplication method in the lib/app.ts file:

We create the Socket.IO server with the following options:

So the frontend application, which is served at http://localhost:4200, is allowed to connect.

Documentation:

The <ClientEvents, ServerEvents> part is specific to TypeScript users. It allows to explicitly specify the events that are exchanged between the server and the client, so you get autocompletion and type checking:

Back to our application! We then create our handlers by injecting the application components:

And we register them:

Documentation: Listening to events

Let's focus on the createTodo handler now, in the lib/todo-management/todo.handlers.ts file:

First, we retrieve the Socket instance:

Please note that using an arrow function (createTodo: async () => {}) wouldn't work here, since the this wouldn't point to the Socket instance.

Then, we validate the payload thanks to the great joi library:

Documentation: https://joi.dev/api/

If there are validation errors, we just call the acknowledgement callback and return:

And we handle the error on the client side:

Documentation: Acknowledgements

If the payload successfully matches the schema, we can generate a new ID and persist the entity:

If there is an unexpected error (for example, if the database is down), we call the acknowledgement callback with a generic error message (in order not to expose the internals of our application).

Else, we just call the callback with the new ID:

And finally (that's the magic part), we notify all the other users for the creation:

Documentation: Broadcasting events

On the client-side, we register a handler for this event:

And voilà!

Since we are quite reasonable developers, we'll now add a few tests for our handler. Let's open the test/todo-management/todo.tests.ts file:

The application is created in the beforeEach hook:

And we create two clients, one for sending the payload and the other for receiving the notifications:

Important note: those two clients are explicitly disconnected in the afterEach hook, so they don't prevent the process from exiting.

Documentation: https://mochajs.org/#hooks

Our first test (the happy path) is quite straightforward:

Let's test with an invalid payload too:

You can run the full test suite with npm test:

That's all folks! The other handlers are quite similar to the first one, and will not be detailed here.

Thanks for reading!

- acknowledgements
- broadcasting
- testing
- server/: the server implementation
- angular-client/: a client implementation based on Angular
- vue-client/: a client implementation based on Vue
- index.ts: the entrypoint of the server which creates the components and initializes the application
- app.ts: the application itself, where the Socket.IO server is created, and the handlers are registered
- todo.handlers.ts: the handlers of the operations on the Todo entities
- todo.repository.ts: the repository for persisting/retrieving the Todo entities from the database
- util.ts: some common utility methods that are used in the project
- todo.tests.ts: the integration tests
- CORS configuration
- List of all options
- POST /todos => todo:create
- GET /todos/:id => todo:read
- PUT /todos/:id => todo:update
- ...
- Back to the list of guides
- Private messaging guide
- Documentation
- Installation
- Running the frontend
- Running the server
- How it worksServer structureInitializationEvent handlerTests
- Server structure
- Initialization
- Event handler
- Tests
- Next steps
```js
git clone https://github.com/socketio/socket.io.gitcd socket.io/examples/basic-crud-application/
```

```js
cd angular-clientnpm installnpm start
```

```js
cd ../servernpm installnpm start
```

```js
├── lib│ ├── index.ts│ ├── app.ts│ ├── todo-management│ │ ├── todo.handlers.ts│ | └── todo.repository.ts│ └── util.ts├── package.json├── test│ └── todo-management│   └── todo.tests.ts└── tsconfig.json
```

```js
const io = new Server<ClientEvents, ServerEvents>(httpServer, serverOptions);
```

```js
{  cors: {    origin: ["http://localhost:4200"]  }}
```

```js
const {    createTodo,    readTodo,    updateTodo,    deleteTodo,    listTodo,} = createTodoHandlers(components);
```

```js
io.on("connection", (socket) => {  socket.on("todo:create", createTodo);  socket.on("todo:read", readTodo);  socket.on("todo:update", updateTodo);  socket.on("todo:delete", deleteTodo);  socket.on("todo:list", listTodo);});
```

```js
createTodo: async function (  payload: Todo,  callback: (res: Response<TodoID>) => void) {  const socket: Socket<ClientEvents, ServerEvents> = this;  // ...}
```

```js
const { error, value } = todoSchema.tailor("create").validate(payload, {  abortEarly: false, // return all errors and not just the first one  stripUnknown: true, // remove unknown attributes from the payload});
```

```js
if (error) {  return callback({    error: Errors.INVALID_PAYLOAD,    errorDetails: error.details,  });}
```

```js
// angular-client/src/app/store.tsthis.socket.emit("todo:create", { title, completed: false }, (res) => {  if ("error" in res) {    // handle the error  } else {    // success!  }});
```

```js
value.id = uuid();try {  await todoRepository.save(value);} catch (e) {  return callback({    error: sanitizeErrorMessage(e),  });}
```

```js
callback({  data: value.id,});
```

```js
socket.broadcast.emit("todo:created", value);
```

```js
// angular-client/src/app/store.tsthis.socket.on("todo:created", (todo) => {  this.todos.push(mapTodo(todo));});
```

```js
beforeEach((done) => {  const partialDone = createPartialDone(2, done);  httpServer = createServer();  todoRepository = new InMemoryTodoRepository();  createApplication(httpServer, {    todoRepository,  });  // ...});
```

```js
httpServer.listen(() => {  const port = (httpServer.address() as AddressInfo).port;  socket = io(`http://localhost:${port}`);  socket.on("connect", partialDone);  otherSocket = io(`http://localhost:${port}`);  otherSocket.on("connect", partialDone);});
```

```js
describe("create todo", () => {  it("should create a todo entity", (done) => {    const partialDone = createPartialDone(2, done);    // send the payload    socket.emit(      "todo:create",      {        title: "lorem ipsum",        completed: false,      },      async (res) => {        if ("error" in res) {          return done(new Error("should not happen"));        }        expect(res.data).to.be.a("string");        // check the entity stored in the database        const storedEntity = await todoRepository.findById(res.data);        expect(storedEntity).to.eql({          id: res.data,          title: "lorem ipsum",          completed: false,        });        partialDone();      }    );    // wait for the notification of the creation    otherSocket.on("todo:created", (todo) => {      expect(todo.id).to.be.a("string");      expect(todo.title).to.eql("lorem ipsum");      expect(todo.completed).to.eql(false);      partialDone();    });  });});
```

```js
describe("create todo", () => {  it("should fail with an invalid entity", (done) => {    const incompleteTodo = {      completed: "false",      description: true,    };    socket.emit("todo:create", incompleteTodo, (res) => {      if (!("error" in res)) {        return done(new Error("should not happen"));      }      expect(res.error).to.eql("invalid payload");      // check the details of the validation error      expect(res.errorDetails).to.eql([        {          message: '"title" is required',          path: ["title"],          type: "any.required",        },      ]);      done();    });    // no notification should be received    otherSocket.on("todo:created", () => {      done(new Error("should not happen"));    });  });});
```

```js
examples
```

```js
git clone https://github.com/socketio/socket.io.gitcd socket.io/examples/basic-crud-application/
```

```js
server/
```

```js
angular-client/
```

```js
vue-client/
```

```js
cd angular-clientnpm installnpm start
```

```js
cd ../servernpm installnpm start
```

```js
├── lib│ ├── index.ts│ ├── app.ts│ ├── todo-management│ │ ├── todo.handlers.ts│ | └── todo.repository.ts│ └── util.ts├── package.json├── test│ └── todo-management│   └── todo.tests.ts└── tsconfig.json
```

```js
index.ts
```

```js
app.ts
```

```js
todo.handlers.ts
```

```js
todo.repository.ts
```

```js
util.ts
```

```js
todo.tests.ts
```

```js
createApplication
```

```js
lib/app.ts
```

```js
const io = new Server<ClientEvents, ServerEvents>(httpServer, serverOptions);
```

```js
{  cors: {    origin: ["http://localhost:4200"]  }}
```

```js
http://localhost:4200
```

```js
<ClientEvents, ServerEvents>
```

```js
const {    createTodo,    readTodo,    updateTodo,    deleteTodo,    listTodo,} = createTodoHandlers(components);
```

```js
io.on("connection", (socket) => {  socket.on("todo:create", createTodo);  socket.on("todo:read", readTodo);  socket.on("todo:update", updateTodo);  socket.on("todo:delete", deleteTodo);  socket.on("todo:list", listTodo);});
```

```js
:create
```

```js
:read
```

```js
POST /todos
```

```js
todo:create
```

```js
GET /todos/:id
```

```js
todo:read
```

```js
PUT /todos/:id
```

```js
todo:update
```

```js
createTodo
```

```js
lib/todo-management/todo.handlers.ts
```

```js
createTodo: async function (  payload: Todo,  callback: (res: Response<TodoID>) => void) {  const socket: Socket<ClientEvents, ServerEvents> = this;  // ...}
```

```js
createTodo: async () => {}
```

```js
this
```

```js
joi
```

```js
const { error, value } = todoSchema.tailor("create").validate(payload, {  abortEarly: false, // return all errors and not just the first one  stripUnknown: true, // remove unknown attributes from the payload});
```

```js
if (error) {  return callback({    error: Errors.INVALID_PAYLOAD,    errorDetails: error.details,  });}
```

```js
// angular-client/src/app/store.tsthis.socket.emit("todo:create", { title, completed: false }, (res) => {  if ("error" in res) {    // handle the error  } else {    // success!  }});
```

```js
value.id = uuid();try {  await todoRepository.save(value);} catch (e) {  return callback({    error: sanitizeErrorMessage(e),  });}
```

```js
callback({  data: value.id,});
```

```js
socket.broadcast.emit("todo:created", value);
```

```js
// angular-client/src/app/store.tsthis.socket.on("todo:created", (todo) => {  this.todos.push(mapTodo(todo));});
```

```js
test/todo-management/todo.tests.ts
```

```js
beforeEach
```

```js
beforeEach((done) => {  const partialDone = createPartialDone(2, done);  httpServer = createServer();  todoRepository = new InMemoryTodoRepository();  createApplication(httpServer, {    todoRepository,  });  // ...});
```

```js
httpServer.listen(() => {  const port = (httpServer.address() as AddressInfo).port;  socket = io(`http://localhost:${port}`);  socket.on("connect", partialDone);  otherSocket = io(`http://localhost:${port}`);  otherSocket.on("connect", partialDone);});
```

```js
afterEach
```

```js
describe("create todo", () => {  it("should create a todo entity", (done) => {    const partialDone = createPartialDone(2, done);    // send the payload    socket.emit(      "todo:create",      {        title: "lorem ipsum",        completed: false,      },      async (res) => {        if ("error" in res) {          return done(new Error("should not happen"));        }        expect(res.data).to.be.a("string");        // check the entity stored in the database        const storedEntity = await todoRepository.findById(res.data);        expect(storedEntity).to.eql({          id: res.data,          title: "lorem ipsum",          completed: false,        });        partialDone();      }    );    // wait for the notification of the creation    otherSocket.on("todo:created", (todo) => {      expect(todo.id).to.be.a("string");      expect(todo.title).to.eql("lorem ipsum");      expect(todo.completed).to.eql(false);      partialDone();    });  });});
```

```js
describe("create todo", () => {  it("should fail with an invalid entity", (done) => {    const incompleteTodo = {      completed: "false",      description: true,    };    socket.emit("todo:create", incompleteTodo, (res) => {      if (!("error" in res)) {        return done(new Error("should not happen"));      }      expect(res.error).to.eql("invalid payload");      // check the details of the validation error      expect(res.errorDetails).to.eql([        {          message: '"title" is required',          path: ["title"],          type: "any.required",        },      ]);      done();    });    // no notification should be received    otherSocket.on("todo:created", () => {      done(new Error("should not happen"));    });  });});
```

```js
npm test
```

# https://socket.io/get-started/chat

# Get started

## Introduction​

## The web framework​

## Serving HTML​

## Integrating Socket.IO​

## Emitting events​

## Broadcasting​

## Homework​

## Getting this example​

In this guide we’ll create a basic chat application. It requires almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal for users of all knowledge levels.

Writing a chat application with popular web applications stacks like LAMP (PHP) has normally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.

Sockets have traditionally been the solution around which most real-time chat systems are architected, providing a bi-directional communication channel between a client and a server.

This means that the server can push messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.

The first goal is to set up a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework express to this end. Make sure Node.JS is installed.

First let’s create a package.json manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine chat-example).

The "name" property must be unique, you cannot use a value like "socket.io" or "express", because npm will complain when installing the dependency.

Now, in order to easily populate the dependencies property with the things we need, we’ll use npm install:

Once it's installed we can create an index.js file that will set up our application.

This means that:

If you run node index.js you should see the following:

And if you point your browser to http://localhost:3000:

So far in index.js we’re calling res.send and passing it a string of HTML. Our code would look very confusing if we just placed our entire application’s HTML there, so instead we're going to create a index.html file and serve that instead.

Let’s refactor our route handler to use sendFile instead.

Put the following in your index.html file:

If you restart the process (by hitting Control+C and running node index.js again) and refresh the page it should look like this:

Socket.IO is composed of two parts:

During development, socket.io serves the client automatically for us, as we’ll see, so for now we only have to install one module:

That will install the module and add the dependency to package.json. Now let’s edit index.js to add it:

Notice that I initialize a new instance of socket.io by passing the server (the HTTP server) object. Then I listen on the connection event for incoming sockets and log it to the console.

Now in index.html add the following snippet before the </body> (end body tag):

That’s all it takes to load the socket.io-client, which exposes an io global (and the endpoint GET /socket.io/socket.io.js), and then connect.

If you would like to use the local version of the client-side JS file, you can find it at node_modules/socket.io/client-dist/socket.io.js.

You can also use a CDN instead of the local files (e.g. <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>).

Notice that I’m not specifying any URL when I call io(), since it defaults to trying to connect to the host that serves the page.

If you're behind a reverse proxy such as apache or nginx please take a look at the documentation for it.

If you're hosting your app in a folder that is not the root of your website (e.g., https://example.com/chatapp) then you also need to specify the path in both the server and the client.

If you now restart the process (by hitting Control+C and running node index.js again) and then refresh the webpage you should see the console print “a user connected”.

Try opening several tabs, and you’ll see several messages.

Each socket also fires a special disconnect event:

Then if you refresh a tab several times you can see it in action.

The main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and binary data is supported too.

Let’s make it so that when the user types in a message, the server gets it as a chat message event. The script section in index.html should now look as follows:

And in index.js we print out the chat message event:

The result should be like the following video:

The next goal is for us to emit the event from the server to the rest of the users.

In order to send an event to everyone, Socket.IO gives us the io.emit() method.

If you want to send a message to everyone except for a certain emitting socket, we have the broadcast flag for emitting from that socket:

In this case, for the sake of simplicity we’ll send the message to everyone, including the sender.

And on the client side when we capture a chat message event we’ll include it in the page. The total client-side JavaScript code now amounts to:

And that completes our chat application, in about 20 lines of code! This is what it looks like:

Here are some ideas to improve the application:

You can find it on GitHub here.

- Express initializes app to be a function handler that you can supply to an HTTP server (as seen in line 4).
- We define a route handler / that gets called when we hit our website home.
- We make the http server listen on port 3000.
- A server that integrates with (or mounts on) the Node.JS HTTP Server socket.io
- A client library that loads on the browser side socket.io-client
- Broadcast a message to connected users when someone connects or disconnects.
- Add support for nicknames.
- Don’t send the same message to the user that sent it. Instead, append the message directly as soon as they press enter.
- Add “{user} is typing” functionality.
- Show who’s online.
- Add private messaging.
- Share your improvements!
- Introduction
- The web framework
- Serving HTML
- Integrating Socket.IO
- Emitting events
- Broadcasting
- Homework
- Getting this example
```js
{  "name": "socket-chat-example",  "version": "0.0.1",  "description": "my first socket.io app",  "dependencies": {}}
```

```js
npm install express@4
```

```js
const express = require('express');const app = express();const http = require('http');const server = http.createServer(app);app.get('/', (req, res) => {  res.send('<h1>Hello world</h1>');});server.listen(3000, () => {  console.log('listening on *:3000');});
```

```js
app.get('/', (req, res) => {  res.sendFile(__dirname + '/index.html');});
```

```js
<!DOCTYPE html><html>  <head>    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>  </body></html>
```

```js
npm install socket.io
```

```js
const express = require('express');const app = express();const http = require('http');const server = http.createServer(app);const { Server } = require("socket.io");const io = new Server(server);app.get('/', (req, res) => {  res.sendFile(__dirname + '/index.html');});io.on('connection', (socket) => {  console.log('a user connected');});server.listen(3000, () => {  console.log('listening on *:3000');});
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();</script>
```

```js
io.on('connection', (socket) => {  console.log('a user connected');  socket.on('disconnect', () => {    console.log('user disconnected');  });});
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var form = document.getElementById('form');  var input = document.getElementById('input');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });</script>
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    console.log('message: ' + msg);  });});
```

```js
io.emit('some event', { someProperty: 'some value', otherProperty: 'other value' }); // This will emit the event to all connected sockets
```

```js
io.on('connection', (socket) => {  socket.broadcast.emit('hi');});
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    io.emit('chat message', msg);  });});
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var messages = document.getElementById('messages');  var form = document.getElementById('form');  var input = document.getElementById('input');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', function(msg) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);  });</script>
```

```js
git clone https://github.com/socketio/chat-example.git
```

```js
express
```

```js
package.json
```

```js
chat-example
```

```js
{  "name": "socket-chat-example",  "version": "0.0.1",  "description": "my first socket.io app",  "dependencies": {}}
```

```js
dependencies
```

```js
npm install
```

```js
npm install express@4
```

```js
index.js
```

```js
const express = require('express');const app = express();const http = require('http');const server = http.createServer(app);app.get('/', (req, res) => {  res.send('<h1>Hello world</h1>');});server.listen(3000, () => {  console.log('listening on *:3000');});
```

```js
app
```

```js
node index.js
```

```js
http://localhost:3000
```

```js
index.js
```

```js
res.send
```

```js
index.html
```

```js
sendFile
```

```js
app.get('/', (req, res) => {  res.sendFile(__dirname + '/index.html');});
```

```js
index.html
```

```js
<!DOCTYPE html><html>  <head>    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>  </body></html>
```

```js
node index.js
```

```js
socket.io
```

```js
npm install socket.io
```

```js
package.json
```

```js
index.js
```

```js
const express = require('express');const app = express();const http = require('http');const server = http.createServer(app);const { Server } = require("socket.io");const io = new Server(server);app.get('/', (req, res) => {  res.sendFile(__dirname + '/index.html');});io.on('connection', (socket) => {  console.log('a user connected');});server.listen(3000, () => {  console.log('listening on *:3000');});
```

```js
socket.io
```

```js
server
```

```js
connection
```

```js
</body>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();</script>
```

```js
socket.io-client
```

```js
GET /socket.io/socket.io.js
```

```js
node_modules/socket.io/client-dist/socket.io.js
```

```js
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
```

```js
io()
```

```js
https://example.com/chatapp
```

```js
node index.js
```

```js
disconnect
```

```js
io.on('connection', (socket) => {  console.log('a user connected');  socket.on('disconnect', () => {    console.log('user disconnected');  });});
```

```js
chat message
```

```js
script
```

```js
index.html
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var form = document.getElementById('form');  var input = document.getElementById('input');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });</script>
```

```js
index.js
```

```js
chat message
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    console.log('message: ' + msg);  });});
```

```js
io.emit()
```

```js
io.emit('some event', { someProperty: 'some value', otherProperty: 'other value' }); // This will emit the event to all connected sockets
```

```js
broadcast
```

```js
io.on('connection', (socket) => {  socket.broadcast.emit('hi');});
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    io.emit('chat message', msg);  });});
```

```js
chat message
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var messages = document.getElementById('messages');  var form = document.getElementById('form');  var input = document.getElementById('input');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', function(msg) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);  });</script>
```

```js
git clone https://github.com/socketio/chat-example.git
```

# https://socket.io/get-started/private-messaging-part-1

# Private messaging - Part I

## Installation​

## Running the frontend​

## Running the server​

## How it works​

## Review​

### Server initialization​

### Client initialization​

### Selection of the username​

### Listing all users​

### Private messaging​

### Connection status​

In this guide we will create the following application:

We will cover the following topics:

Prerequisites:

This guide has four distinct parts:

Let's start!

First, let's retrieve the initial implementation of our chat application:

Here's what you should see in the current directory:

The code for the frontend is located in the src directory, while the code for the server is in the server directory.

The project is a basic Vue.js application which was created with @vue/cli.

To run it:

Then if you open http://localhost:8080 in your browser, you should see:

Now, let's start the server:

Your console should print:

So far, so good! You should be able to open several tabs and send a few messages between them:

The Socket.IO server is initialized in the server/index.js file:

Here, we create a Socket.IO server and attach it to a Node.js HTTP server.

Documentation:

The cors configuration is needed so that HTTP requests sent by the frontend (running at http://localhost:8080) are allowed to reach the server (running at http://localhost:3000, so we are in a cross-origin situation).

Documentation:

The Socket.IO client is initialized in the src/socket.js file:

autoConnect is set to false so the connection is not established right away. We will manually call socket.connect() later, once the user has selected a username.

Documentation: Socket.IO client initialization

We also register a catch-all listener, which is very useful during development:

So that any event received by the client will be printed in the console.

Now, let's move to src/App.vue:

The application is started with usernameAlreadySelected set to false, so the form to select a username is displayed:

Once the form is submitted, we'll reach the onUsernameSelection method:

We attach the username in the auth object, and then call socket.connect().

If you open your network tab in your developer tools, you should see a few HTTP requests:

If you see this, it means that the connection was successfully established.

On the server-side, we register a middleware which checks the username and allows the connection:

The username is added as an attribute of the socket object, in order to be reused later. You can attach any attribute, as long as you don't overwrite an existing one like socket.id or socket.handshake.

Documentation:

On the client-side (src/App.vue), we add a handler for the connect_error event:

The connect_error event will be emitted upon connection failure:

Please note that, in the function above, the low-level errors are not handled (the user could be notified of the connection failure, for example).

Last note: the handler for the connect_error is removed in the destroyed hook:

So the listeners registered by our App component are cleaned up when the component is destroyed.

Upon connection, we send all existing users to the client:

We are looping over the io.of("/").sockets object, which is a Map of all currently connected Socket instances, indexed by ID.

Two remarks here:

We'll come back to this later.

On the client-side (src/components/Chat.vue), we register a handler for the users event:

We also notify the existing users:

Server

socket.broadcast.emit("user connected", ...) will emit to all connected clients, except the socket itself.

The other form of broadcasting, io.emit("user connected", ...), would have sent the "user connected" event to all connected clients, including the new user.

Documentation: broadcasting events

Client

The list of users is displayed on the left panel:

When selecting a given user, the right panel displays a chat window:

Here is how private messages are implemented:

Client (sender)

Server

Here, we are using the concept of Rooms. These are channels that Socket instances can join and leave, and you can broadcast to all clients in a room.

We are relying on the fact that the Socket instance automatically joins the room identified by its id (socket.join(socket.id) is called for you).

So socket.to(to).emit("private message", ...) emits to the given user ID.

Client (recipient)

On the client-side, the Socket instance emits two special events:

Those events can be used to track the state of the connection (in src/components/Chat.vue):

You can test it by stopping the server:

OK, so... what we have for now is great, but there is an obvious issue:

Explanation: a new Socket ID is generated upon reconnection, so every time a user gets disconnected and reconnects, it will get a new user ID.

That's why we need a persistent user ID, which is the subject of the 2nd part of this guide.

Thanks for reading!

- middlewares
- rooms
- scaling to multiple Socket.IO servers
- basic knowledge of Socket.IO
- basic knowledge of Vue.js (though knowledge of another popular frontend framework should work too)
- basic knowledge of Redis (for the final part)
- Part I (current): initial implementation
- Part II: persistent user ID
- Part III: persistent messages
- Part IV: scaling up
- Node.js documentation
- Socket.IO server initialization
- Cross-Origin Resource Sharing (CORS)
- Socket.IO CORS configuration
- the Engine.IO handshake (contains the session ID — here, zBjrh...AAAK — that is used in subsequent requests)
- the Socket.IO handshake request (contains the value of the auth option)
- the Socket.IO handshake response (contains the Socket#id)
- the WebSocket connection
- the first HTTP long-polling request, which is closed once the WebSocket connection is established
- middlewares
- the Socket instance
- due to the low-level errors (when the server is down for example)
- due to middleware errors
- we are using the socket.id as the user ID of our application
- we are only retrieving the users of the current Socket.IO server (not suitable when scaling up)
- connect: upon connection or reconnection
- disconnect: upon disconnection
- Installation
- Running the frontend
- Running the server
- How it worksServer initializationClient initializationSelection of the usernameListing all usersPrivate messagingConnection status
- Server initialization
- Client initialization
- Selection of the username
- Listing all users
- Private messaging
- Connection status
- Review
```js
git clone https://github.com/socketio/socket.io.gitcd socket.io/examples/private-messaginggit checkout examples/private-messaging-part-1
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── index.js│   ├── package.json└── src    ├── App.vue    ├── components    │   ├── Chat.vue    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
npm installnpm run serve
```

```js
cd servernpm installnpm start
```

```js
server listening at http://localhost:3000
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  cors: {    origin: "http://localhost:8080",  },});
```

```js
import { io } from "socket.io-client";const URL = "http://localhost:3000";const socket = io(URL, { autoConnect: false });export default socket;
```

```js
socket.onAny((event, ...args) => {  console.log(event, args);});
```

```js
onUsernameSelection(username) {  this.usernameAlreadySelected = true;  socket.auth = { username };  socket.connect();}
```

```js
io.use((socket, next) => {  const username = socket.handshake.auth.username;  if (!username) {    return next(new Error("invalid username"));  }  socket.username = username;  next();});
```

```js
socket.on("connect_error", (err) => {  if (err.message === "invalid username") {    this.usernameAlreadySelected = false;  }});
```

```js
destroyed() {  socket.off("connect_error");}
```

```js
io.on("connection", (socket) => {  const users = [];  for (let [id, socket] of io.of("/").sockets) {    users.push({      userID: id,      username: socket.username,    });  }  socket.emit("users", users);  // ...});
```

```js
socket.on("users", (users) => {  users.forEach((user) => {    user.self = user.userID === socket.id;    initReactiveProperties(user);  });  // put the current user first, and then sort by username  this.users = users.sort((a, b) => {    if (a.self) return -1;    if (b.self) return 1;    if (a.username < b.username) return -1;    return a.username > b.username ? 1 : 0;  });});
```

```js
io.on("connection", (socket) => {  // notify existing users  socket.broadcast.emit("user connected", {    userID: socket.id,    username: socket.username,  });});
```

```js
socket.on("user connected", (user) => {  initReactiveProperties(user);  this.users.push(user);});
```

```js
onMessage(content) {  if (this.selectedUser) {    socket.emit("private message", {      content,      to: this.selectedUser.userID,    });    this.selectedUser.messages.push({      content,      fromSelf: true,    });  }}
```

```js
socket.on("private message", ({ content, to }) => {  socket.to(to).emit("private message", {    content,    from: socket.id,  });});
```

```js
socket.on("private message", ({ content, from }) => {  for (let i = 0; i < this.users.length; i++) {    const user = this.users[i];    if (user.userID === from) {      user.messages.push({        content,        fromSelf: false,      });      if (user !== this.selectedUser) {        user.hasNewMessages = true;      }      break;    }  }});
```

```js
socket.on("connect", () => {  this.users.forEach((user) => {    if (user.self) {      user.connected = true;    }  });});socket.on("disconnect", () => {  this.users.forEach((user) => {    if (user.self) {      user.connected = false;    }  });});
```

```js
git clone https://github.com/socketio/socket.io.gitcd socket.io/examples/private-messaginggit checkout examples/private-messaging-part-1
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── index.js│   ├── package.json└── src    ├── App.vue    ├── components    │   ├── Chat.vue    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
src
```

```js
server
```

```js
@vue/cli
```

```js
npm installnpm run serve
```

```js
cd servernpm installnpm start
```

```js
server listening at http://localhost:3000
```

```js
server/index.js
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  cors: {    origin: "http://localhost:8080",  },});
```

```js
cors
```

```js
http://localhost:8080
```

```js
http://localhost:3000
```

```js
src/socket.js
```

```js
import { io } from "socket.io-client";const URL = "http://localhost:3000";const socket = io(URL, { autoConnect: false });export default socket;
```

```js
autoConnect
```

```js
false
```

```js
socket.connect()
```

```js
socket.onAny((event, ...args) => {  console.log(event, args);});
```

```js
src/App.vue
```

```js
usernameAlreadySelected
```

```js
false
```

```js
onUsernameSelection
```

```js
onUsernameSelection(username) {  this.usernameAlreadySelected = true;  socket.auth = { username };  socket.connect();}
```

```js
username
```

```js
auth
```

```js
socket.connect()
```

```js
zBjrh...AAAK
```

```js
auth
```

```js
io.use((socket, next) => {  const username = socket.handshake.auth.username;  if (!username) {    return next(new Error("invalid username"));  }  socket.username = username;  next();});
```

```js
username
```

```js
socket
```

```js
socket.id
```

```js
socket.handshake
```

```js
src/App.vue
```

```js
connect_error
```

```js
socket.on("connect_error", (err) => {  if (err.message === "invalid username") {    this.usernameAlreadySelected = false;  }});
```

```js
connect_error
```

```js
connect_error
```

```js
destroyed() {  socket.off("connect_error");}
```

```js
App
```

```js
io.on("connection", (socket) => {  const users = [];  for (let [id, socket] of io.of("/").sockets) {    users.push({      userID: id,      username: socket.username,    });  }  socket.emit("users", users);  // ...});
```

```js
io.of("/").sockets
```

```js
socket.id
```

```js
src/components/Chat.vue
```

```js
users
```

```js
socket.on("users", (users) => {  users.forEach((user) => {    user.self = user.userID === socket.id;    initReactiveProperties(user);  });  // put the current user first, and then sort by username  this.users = users.sort((a, b) => {    if (a.self) return -1;    if (b.self) return 1;    if (a.username < b.username) return -1;    return a.username > b.username ? 1 : 0;  });});
```

```js
io.on("connection", (socket) => {  // notify existing users  socket.broadcast.emit("user connected", {    userID: socket.id,    username: socket.username,  });});
```

```js
socket.broadcast.emit("user connected", ...)
```

```js
socket
```

```js
io.emit("user connected", ...)
```

```js
socket.on("user connected", (user) => {  initReactiveProperties(user);  this.users.push(user);});
```

```js
onMessage(content) {  if (this.selectedUser) {    socket.emit("private message", {      content,      to: this.selectedUser.userID,    });    this.selectedUser.messages.push({      content,      fromSelf: true,    });  }}
```

```js
socket.on("private message", ({ content, to }) => {  socket.to(to).emit("private message", {    content,    from: socket.id,  });});
```

```js
socket.join(socket.id)
```

```js
socket.to(to).emit("private message", ...)
```

```js
socket.on("private message", ({ content, from }) => {  for (let i = 0; i < this.users.length; i++) {    const user = this.users[i];    if (user.userID === from) {      user.messages.push({        content,        fromSelf: false,      });      if (user !== this.selectedUser) {        user.hasNewMessages = true;      }      break;    }  }});
```

```js
connect
```

```js
disconnect
```

```js
src/components/Chat.vue
```

```js
socket.on("connect", () => {  this.users.forEach((user) => {    if (user.self) {      user.connected = true;    }  });});socket.on("disconnect", () => {  this.users.forEach((user) => {    if (user.self) {      user.connected = false;    }  });});
```

# https://socket.io/get-started/private-messaging-part-2

# Private messaging - Part II

## Installation​

## How it works​

## Review​

### Persistent session ID​

### Private messaging (updated)​

### Disconnection handler​

This guide has four distinct parts:

Here's where we were at the end of the 1st part:

Exchanging private messages is currently based on the socket.id attribute, which works well but is problematic here because this ID is only valid for the current Socket.IO session and will change every time the low-level connection between the client and the server is severed.

So, every time the user reconnects, a new user will be created:

Which is... not that great. Let's fix this!

Let's checkout the branch for part II:

Here's what you should see in the current directory:

The complete diff can be found here.

On the server-side (server/index.js), we create two random values:

The session details are then sent to the user:

On the client-side (src/App.vue), we store the session ID in the localStorage:

Actually, there were several possible implementations:

Here, we chose the localStorage option, so all your tabs will be linked to the same session ID, which means that:

And finally, we fetch the session ID on application startup:

You should now be able to refresh your tab without losing your session:

On the server-side, the session is saved in an in-memory store (server/sessionStore.js):

Again, this will only work with a single Socket.IO server, we'll come back to this in the 4th part of this guide.

The private messaging is now based on the userID which is generated on the server-side, so we need to do two things:

Here's what happens:

With socket.to(to).to(socket.userID).emit(...), we broadcast in both the recipient and the sender (excluding the given Socket instance) rooms.

So now we have:

On the server-side, the Socket instance emits two special events: disconnecting and disconnect

We need to update our "disconnect" handler, because the session can now be shared across tabs:

The allSockets() method returns a Set containing the ID of all Socket instances that are in the given room.

Note: we could also have used the io.of("/").sockets object, like in part I, but the allSockets() method also works with multiple Socket.IO servers, which will be useful when scaling up.

Documentation: allSockets() method

OK, so… what we have now is better, but there is yet another issue: the messages are not actually persisted on the server. As a consequence, when the user reloads the page, it loses all its existing conversations.

This could be fixed for example by saving the messages in the localStorage of the browser, but there is another more annoying repercussion:

We will try to fix this in the 3rd part of this guide.

Thanks for reading!

- Part I: initial implementation
- Part II (current): persistent user ID
- Part III: persistent messages
- Part IV: scaling up
- a session ID, private, which will be used to authenticate the user upon reconnection
- a user ID, public, which will be used as an identifier to exchange messages
- no storage at all: reconnection will preserve the session, but refreshing the page will lose it
- sessionStorage: reconnection & refreshing the page will preserve the session
- localStorage: reconnection & refreshing the page will preserve the session + this session will be shared across the browser tabs
- you can chat with yourself (yay!)
- you now need to use another browser (or the private mode of your browser) to create another peer
- make the Socket instance join the associated room:
- update the forwarding handler:
- when the sender gets disconnected, all the packets it sends are buffered until reconnection (which is great, in most cases)
- but when the recipient gets disconnected, the packets are lost, since there is no listening Socket instance in the given room
- Installation
- How it worksPersistent session IDPrivate messaging (updated)Disconnection handler
- Persistent session ID
- Private messaging (updated)
- Disconnection handler
- Review
```js
git checkout examples/private-messaging-part-2
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── index.js (updated)│   ├── package.json│   └── sessionStore.js (created)└── src    ├── App.vue (updated)    ├── components    │   ├── Chat.vue (updated)    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
io.use((socket, next) => {  const sessionID = socket.handshake.auth.sessionID;  if (sessionID) {    // find existing session    const session = sessionStore.findSession(sessionID);    if (session) {      socket.sessionID = sessionID;      socket.userID = session.userID;      socket.username = session.username;      return next();    }  }  const username = socket.handshake.auth.username;  if (!username) {    return next(new Error("invalid username"));  }  // create new session  socket.sessionID = randomId();  socket.userID = randomId();  socket.username = username;  next();});
```

```js
io.on("connection", (socket) => {  // ...  socket.emit("session", {    sessionID: socket.sessionID,    userID: socket.userID,  });  // ...});
```

```js
socket.on("session", ({ sessionID, userID }) => {  // attach the session ID to the next reconnection attempts  socket.auth = { sessionID };  // store it in the localStorage  localStorage.setItem("sessionID", sessionID);  // save the ID of the user  socket.userID = userID;});
```

```js
created() {  const sessionID = localStorage.getItem("sessionID");  if (sessionID) {    this.usernameAlreadySelected = true;    socket.auth = { sessionID };    socket.connect();  }  // ...}
```

```js
class InMemorySessionStore extends SessionStore {  constructor() {    super();    this.sessions = new Map();  }  findSession(id) {    return this.sessions.get(id);  }  saveSession(id, session) {    this.sessions.set(id, session);  }  findAllSessions() {    return [...this.sessions.values()];  }}
```

```js
io.on("connection", (socket) => {  // ...  socket.join(socket.userID);  // ...});
```

```js
io.on("connection", (socket) => {  // ...  socket.on("private message", ({ content, to }) => {    socket.to(to).to(socket.userID).emit("private message", {      content,      from: socket.userID,      to,    });  });  // ...});
```

```js
io.on("connection", (socket) => {  // ...  socket.on("disconnect", async () => {    const matchingSockets = await io.in(socket.userID).allSockets();    const isDisconnected = matchingSockets.size === 0;    if (isDisconnected) {      // notify other users      socket.broadcast.emit("user disconnected", socket.userID);      // update the connection status of the session      sessionStore.saveSession(socket.sessionID, {        userID: socket.userID,        username: socket.username,        connected: false,      });    }  });});
```

```js
socket.id
```

```js
git checkout examples/private-messaging-part-2
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── index.js (updated)│   ├── package.json│   └── sessionStore.js (created)└── src    ├── App.vue (updated)    ├── components    │   ├── Chat.vue (updated)    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
server/index.js
```

```js
io.use((socket, next) => {  const sessionID = socket.handshake.auth.sessionID;  if (sessionID) {    // find existing session    const session = sessionStore.findSession(sessionID);    if (session) {      socket.sessionID = sessionID;      socket.userID = session.userID;      socket.username = session.username;      return next();    }  }  const username = socket.handshake.auth.username;  if (!username) {    return next(new Error("invalid username"));  }  // create new session  socket.sessionID = randomId();  socket.userID = randomId();  socket.username = username;  next();});
```

```js
io.on("connection", (socket) => {  // ...  socket.emit("session", {    sessionID: socket.sessionID,    userID: socket.userID,  });  // ...});
```

```js
src/App.vue
```

```js
socket.on("session", ({ sessionID, userID }) => {  // attach the session ID to the next reconnection attempts  socket.auth = { sessionID };  // store it in the localStorage  localStorage.setItem("sessionID", sessionID);  // save the ID of the user  socket.userID = userID;});
```

```js
localStorage
```

```js
created() {  const sessionID = localStorage.getItem("sessionID");  if (sessionID) {    this.usernameAlreadySelected = true;    socket.auth = { sessionID };    socket.connect();  }  // ...}
```

```js
server/sessionStore.js
```

```js
class InMemorySessionStore extends SessionStore {  constructor() {    super();    this.sessions = new Map();  }  findSession(id) {    return this.sessions.get(id);  }  saveSession(id, session) {    this.sessions.set(id, session);  }  findAllSessions() {    return [...this.sessions.values()];  }}
```

```js
userID
```

```js
io.on("connection", (socket) => {  // ...  socket.join(socket.userID);  // ...});
```

```js
io.on("connection", (socket) => {  // ...  socket.on("private message", ({ content, to }) => {    socket.to(to).to(socket.userID).emit("private message", {      content,      from: socket.userID,      to,    });  });  // ...});
```

```js
socket.to(to).to(socket.userID).emit(...)
```

```js
io.on("connection", (socket) => {  // ...  socket.on("disconnect", async () => {    const matchingSockets = await io.in(socket.userID).allSockets();    const isDisconnected = matchingSockets.size === 0;    if (isDisconnected) {      // notify other users      socket.broadcast.emit("user disconnected", socket.userID);      // update the connection status of the session      sessionStore.saveSession(socket.sessionID, {        userID: socket.userID,        username: socket.username,        connected: false,      });    }  });});
```

```js
allSockets()
```

```js
io.of("/").sockets
```

```js
allSockets()
```

# https://socket.io/get-started/private-messaging-part-3

# Private messaging - Part III

## Installation​

## How it works​

## Review​

### Persistent messages​

This guide has four distinct parts:

Here's where we were at the end of the 2nd part:

All is working pretty well, but there is a last issue which is quite annoying:

There are multiple solutions to this problem, and we will go for the easiest to implement: store all the messages on the server-side.

Note: this 3rd part will be brief, but it underlines an important property of Socket.IO: you cannot rely on the status of the connection. It should be up most of the time but there is a myriad of things that can kill a TCP connection (this is particularly true on mobile browsers).

Let's checkout the branch for part III:

Here's what you should see in the current directory:

The complete diff can be found here.

On the server-side (server/index.js), we now persist the message in our new store:

And we fetch the list of messages upon connection:

The code is quite straightforward. We shouldn't lose messages upon disconnection anymore:

Now that we have a functional chat, we will see in the 4th part of this guide how to scale to multiple Socket.IO servers.

Thanks for reading!

- Part I: initial implementation
- Part II : persistent user ID
- Part III (current): persistent messages
- Part IV: scaling up
- when the sender gets disconnected, all the packets it sends are buffered until reconnection (which is great in this case)
- but when the recipient gets disconnected, the packets are lost, since there is no listening Socket instance in the given room
- Installation
- How it worksPersistent messages
- Persistent messages
- Review
```js
git checkout examples/private-messaging-part-3
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── index.js (updated)│   ├── messageStore.js (created)│   ├── package.json│   └── sessionStore.js└── src    ├── App.vue    ├── components    │   ├── Chat.vue (updated)    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
io.on("connection", (socket) => {  // ...  socket.on("private message", ({ content, to }) => {    const message = {      content,      from: socket.userID,      to,    };    socket.to(to).to(socket.userID).emit("private message", message);    messageStore.saveMessage(message);  });  // ...});
```

```js
io.on("connection", (socket) => {  // ...  const users = [];  const messagesPerUser = new Map();  messageStore.findMessagesForUser(socket.userID).forEach((message) => {    const { from, to } = message;    const otherUser = socket.userID === from ? to : from;    if (messagesPerUser.has(otherUser)) {      messagesPerUser.get(otherUser).push(message);    } else {      messagesPerUser.set(otherUser, [message]);    }  });  sessionStore.findAllSessions().forEach((session) => {    users.push({      userID: session.userID,      username: session.username,      connected: session.connected,      messages: messagesPerUser.get(session.userID) || [],    });  });  socket.emit("users", users);  // ...});
```

```js
git checkout examples/private-messaging-part-3
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── index.js (updated)│   ├── messageStore.js (created)│   ├── package.json│   └── sessionStore.js└── src    ├── App.vue    ├── components    │   ├── Chat.vue (updated)    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
server/index.js
```

```js
io.on("connection", (socket) => {  // ...  socket.on("private message", ({ content, to }) => {    const message = {      content,      from: socket.userID,      to,    };    socket.to(to).to(socket.userID).emit("private message", message);    messageStore.saveMessage(message);  });  // ...});
```

```js
io.on("connection", (socket) => {  // ...  const users = [];  const messagesPerUser = new Map();  messageStore.findMessagesForUser(socket.userID).forEach((message) => {    const { from, to } = message;    const otherUser = socket.userID === from ? to : from;    if (messagesPerUser.has(otherUser)) {      messagesPerUser.get(otherUser).push(message);    } else {      messagesPerUser.set(otherUser, [message]);    }  });  sessionStore.findAllSessions().forEach((session) => {    users.push({      userID: session.userID,      username: session.username,      connected: session.connected,      messages: messagesPerUser.get(session.userID) || [],    });  });  socket.emit("users", users);  // ...});
```

# https://socket.io/get-started/private-messaging-part-4

# Private messaging - Part IV

## Installation​

## Updating the server​

## How it works​

## Review​

### Creating multiple servers​

### Sessions & messages​

### Forwarding messages​

This guide has four distinct parts:

Here's where we were at the end of the 3rd part:

We will see now how we can scale to multiple Socket.IO servers, for high availability / load-balancing purposes.

Let's checkout the branch for part IV:

Here's what you should see in the current directory:

The complete diff can be found here.

For this last part, we need 3 additional dependencies on the server-side:

We also need a Redis instance. For your convenience, a docker-compose.yml file is provided:

This will create 4 Node.js workers, each running the same index.js file.

On the client-side, no change is needed, we will focus on the server-side here.

When creating multiple Socket.IO servers, there are two things to do:

In our example, the @socket.io/sticky module is used to ensure that requests from a given client are always routed to the same Socket.IO server. This is what is called "sticky-session":

Note: we could also have created several processes listening to different ports (or used multiple hosts), and add a reverse-proxy in front of them. Enabling sticky-session for common reverse-proxy solutions like NginX or HAProxy is covered in the documentation.

The cluster is created in the server/cluster.js file:

In our existing server/index.js file, there is a single change: the HTTP server created by the worker process does not actually listen to a given port, the requests will be handled by the master process and then forwarded to the right worker.

Before:

After:

The setupWorker method provided by the @socket.io/sticky will take care of the synchronization between the master and the worker.

Now that sticky-session is enabled, we need to share sessions and messages across the Socket.IO servers.

We create a new SessionStore based on Redis. We will store each session in a Redis hash, with the HSET command:

We also set an expiry to the key in order to clean up old sessions.

Fetching the session is quite straightforward, with the HMGET command:

Fetching all sessions is a bit more complex:

Similarly, we create a new MessageStore based on Redis. We will store all the messages linked to a given user in a Redis list, with the RPUSH command:

Retrieving the messages is done with the LRANGE command:

There is one last modification that is needed: we need to make sure that messages actually reach the recipient, even if this recipient is not connected on the same Socket.IO server:

This is the duty of the Redis adapter, which relies on the Redis pub/sub mechanism to broadcast messages between the Socket.IO servers and eventually reach all clients.

And that's it! If you have a Redis CLI on your machine, you can check the messages that are sent on the wire:

Documentation:

Note: with the Redis adapter, the allSockets() method which is used in the "disconnect" handler automatically returns the Socket IDs across all Socket.IO servers, so there is nothing to update.

OK, so let's sum it up: we have created a fully functional chat (yes, once again!), robust, ready to scale horizontally, which allowed us to introduce some useful Socket.IO features:

Thanks for reading!

- Part I: initial implementation
- Part II : persistent user ID
- Part III : persistent messages
- Part IV (current): scaling up
- ioredis: a great Redis client
- socket.io-redis: a Socket.IO adapter based on Redis pub/sub mechanism
- @socket.io/sticky: a module for running Socket.IO within a Node.js cluster
- you need to enable sticky-session (please see here for the complete explanation)
- you need to replace the default in-memory adapter with the Redis adapter (or another compatible adapter)
- Redis pub/sub mechanism
- the Redis adapter
- middlewares
- rooms
- scaling to multiple Socket.IO servers
- Installation
- Updating the server
- How it worksCreating multiple serversSessions & messagesForwarding messages
- Creating multiple servers
- Sessions & messages
- Forwarding messages
- Review
```js
git checkout examples/private-messaging-part-4
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── cluster.js (created)│   ├── docker-compose.yml (created)│   ├── index.js (updated)│   ├── messageStore.js (updated)│   ├── package.json (updated)│   └── sessionStore.js (updated)└── src    ├── App.vue    ├── components    │   ├── Chat.vue    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
cd serverdocker-compose up -dnpm installnpm start
```

```js
const cluster = require("cluster");const http = require("http");const { setupMaster } = require("@socket.io/sticky");const WORKERS_COUNT = 4;if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  for (let i = 0; i < WORKERS_COUNT; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });  const httpServer = http.createServer();  setupMaster(httpServer, {    loadBalancingMethod: "least-connection", // either "random", "round-robin" or "least-connection"  });  const PORT = process.env.PORT || 3000;  httpServer.listen(PORT, () =>    console.log(`server listening at http://localhost:${PORT}`)  );} else {  console.log(`Worker ${process.pid} started`);  require("./index");}
```

```js
httpServer.listen(PORT, () =>  console.log(`server listening at http://localhost:${PORT}`));
```

```js
setupWorker(io);
```

```js
class RedisSessionStore extends SessionStore {  // ...  saveSession(id, { userID, username, connected }) {    this.redisClient      .multi()      .hset(`session:${id}`, "userID", userID, "username", username, "connected", connected)      .expire(`session:${id}`, SESSION_TTL)      .exec();  }  // ...}
```

```js
const mapSession = ([userID, username, connected]) =>  userID ? { userID, username, connected: connected === "true" } : undefined;class RedisSessionStore extends SessionStore {  // ...  findSession(id) {    return this.redisClient      .hmget(`session:${id}`, "userID", "username", "connected")      .then(mapSession);  }  // ...}
```

```js
class RedisSessionStore extends SessionStore {  // ...  async findAllSessions() {    // first, we fetch all the keys with the SCAN command    const keys = new Set();    let nextIndex = 0;    do {      const [nextIndexAsStr, results] = await this.redisClient.scan(        nextIndex,        "MATCH",        "session:*",        "COUNT",        "100"      );      nextIndex = parseInt(nextIndexAsStr, 10);      results.forEach((s) => keys.add(s));    } while (nextIndex !== 0);    // and then we retrieve the session details with multiple HMGET commands    const commands = [];    keys.forEach((key) => {      commands.push(["hmget", key, "userID", "username", "connected"]);    });    return this.redisClient      .multi(commands)      .exec()      .then((results) => {        return results          .map(([err, session]) => (err ? undefined : mapSession(session)))          .filter((v) => !!v);      });  }}
```

```js
class RedisMessageStore extends MessageStore {  // ...  saveMessage(message) {    const value = JSON.stringify(message);    this.redisClient      .multi()      .rpush(`messages:${message.from}`, value)      .rpush(`messages:${message.to}`, value)      .expire(`messages:${message.from}`, CONVERSATION_TTL)      .expire(`messages:${message.to}`, CONVERSATION_TTL)      .exec();  }  // ...}
```

```js
class RedisMessageStore extends MessageStore {  // ...  findMessagesForUser(userID) {    return this.redisClient      .lrange(`messages:${userID}`, 0, -1)      .then((results) => {        return results.map((result) => JSON.parse(result));      });  }}
```

```js
const httpServer = require("http").createServer();const Redis = require("ioredis");const redisClient = new Redis();const io = require("socket.io")(httpServer, {  cors: {    origin: "http://localhost:8080",  },  adapter: require("socket.io-redis")({    pubClient: redisClient,    subClient: redisClient.duplicate(),  }),});
```

```js
$ redis-cli127.0.0.1:6379> PSUBSCRIBE socket.io*Reading messages... (press Ctrl-C to quit)1) "psubscribe"2) "socket.io*"3) (integer) 11) "pmessage"2) "socket.io*"3) "socket.io#/#"4) "\x93\xa6XFD3OF\x83..."
```

```js
git checkout examples/private-messaging-part-4
```

```js
├── babel.config.js├── package.json├── public│   ├── favicon.ico│   ├── fonts│   │   └── Lato-Regular.ttf│   └── index.html├── README.md├── server│   ├── cluster.js (created)│   ├── docker-compose.yml (created)│   ├── index.js (updated)│   ├── messageStore.js (updated)│   ├── package.json (updated)│   └── sessionStore.js (updated)└── src    ├── App.vue    ├── components    │   ├── Chat.vue    │   ├── MessagePanel.vue    │   ├── SelectUsername.vue    │   ├── StatusIcon.vue    │   └── User.vue    ├── main.js    └── socket.js
```

```js
ioredis
```

```js
socket.io-redis
```

```js
@socket.io/sticky
```

```js
docker-compose.yml
```

```js
cd serverdocker-compose up -dnpm installnpm start
```

```js
index.js
```

```js
@socket.io/sticky
```

```js
server/cluster.js
```

```js
const cluster = require("cluster");const http = require("http");const { setupMaster } = require("@socket.io/sticky");const WORKERS_COUNT = 4;if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  for (let i = 0; i < WORKERS_COUNT; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });  const httpServer = http.createServer();  setupMaster(httpServer, {    loadBalancingMethod: "least-connection", // either "random", "round-robin" or "least-connection"  });  const PORT = process.env.PORT || 3000;  httpServer.listen(PORT, () =>    console.log(`server listening at http://localhost:${PORT}`)  );} else {  console.log(`Worker ${process.pid} started`);  require("./index");}
```

```js
server/index.js
```

```js
httpServer.listen(PORT, () =>  console.log(`server listening at http://localhost:${PORT}`));
```

```js
setupWorker(io);
```

```js
setupWorker
```

```js
@socket.io/sticky
```

```js
class RedisSessionStore extends SessionStore {  // ...  saveSession(id, { userID, username, connected }) {    this.redisClient      .multi()      .hset(`session:${id}`, "userID", userID, "username", username, "connected", connected)      .expire(`session:${id}`, SESSION_TTL)      .exec();  }  // ...}
```

```js
const mapSession = ([userID, username, connected]) =>  userID ? { userID, username, connected: connected === "true" } : undefined;class RedisSessionStore extends SessionStore {  // ...  findSession(id) {    return this.redisClient      .hmget(`session:${id}`, "userID", "username", "connected")      .then(mapSession);  }  // ...}
```

```js
class RedisSessionStore extends SessionStore {  // ...  async findAllSessions() {    // first, we fetch all the keys with the SCAN command    const keys = new Set();    let nextIndex = 0;    do {      const [nextIndexAsStr, results] = await this.redisClient.scan(        nextIndex,        "MATCH",        "session:*",        "COUNT",        "100"      );      nextIndex = parseInt(nextIndexAsStr, 10);      results.forEach((s) => keys.add(s));    } while (nextIndex !== 0);    // and then we retrieve the session details with multiple HMGET commands    const commands = [];    keys.forEach((key) => {      commands.push(["hmget", key, "userID", "username", "connected"]);    });    return this.redisClient      .multi(commands)      .exec()      .then((results) => {        return results          .map(([err, session]) => (err ? undefined : mapSession(session)))          .filter((v) => !!v);      });  }}
```

```js
class RedisMessageStore extends MessageStore {  // ...  saveMessage(message) {    const value = JSON.stringify(message);    this.redisClient      .multi()      .rpush(`messages:${message.from}`, value)      .rpush(`messages:${message.to}`, value)      .expire(`messages:${message.from}`, CONVERSATION_TTL)      .expire(`messages:${message.to}`, CONVERSATION_TTL)      .exec();  }  // ...}
```

```js
class RedisMessageStore extends MessageStore {  // ...  findMessagesForUser(userID) {    return this.redisClient      .lrange(`messages:${userID}`, 0, -1)      .then((results) => {        return results.map((result) => JSON.parse(result));      });  }}
```

```js
const httpServer = require("http").createServer();const Redis = require("ioredis");const redisClient = new Redis();const io = require("socket.io")(httpServer, {  cors: {    origin: "http://localhost:8080",  },  adapter: require("socket.io-redis")({    pubClient: redisClient,    subClient: redisClient.duplicate(),  }),});
```

```js
$ redis-cli127.0.0.1:6379> PSUBSCRIBE socket.io*Reading messages... (press Ctrl-C to quit)1) "psubscribe"2) "socket.io*"3) (integer) 11) "pmessage"2) "socket.io*"3) "socket.io#/#"4) "\x93\xa6XFD3OF\x83..."
```

```js
allSockets()
```

# https://socket.io/get-started/webtransport

# Socket.IO with WebTransport

## Requirements​

## SSL certificate​

## Basic HTTPS server​

## Socket.IO server​

## WebTransport​

## Conclusion​

Support for WebTransport has been added in version 4.7.0 (June 2023).

In short, WebTransport is an alternative to WebSocket which fixes several performance issues that plague WebSockets like head-of-line blocking.

In this guide, we will create a Socket.IO server that accepts WebTransport connections.

Here we go!

Please use at least Node.js 18 (the current LTS version at the time of writing).

First, let's create a new directory for our project:

WebTransport only works in secure contexts (HTTPS), so we will need an SSL certificate.

You can run the following command to issue a new certificate:

Reference: https://www.openssl.org/docs/man3.1/man1/openssl-req.html

This will generate a private key and a certificate which comply with the requirements listed here:

OK, so you should now have:

Then, let's create a basic Node.js HTTPS server:

Nothing fancy here, we just serve the content of the index.html file at /, and return an HTTP 404 error code otherwise.

Reference: https://nodejs.org/api/https.html

You can start the server by running node index.js:

Now, let's open a new browser window:

The --ignore-certificate-errors-spki-list flag tells Chromium to accept our self-signed certificate without complaining:

Our SSL certificate is indeed deemed valid:

Great! You should now have:

Now, let's install the socket.io package:

We now create a Socket.IO server and attach it to our existing HTTPS server:

Let's update the client accordingly:

A few explanations:

The Socket.IO client bundle is served by the server at /socket.io/socket.io.js.

We could also have used the minified bundle (/socket.io/socket.io.min.js, without debug logs) or a CDN (for example https://cdn.socket.io/4.7.2/socket.io.min.js).

In the Socket.IO jargon, a Transport is a way to establish a connection between a client and a server. Since version 4.7.0, there are now 3 available transports:

By default, the Socket.IO client will always try HTTP long-polling first, since it is the transport which is the most likely to successfully establish a connection. It will then quietly upgrade to more performant transports, like WebSocket or WebTransport.

More about this upgrade mechanism here.

OK, so let's restart our server. You should now see:

So far, so good.

On the client side, WebTransport is currently available in all major browsers but Safari: https://caniuse.com/webtransport

On the server side, until support for WebTransport lands in Node.js (and in Deno), we can use the @fails-components/webtransport package maintained by Marten Richter.

Source: https://github.com/fails-components/webtransport

Let's create an HTTP/3 server and forward the WebTransport sessions to the Socket.IO server:

This should have been sufficient, but there is an error in the browser nonetheless:

If someone has any clue about this, please ping us.

Even if WebTransport fails (which might also happen if something between the client and the server blocks the connection), the connection is successfully established with WebSocket.

A quick workaround is to use 127.0.0.1 instead of localhost:

And voilà!

Like WebSocket more than 10 years ago (!), Socket.IO now allows you to benefit from the performance improvements brought by WebTransport, without worrying about browser compatibility.

Thanks for reading!

- https://w3c.github.io/webtransport/
- https://developer.chrome.com/articles/webtransport/
- the total length of the validity period MUST NOT exceed two weeks
- the exact list of allowed public key algorithms [...] MUST include ECDSA with the secp256r1 (NIST P-256) named group
- client bundle
- transport
- HTTP long-polling
- WebSocket
- WebTransport
- Requirements
- SSL certificate
- Basic HTTPS server
- Socket.IO server
- WebTransport
- Conclusion
```js
mkdir webtransport-sample-project && cd webtransport-sample-project
```

```js
openssl req -new -x509 -nodes \    -out cert.pem \    -keyout key.pem \    -newkey ec \    -pkeyopt ec_paramgen_curve:prime256v1 \    -subj '/CN=127.0.0.1' \    -days 14
```

```js
.├── cert.pem└── key.pem
```

```js
{  "name": "webtransport-sample-project",  "version": "0.0.1",  "description": "Socket.IO with WebTransport",  "private": true,  "type": "module"}
```

```js
import { readFile } from "node:fs/promises";import { createServer } from "node:https";const key = await readFile("./key.pem");const cert = await readFile("./cert.pem");const httpsServer = createServer({  key,  cert}, async (req, res) => {  if (req.method === "GET" && req.url === "/") {    const content = await readFile("./index.html");    res.writeHead(200, {      "content-type": "text/html"    });    res.write(content);    res.end();  } else {    res.writeHead(404).end();  }});const port = process.env.PORT || 3000;httpsServer.listen(port, () => {  console.log(`server listening at https://localhost:${port}`);});
```

```js
<!doctype html><html lang="en">  <head>    <meta charset="UTF-8">    <title>Socket.IO WebTransport example</title>  </head>  <body>    Hello world!  </body></html>
```

```js
$ node index.jsserver listening at https://localhost:3000
```

```js
#!/bin/bashHASH=`openssl x509 -pubkey -noout -in cert.pem |    openssl pkey -pubin -outform der |    openssl dgst -sha256 -binary |    base64`chromium \    --ignore-certificate-errors-spki-list=$HASH \    https://localhost:3000
```

```js
.├── cert.pem├── index.html├── index.js├── key.pem├── open_browser.sh└── package.json
```

```js
npm i socket.io
```

```js
import { readFile } from "node:fs/promises";import { createServer } from "node:https";import { Server } from "socket.io";const key = await readFile("./key.pem");const cert = await readFile("./cert.pem");const httpsServer = createServer({  key,  cert}, async (req, res) => {  if (req.method === "GET" && req.url === "/") {    const content = await readFile("./index.html");    res.writeHead(200, {      "content-type": "text/html"    });    res.write(content);    res.end();  } else {    res.writeHead(404).end();  }});const port = process.env.PORT || 3000;httpsServer.listen(port, () => {  console.log(`server listening at https://localhost:${port}`);});const io = new Server(httpsServer);io.on("connection", (socket) => {  console.log(`connected with transport ${socket.conn.transport.name}`);  socket.conn.on("upgrade", (transport) => {    console.log(`transport upgraded to ${transport.name}`);  });  socket.on("disconnect", (reason) => {    console.log(`disconnected due to ${reason}`);  });});
```

```js
<!doctype html><html lang="en">  <head>    <meta charset="UTF-8">    <title>Socket.IO WebTransport example</title>  </head>  <body>    <p>Status: <span id="status">Disconnected</span></p>    <p>Transport: <span id="transport">N/A</span></p>    <script src="/socket.io/socket.io.js"></script>    <script>      const $status = document.getElementById("status");      const $transport = document.getElementById("transport");      const socket = io();      socket.on("connect", () => {        console.log(`connected with transport ${socket.io.engine.transport.name}`);        $status.innerText = "Connected";        $transport.innerText = socket.io.engine.transport.name;        socket.io.engine.on("upgrade", (transport) => {          console.log(`transport upgraded to ${transport.name}`);          $transport.innerText = transport.name;        });      });      socket.on("connect_error", (err) => {        console.log(`connect_error due to ${err.message}`);      });      socket.on("disconnect", (reason) => {        console.log(`disconnect due to ${reason}`);        $status.innerText = "Disconnected";        $transport.innerText = "N/A";      });    </script>  </body></html>
```

```js
<script src="/socket.io/socket.io.js"></script>
```

```js
socket.on("connect", () => {  console.log(`connected with transport ${socket.io.engine.transport.name}`);  // ...});
```

```js
npm i @fails-components/webtransport @fails-components/webtransport-transport-http3-quiche
```

```js
import { readFile } from "node:fs/promises";import { createServer } from "node:https";import { Server } from "socket.io";import { Http3Server } from "@fails-components/webtransport";const key = await readFile("./key.pem");const cert = await readFile("./cert.pem");const httpsServer = createServer({  key,  cert}, async (req, res) => {  if (req.method === "GET" && req.url === "/") {    const content = await readFile("./index.html");    res.writeHead(200, {      "content-type": "text/html"    });    res.write(content);    res.end();  } else {    res.writeHead(404).end();  }});const port = process.env.PORT || 3000;httpsServer.listen(port, () => {  console.log(`server listening at https://localhost:${port}`);});const io = new Server(httpsServer, {  transports: ["polling", "websocket", "webtransport"]});io.on("connection", (socket) => {  console.log(`connected with transport ${socket.conn.transport.name}`);  socket.conn.on("upgrade", (transport) => {    console.log(`transport upgraded to ${transport.name}`);  });  socket.on("disconnect", (reason) => {    console.log(`disconnected due to ${reason}`);  });});const h3Server = new Http3Server({  port,  host: "0.0.0.0",  secret: "changeit",  cert,  privKey: key,});h3Server.startServer();(async () => {  const stream = await h3Server.sessionStream("/socket.io/");  const sessionReader = stream.getReader();  while (true) {    const { done, value } = await sessionReader.read();    if (done) {      break;    }    io.engine.onWebTransportSession(value);  }})();
```

```js
<!doctype html><html lang="en">  <head>    <meta charset="UTF-8">    <title>Socket.IO WebTransport example</title>  </head>  <body>    <p>Status: <span id="status">Disconnected</span></p>    <p>Transport: <span id="transport">N/A</span></p>    <script src="/socket.io/socket.io.js"></script>    <script>      const $status = document.getElementById("status");      const $transport = document.getElementById("transport");      const socket = io({        transportOptions: {          webtransport: {            hostname: "127.0.0.1"          }        }      });      socket.on("connect", () => {        console.log(`connected with transport ${socket.io.engine.transport.name}`);        $status.innerText = "Connected";        $transport.innerText = socket.io.engine.transport.name;        socket.io.engine.on("upgrade", (transport) => {          console.log(`transport upgraded to ${transport.name}`);          $transport.innerText = transport.name;        });      });      socket.on("connect_error", (err) => {        console.log(`connect_error due to ${err.message}`);      });      socket.on("disconnect", (reason) => {        console.log(`disconnect due to ${reason}`);        $status.innerText = "Disconnected";        $transport.innerText = "N/A";      });    </script>  </body></html>
```

```js
#!/bin/bashHASH=`openssl x509 -pubkey -noout -in cert.pem |    openssl pkey -pubin -outform der |    openssl dgst -sha256 -binary |    base64`chromium \    --ignore-certificate-errors-spki-list=$HASH \    --origin-to-force-quic-on=127.0.0.1:3000 \    https://localhost:3000
```

```js
mkdir webtransport-sample-project && cd webtransport-sample-project
```

```js
openssl req -new -x509 -nodes \    -out cert.pem \    -keyout key.pem \    -newkey ec \    -pkeyopt ec_paramgen_curve:prime256v1 \    -subj '/CN=127.0.0.1' \    -days 14
```

```js
.├── cert.pem└── key.pem
```

```js
{  "name": "webtransport-sample-project",  "version": "0.0.1",  "description": "Socket.IO with WebTransport",  "private": true,  "type": "module"}
```

```js
import { readFile } from "node:fs/promises";import { createServer } from "node:https";const key = await readFile("./key.pem");const cert = await readFile("./cert.pem");const httpsServer = createServer({  key,  cert}, async (req, res) => {  if (req.method === "GET" && req.url === "/") {    const content = await readFile("./index.html");    res.writeHead(200, {      "content-type": "text/html"    });    res.write(content);    res.end();  } else {    res.writeHead(404).end();  }});const port = process.env.PORT || 3000;httpsServer.listen(port, () => {  console.log(`server listening at https://localhost:${port}`);});
```

```js
<!doctype html><html lang="en">  <head>    <meta charset="UTF-8">    <title>Socket.IO WebTransport example</title>  </head>  <body>    Hello world!  </body></html>
```

```js
index.html
```

```js
node index.js
```

```js
$ node index.jsserver listening at https://localhost:3000
```

```js
#!/bin/bashHASH=`openssl x509 -pubkey -noout -in cert.pem |    openssl pkey -pubin -outform der |    openssl dgst -sha256 -binary |    base64`chromium \    --ignore-certificate-errors-spki-list=$HASH \    https://localhost:3000
```

```js
--ignore-certificate-errors-spki-list
```

```js
.├── cert.pem├── index.html├── index.js├── key.pem├── open_browser.sh└── package.json
```

```js
socket.io
```

```js
npm i socket.io
```

```js
import { readFile } from "node:fs/promises";import { createServer } from "node:https";import { Server } from "socket.io";const key = await readFile("./key.pem");const cert = await readFile("./cert.pem");const httpsServer = createServer({  key,  cert}, async (req, res) => {  if (req.method === "GET" && req.url === "/") {    const content = await readFile("./index.html");    res.writeHead(200, {      "content-type": "text/html"    });    res.write(content);    res.end();  } else {    res.writeHead(404).end();  }});const port = process.env.PORT || 3000;httpsServer.listen(port, () => {  console.log(`server listening at https://localhost:${port}`);});const io = new Server(httpsServer);io.on("connection", (socket) => {  console.log(`connected with transport ${socket.conn.transport.name}`);  socket.conn.on("upgrade", (transport) => {    console.log(`transport upgraded to ${transport.name}`);  });  socket.on("disconnect", (reason) => {    console.log(`disconnected due to ${reason}`);  });});
```

```js
<!doctype html><html lang="en">  <head>    <meta charset="UTF-8">    <title>Socket.IO WebTransport example</title>  </head>  <body>    <p>Status: <span id="status">Disconnected</span></p>    <p>Transport: <span id="transport">N/A</span></p>    <script src="/socket.io/socket.io.js"></script>    <script>      const $status = document.getElementById("status");      const $transport = document.getElementById("transport");      const socket = io();      socket.on("connect", () => {        console.log(`connected with transport ${socket.io.engine.transport.name}`);        $status.innerText = "Connected";        $transport.innerText = socket.io.engine.transport.name;        socket.io.engine.on("upgrade", (transport) => {          console.log(`transport upgraded to ${transport.name}`);          $transport.innerText = transport.name;        });      });      socket.on("connect_error", (err) => {        console.log(`connect_error due to ${err.message}`);      });      socket.on("disconnect", (reason) => {        console.log(`disconnect due to ${reason}`);        $status.innerText = "Disconnected";        $transport.innerText = "N/A";      });    </script>  </body></html>
```

```js
<script src="/socket.io/socket.io.js"></script>
```

```js
/socket.io/socket.io.js
```

```js
/socket.io/socket.io.min.js
```

```js
socket.on("connect", () => {  console.log(`connected with transport ${socket.io.engine.transport.name}`);  // ...});
```

```js
@fails-components/webtransport
```

```js
npm i @fails-components/webtransport @fails-components/webtransport-transport-http3-quiche
```

```js
import { readFile } from "node:fs/promises";import { createServer } from "node:https";import { Server } from "socket.io";import { Http3Server } from "@fails-components/webtransport";const key = await readFile("./key.pem");const cert = await readFile("./cert.pem");const httpsServer = createServer({  key,  cert}, async (req, res) => {  if (req.method === "GET" && req.url === "/") {    const content = await readFile("./index.html");    res.writeHead(200, {      "content-type": "text/html"    });    res.write(content);    res.end();  } else {    res.writeHead(404).end();  }});const port = process.env.PORT || 3000;httpsServer.listen(port, () => {  console.log(`server listening at https://localhost:${port}`);});const io = new Server(httpsServer, {  transports: ["polling", "websocket", "webtransport"]});io.on("connection", (socket) => {  console.log(`connected with transport ${socket.conn.transport.name}`);  socket.conn.on("upgrade", (transport) => {    console.log(`transport upgraded to ${transport.name}`);  });  socket.on("disconnect", (reason) => {    console.log(`disconnected due to ${reason}`);  });});const h3Server = new Http3Server({  port,  host: "0.0.0.0",  secret: "changeit",  cert,  privKey: key,});h3Server.startServer();(async () => {  const stream = await h3Server.sessionStream("/socket.io/");  const sessionReader = stream.getReader();  while (true) {    const { done, value } = await sessionReader.read();    if (done) {      break;    }    io.engine.onWebTransportSession(value);  }})();
```

```js
127.0.0.1
```

```js
localhost
```

```js
<!doctype html><html lang="en">  <head>    <meta charset="UTF-8">    <title>Socket.IO WebTransport example</title>  </head>  <body>    <p>Status: <span id="status">Disconnected</span></p>    <p>Transport: <span id="transport">N/A</span></p>    <script src="/socket.io/socket.io.js"></script>    <script>      const $status = document.getElementById("status");      const $transport = document.getElementById("transport");      const socket = io({        transportOptions: {          webtransport: {            hostname: "127.0.0.1"          }        }      });      socket.on("connect", () => {        console.log(`connected with transport ${socket.io.engine.transport.name}`);        $status.innerText = "Connected";        $transport.innerText = socket.io.engine.transport.name;        socket.io.engine.on("upgrade", (transport) => {          console.log(`transport upgraded to ${transport.name}`);          $transport.innerText = transport.name;        });      });      socket.on("connect_error", (err) => {        console.log(`connect_error due to ${err.message}`);      });      socket.on("disconnect", (reason) => {        console.log(`disconnect due to ${reason}`);        $status.innerText = "Disconnected";        $transport.innerText = "N/A";      });    </script>  </body></html>
```

```js
#!/bin/bashHASH=`openssl x509 -pubkey -noout -in cert.pem |    openssl pkey -pubin -outform der |    openssl dgst -sha256 -binary |    base64`chromium \    --ignore-certificate-errors-spki-list=$HASH \    --origin-to-force-quic-on=127.0.0.1:3000 \    https://localhost:3000
```

# https://socket.io/how-to/build-a-basic-client

# How to build a basic Socket.IO client

## Event emitter​

## WebSocket connection​

## The Engine.IO protocol​

## The Socket.IO protocol​

## Ending notes​

### Heartbeat​

### Reconnection​

### Connecting​

### Sending an event​

### Receiving an event​

### Disconnecting manually​

In this guide, we will implement a basic Socket.IO client in JavaScript, in order to get a better understanding of the Socket.IO protocol.

We will implement the following features:

The official client obviously contains a lot more features:

But that should be sufficient to give you a good overview of how the library works under the hood.

Our goal is to achieve something like this:

Ready? Let's do this!

The underlying connection between the server and the client (WebSocket or HTTP long-polling) is abstracted away and managed by the library.

Let's create a minimalistic EventEmitter class:

Our Socket class will then extend this class, in order to expose both the on() and the emit() methods:

In our constructor, the uri argument is either:

Let's create an entrypoint:

OK, so that's a good start!

Now, let's create the WebSocket connection to the server:

Some explanations about the createUrl() method:

So the final URL will look like: wss://example.com/socket.io/?EIO=4&transport=websocket

The Socket.IO codebase is split into two distinct layers:

See also:

When using WebSocket, the format of the messages sent over the wire is simply: <packet type><payload>

Here are the different packet types in the 4th version (hence the EIO=4 above) of the protocol:

Example:

Let's handle the WebSocket messages:

A heartbeat mechanism is implemented to ensure that the connection between the server and the client is healthy.

The server sends two values during the initial handshake: pingInterval and pingTimeout

It will then send a PING packet every pingInterval ms, and expect a PONG packet back from the client. Let's do this:

While we're at it, we will also handle reconnections. WebSockets are awesome, but they can (and they will, in real-life conditions) get disconnected, so we must take care of that:

The official Socket.IO client uses a fancy exponential delay with some randomness in order to prevent spikes of load when a lot of clients reconnect at the same time, but we'll keep it simple here and use a constant value.

OK, so let's sum up, we now have a client that can:

That's it for the Engine.IO protocol! Let's dig into the Socket.IO protocol now.

The Socket.IO protocol is built on top of the Engine.IO protocol described earlier, which means that every Socket.IO packet will be prefixed by "4" (the Engine.IO MESSAGE packet type) when sent over the wire.

Reference: the Socket.IO protocol

Without binary elements, the format is the following:

Here is the list of available packet types:

Example:

The client must send a CONNECT packet at the beginning of the Socket.IO session:

If the connection is allowed, then the server will send a CONNECT packet back:

We are using super.emit(...) so that we will be able to override the emit() method later to send an event.

Let's send some data to the server. We need to track the state of the underlying connection and buffer the packets until the connection is ready:

Conversely, let's handle the EVENT packets sent by the server:

And finally, let's handle the few cases where the socket shouldn't try to reconnect:

That's it for our basic Socket.IO client! So let's recap.

We have implemented the following features:

Hopefully, you now have a better understanding of how the library works under the hood.

The complete source code can be found there.

Thanks for reading!

- creating a WebSocket connection
- managing reconnections
- sending events
- receiving events
- disconnecting manually
- support for old browsers, down to IE9
- fallback to HTTP long-polling
- acknowledgements
- binary payloads
- multiplexing
- catch-all listeners
- connection state recovery
- ...
- server
- client
- provided by the user:
- or inferred from the window.location object
- a WebSocket URL starts with ws:// or wss://, so we handle this in the replace() call
- a Socket.IO URL always contains a specific request path, which defaults to /socket.io/
- there are two mandatory query parameters:EIO=4: the version of the Engine.IO protocoltransport=websocket: the transport used
- EIO=4: the version of the Engine.IO protocol
- transport=websocket: the transport used
- the low-level plumbing: what we call Engine.IO, the engine inside Socket.IO
- How it works
- The Engine.IO protocol
- open a WebSocket connection to the server
- honor the heartbeat mechanism by responding to PING packets
- automatically reconnect upon failure
- when the client calls socket.disconnect()
- when the server calls socket.disconnect()
- creating a WebSocket connection
- managing reconnections
- sending events
- receiving events
- disconnecting manually
- Event emitter
- WebSocket connection
- The Engine.IO protocolHeartbeatReconnection
- Heartbeat
- Reconnection
- The Socket.IO protocolConnectingSending an eventReceiving an eventDisconnecting manually
- Connecting
- Sending an event
- Receiving an event
- Disconnecting manually
- Ending notes
```js
import { io } from "./basic-client.js";const socket = io();// connectionsocket.on("connect", () => {  // ...});// receiving an eventsocket.on("foo", (value) => {  // ...});// sending an eventsocket.emit("bar", "abc");
```

```js
import { EventEmitter } from "node:events";const myEmitter = new EventEmitter();myEmitter.on("foo", () => {  console.log("foo!");});myEmitter.emit("foo");
```

```js
io.on("connection", (socket) => {  // send a "foo" event to the client  socket.emit("foo");  // receive a "bar" event from the client  socket.on("bar", () => {    // ...  });});
```

```js
import { io } from "socket.io-client";const socket = io();// receive a "foo" event from the serversocket.on("foo", () => {  // ...});// send a "bar" event to the serversocket.emit("bar");
```

```js
class EventEmitter {  #listeners = new Map();  on(event, listener) {    let listeners = this.#listeners.get(event);    if (!listeners) {      this.#listeners.set(event, listeners = []);    }    listeners.push(listener);  }  emit(event, ...args) {    const listeners = this.#listeners.get(event);    if (listeners) {      for (const listener of listeners) {        listener.apply(null, args);      }    }  }}
```

```js
class Socket extends EventEmitter {  constructor(uri, opts) {    super();  }}
```

```js
const socket = io("https://example.com");
```

```js
const socket = io();
```

```js
export function io(uri, opts) {  if (typeof uri !== "string") {    opts = uri;    uri = location.origin;  }  return new Socket(uri, opts);}
```

```js
class Socket extends EventEmitter {+ #uri;+ #opts;+ #ws;  constructor(uri, opts) {    super();+   this.#uri = uri;+   this.#opts = Object.assign({+     path: "/socket.io/"+   }, opts);+   this.#open();  }+ #open() {+   this.#ws = new WebSocket(this.#createUrl());+ }++ #createUrl() {+   const uri = this.#uri.replace(/^http/, "ws");+   const queryParams = "?EIO=4&transport=websocket";+   return `${uri}${this.#opts.path}${queryParams}`;+ }}
```

```js
4hellowith:4      => MESSAGE packet typehello  => message payload (UTF-8 encoded)
```

```js
+const EIOPacketType = {+  OPEN: "0",+  CLOSE: "1",+  PING: "2",+  PONG: "3",+  MESSAGE: "4",+};+function noop() {}class Socket extends EventEmitter {  [...]  #open() {    this.#ws = new WebSocket(this.#createUrl());+   this.#ws.onmessage = ({ data }) => this.#onMessage(data);+   this.#ws.onclose = () => this.#onClose("transport close");  }+ #onMessage(data) {+   if (typeof data !== "string") {+     // TODO handle binary payloads+     return;+   }++   switch (data[0]) {+     case EIOPacketType.CLOSE:+       this.#onClose("transport close");+       break;++     default:+       this.#onClose("parse error");+       break;+   }+ }++ #onClose(reason) {+   if (this.#ws) {+     this.#ws.onclose = noop;+     this.#ws.close();+   }+ }+}
```

```js
class Socket extends EventEmitter {+ #pingTimeoutTimer;+ #pingTimeoutDelay;  [...]  #onMessage(data) {    if (typeof data !== "string") {      // TODO handle binary payloads      return;    }    switch (data[0]) {+     case EIOPacketType.OPEN:+       this.#onOpen(data);+       break;+      case EIOPacketType.CLOSE:        this.#onClose("transport close");        break;+     case EIOPacketType.PING:+       this.#resetPingTimeout();+       this.#send(EIOPacketType.PONG);+       break;      default:        this.#onClose("parse error");        break;    }  }+ #onOpen(data) {+   let handshake;+   try {+     handshake = JSON.parse(data.substring(1));+   } catch (e) {+     return this.#onClose("parse error");+   }+   this.#pingTimeoutDelay = handshake.pingInterval + handshake.pingTimeout;+   this.#resetPingTimeout();+ }++ #resetPingTimeout() {+   clearTimeout(this.#pingTimeoutTimer);+   this.#pingTimeoutTimer = setTimeout(() => {+     this.#onClose("ping timeout");+   }, this.#pingTimeoutDelay);+ }++ #send(data) {+   if (this.#ws.readyState === WebSocket.OPEN) {+     this.#ws.send(data);+   }+ }  #onClose(reason) {    if (this.#ws) {      this.#ws.onclose = noop;      this.#ws.close();    }+   clearTimeout(this.#pingTimeoutTimer);  }}
```

```js
class Socket extends EventEmitter {  [...]  constructor(uri, opts) {    super();    this.#uri = uri;    this.#opts = Object.assign(      {        path: "/socket.io/",+       reconnectionDelay: 2000,      },      opts    );    this.#open();  }  #onClose(reason) {    if (this.#ws) {      this.#ws.onclose = noop;      this.#ws.close();    }    clearTimeout(this.#pingTimeoutTimer);+   setTimeout(() => this.#open(), this.#opts.reconnectionDelay);  }}
```

```js
<packet type>[JSON-stringified payload]
```

```js
2["hello","world"]with:2                   => EVENT packet type["hello","world"]   => JSON.stringified() payload
```

```js
+const SIOPacketType = {+  CONNECT: 0,+  DISCONNECT: 1,+  EVENT: 2,+};class Socket extends EventEmitter {  [...]  #onOpen(data) {    let handshake;    try {      handshake = JSON.parse(data.substring(1));    } catch (e) {      return this.#onClose("parse error");    }    this.#pingTimeoutDelay = handshake.pingInterval + handshake.pingTimeout;    this.#resetPingTimeout();+   this.#doConnect();  }+ #doConnect() {+   this.#sendPacket({ type: SIOPacketType.CONNECT });+ }++ #sendPacket(packet) {+   this.#send(EIOPacketType.MESSAGE + encode(packet));+ }}+function encode(packet) {+  let output = "" + packet.type;++  return output;+}
```

```js
class Socket extends EventEmitter {+ id;  [...]  #onMessage(data) {    switch (data[0]) {      [...]+     case EIOPacketType.MESSAGE:+       let packet;+       try {+         packet = decode(data);+       } catch (e) {+         return this.#onClose("parse error");+       }+       this.#onPacket(packet);+       break;    }  }+ #onPacket(packet) {+   switch (packet.type) {+     case SIOPacketType.CONNECT:+       this.#onConnect(packet);+       break;+   }+ }+ #onConnect(packet) {+   this.id = packet.data.sid;++   super.emit("connect");+ }}+function decode(data) {+  let i = 1; // skip "4" prefix++  const packet = {+    type: parseInt(data.charAt(i++), 10),+  };++  if (!isPacketValid(packet)) {+    throw new Error("invalid format");+  }++  return packet;+}++function isPacketValid(packet) {+  switch (packet.type) {+    case SIOPacketType.CONNECT:+      return typeof packet.data === "object";+    default:+      return false;+  }+}
```

```js
class Socket extends EventEmitter {+ connected = false;+ #sendBuffer = [];  [...]+ emit(...args) {+   const packet = {+     type: SIOPacketType.EVENT,+     data: args,+   };++   if (this.connected) {+     this.#sendPacket(packet);+   } else {+     this.#sendBuffer.push(packet);+   }+ }  #onConnect(packet) {    this.id = packet.data.sid;+   this.connected = true;+   this.#sendBuffer.forEach((packet) => this.#sendPacket(packet));+   this.#sendBuffer.slice(0);    super.emit("connect");  }}function encode(packet) {  let output = "" + packet.type;+ if (packet.data) {+   output += JSON.stringify(packet.data);+ }  return output;}
```

```js
class Socket extends EventEmitter {  [...]  #onPacket(packet) {    switch (packet.type) {      case SIOPacketType.CONNECT:        this.#onConnect(packet);        break;+     case SIOPacketType.EVENT:+       super.emit.apply(this, packet.data);+       break;    }  }}function decode(data) {  let i = 1; // skip "4" prefix  const packet = {    type: parseInt(data.charAt(i++), 10),  };+ if (data.charAt(i)) {+   packet.data = JSON.parse(data.substring(i));+ }  if (!isPacketValid(packet)) {    throw new Error("invalid format");  }  return packet;}function isPacketValid(packet) {  switch (packet.type) {    case SIOPacketType.CONNECT:      return typeof packet.data === "object";+   case SIOPacketType.EVENT: {+     const args = packet.data;+     return (+       Array.isArray(args) && args.length > 0 && typeof args[0] === "string"+     );+   }    default:      return false;  }}
```

```js
class Socket extends EventEmitter {+ #reconnectTimer;+ #shouldReconnect = true;  [...]  #onPacket(packet) {    switch (packet.type) {      case SIOPacketType.CONNECT:        this.#onConnect(packet);        break;+     case SIOPacketType.DISCONNECT:+       this.#shouldReconnect = false;+       this.#onClose("io server disconnect");+       break;      case SIOPacketType.EVENT:        super.emit.apply(this, packet.data);        break;    }  }  #onClose(reason) {    if (this.#ws) {      this.#ws.onclose = noop;      this.#ws.close();    }    clearTimeout(this.#pingTimeoutTimer);+   clearTimeout(this.#reconnectTimer);++   if (this.#shouldReconnect) {+     this.#reconnectTimer = setTimeout(+       () => this.#open(),+       this.#opts.reconnectionDelay+     );+   }-   setTimeout(() => this.#open(), this.#opts.reconnectionDelay);  }+ disconnect() {+   this.#shouldReconnect = false;+   this.#onClose("io client disconnect");+ }}function isPacketValid(packet) {  switch (packet.type) {    case SIOPacketType.CONNECT:      return typeof packet.data === "object";+   case SIOPacketType.DISCONNECT:+     return packet.data === undefined;    case SIOPacketType.EVENT: {      const args = packet.data;      return (        Array.isArray(args) && args.length > 0 && typeof args[0] === "string"      );    }    default:      return false;  }}
```

```js
import { io } from "./basic-client.js";const socket = io();// connectionsocket.on("connect", () => {  // ...});// receiving an eventsocket.on("foo", (value) => {  // ...});// sending an eventsocket.emit("bar", "abc");
```

```js
import { EventEmitter } from "node:events";const myEmitter = new EventEmitter();myEmitter.on("foo", () => {  console.log("foo!");});myEmitter.emit("foo");
```

```js
io.on("connection", (socket) => {  // send a "foo" event to the client  socket.emit("foo");  // receive a "bar" event from the client  socket.on("bar", () => {    // ...  });});
```

```js
import { io } from "socket.io-client";const socket = io();// receive a "foo" event from the serversocket.on("foo", () => {  // ...});// send a "bar" event to the serversocket.emit("bar");
```

```js
EventEmitter
```

```js
class EventEmitter {  #listeners = new Map();  on(event, listener) {    let listeners = this.#listeners.get(event);    if (!listeners) {      this.#listeners.set(event, listeners = []);    }    listeners.push(listener);  }  emit(event, ...args) {    const listeners = this.#listeners.get(event);    if (listeners) {      for (const listener of listeners) {        listener.apply(null, args);      }    }  }}
```

```js
Socket
```

```js
on()
```

```js
emit()
```

```js
class Socket extends EventEmitter {  constructor(uri, opts) {    super();  }}
```

```js
uri
```

```js
const socket = io("https://example.com");
```

```js
window.location
```

```js
const socket = io();
```

```js
export function io(uri, opts) {  if (typeof uri !== "string") {    opts = uri;    uri = location.origin;  }  return new Socket(uri, opts);}
```

```js
class Socket extends EventEmitter {+ #uri;+ #opts;+ #ws;  constructor(uri, opts) {    super();+   this.#uri = uri;+   this.#opts = Object.assign({+     path: "/socket.io/"+   }, opts);+   this.#open();  }+ #open() {+   this.#ws = new WebSocket(this.#createUrl());+ }++ #createUrl() {+   const uri = this.#uri.replace(/^http/, "ws");+   const queryParams = "?EIO=4&transport=websocket";+   return `${uri}${this.#opts.path}${queryParams}`;+ }}
```

```js
createUrl()
```

```js
ws://
```

```js
wss://
```

```js
replace()
```

```js
/socket.io/
```

```js
EIO=4
```

```js
transport=websocket
```

```js
wss://example.com/socket.io/?EIO=4&transport=websocket
```

```js
<packet type><payload>
```

```js
EIO=4
```

```js
4hellowith:4      => MESSAGE packet typehello  => message payload (UTF-8 encoded)
```

```js
+const EIOPacketType = {+  OPEN: "0",+  CLOSE: "1",+  PING: "2",+  PONG: "3",+  MESSAGE: "4",+};+function noop() {}class Socket extends EventEmitter {  [...]  #open() {    this.#ws = new WebSocket(this.#createUrl());+   this.#ws.onmessage = ({ data }) => this.#onMessage(data);+   this.#ws.onclose = () => this.#onClose("transport close");  }+ #onMessage(data) {+   if (typeof data !== "string") {+     // TODO handle binary payloads+     return;+   }++   switch (data[0]) {+     case EIOPacketType.CLOSE:+       this.#onClose("transport close");+       break;++     default:+       this.#onClose("parse error");+       break;+   }+ }++ #onClose(reason) {+   if (this.#ws) {+     this.#ws.onclose = noop;+     this.#ws.close();+   }+ }+}
```

```js
pingInterval
```

```js
pingTimeout
```

```js
pingInterval
```

```js
class Socket extends EventEmitter {+ #pingTimeoutTimer;+ #pingTimeoutDelay;  [...]  #onMessage(data) {    if (typeof data !== "string") {      // TODO handle binary payloads      return;    }    switch (data[0]) {+     case EIOPacketType.OPEN:+       this.#onOpen(data);+       break;+      case EIOPacketType.CLOSE:        this.#onClose("transport close");        break;+     case EIOPacketType.PING:+       this.#resetPingTimeout();+       this.#send(EIOPacketType.PONG);+       break;      default:        this.#onClose("parse error");        break;    }  }+ #onOpen(data) {+   let handshake;+   try {+     handshake = JSON.parse(data.substring(1));+   } catch (e) {+     return this.#onClose("parse error");+   }+   this.#pingTimeoutDelay = handshake.pingInterval + handshake.pingTimeout;+   this.#resetPingTimeout();+ }++ #resetPingTimeout() {+   clearTimeout(this.#pingTimeoutTimer);+   this.#pingTimeoutTimer = setTimeout(() => {+     this.#onClose("ping timeout");+   }, this.#pingTimeoutDelay);+ }++ #send(data) {+   if (this.#ws.readyState === WebSocket.OPEN) {+     this.#ws.send(data);+   }+ }  #onClose(reason) {    if (this.#ws) {      this.#ws.onclose = noop;      this.#ws.close();    }+   clearTimeout(this.#pingTimeoutTimer);  }}
```

```js
class Socket extends EventEmitter {  [...]  constructor(uri, opts) {    super();    this.#uri = uri;    this.#opts = Object.assign(      {        path: "/socket.io/",+       reconnectionDelay: 2000,      },      opts    );    this.#open();  }  #onClose(reason) {    if (this.#ws) {      this.#ws.onclose = noop;      this.#ws.close();    }    clearTimeout(this.#pingTimeoutTimer);+   setTimeout(() => this.#open(), this.#opts.reconnectionDelay);  }}
```

```js
<packet type>[JSON-stringified payload]
```

```js
2["hello","world"]with:2                   => EVENT packet type["hello","world"]   => JSON.stringified() payload
```

```js
+const SIOPacketType = {+  CONNECT: 0,+  DISCONNECT: 1,+  EVENT: 2,+};class Socket extends EventEmitter {  [...]  #onOpen(data) {    let handshake;    try {      handshake = JSON.parse(data.substring(1));    } catch (e) {      return this.#onClose("parse error");    }    this.#pingTimeoutDelay = handshake.pingInterval + handshake.pingTimeout;    this.#resetPingTimeout();+   this.#doConnect();  }+ #doConnect() {+   this.#sendPacket({ type: SIOPacketType.CONNECT });+ }++ #sendPacket(packet) {+   this.#send(EIOPacketType.MESSAGE + encode(packet));+ }}+function encode(packet) {+  let output = "" + packet.type;++  return output;+}
```

```js
class Socket extends EventEmitter {+ id;  [...]  #onMessage(data) {    switch (data[0]) {      [...]+     case EIOPacketType.MESSAGE:+       let packet;+       try {+         packet = decode(data);+       } catch (e) {+         return this.#onClose("parse error");+       }+       this.#onPacket(packet);+       break;    }  }+ #onPacket(packet) {+   switch (packet.type) {+     case SIOPacketType.CONNECT:+       this.#onConnect(packet);+       break;+   }+ }+ #onConnect(packet) {+   this.id = packet.data.sid;++   super.emit("connect");+ }}+function decode(data) {+  let i = 1; // skip "4" prefix++  const packet = {+    type: parseInt(data.charAt(i++), 10),+  };++  if (!isPacketValid(packet)) {+    throw new Error("invalid format");+  }++  return packet;+}++function isPacketValid(packet) {+  switch (packet.type) {+    case SIOPacketType.CONNECT:+      return typeof packet.data === "object";+    default:+      return false;+  }+}
```

```js
super.emit(...)
```

```js
emit()
```

```js
class Socket extends EventEmitter {+ connected = false;+ #sendBuffer = [];  [...]+ emit(...args) {+   const packet = {+     type: SIOPacketType.EVENT,+     data: args,+   };++   if (this.connected) {+     this.#sendPacket(packet);+   } else {+     this.#sendBuffer.push(packet);+   }+ }  #onConnect(packet) {    this.id = packet.data.sid;+   this.connected = true;+   this.#sendBuffer.forEach((packet) => this.#sendPacket(packet));+   this.#sendBuffer.slice(0);    super.emit("connect");  }}function encode(packet) {  let output = "" + packet.type;+ if (packet.data) {+   output += JSON.stringify(packet.data);+ }  return output;}
```

```js
class Socket extends EventEmitter {  [...]  #onPacket(packet) {    switch (packet.type) {      case SIOPacketType.CONNECT:        this.#onConnect(packet);        break;+     case SIOPacketType.EVENT:+       super.emit.apply(this, packet.data);+       break;    }  }}function decode(data) {  let i = 1; // skip "4" prefix  const packet = {    type: parseInt(data.charAt(i++), 10),  };+ if (data.charAt(i)) {+   packet.data = JSON.parse(data.substring(i));+ }  if (!isPacketValid(packet)) {    throw new Error("invalid format");  }  return packet;}function isPacketValid(packet) {  switch (packet.type) {    case SIOPacketType.CONNECT:      return typeof packet.data === "object";+   case SIOPacketType.EVENT: {+     const args = packet.data;+     return (+       Array.isArray(args) && args.length > 0 && typeof args[0] === "string"+     );+   }    default:      return false;  }}
```

```js
socket.disconnect()
```

```js
socket.disconnect()
```

```js
class Socket extends EventEmitter {+ #reconnectTimer;+ #shouldReconnect = true;  [...]  #onPacket(packet) {    switch (packet.type) {      case SIOPacketType.CONNECT:        this.#onConnect(packet);        break;+     case SIOPacketType.DISCONNECT:+       this.#shouldReconnect = false;+       this.#onClose("io server disconnect");+       break;      case SIOPacketType.EVENT:        super.emit.apply(this, packet.data);        break;    }  }  #onClose(reason) {    if (this.#ws) {      this.#ws.onclose = noop;      this.#ws.close();    }    clearTimeout(this.#pingTimeoutTimer);+   clearTimeout(this.#reconnectTimer);++   if (this.#shouldReconnect) {+     this.#reconnectTimer = setTimeout(+       () => this.#open(),+       this.#opts.reconnectionDelay+     );+   }-   setTimeout(() => this.#open(), this.#opts.reconnectionDelay);  }+ disconnect() {+   this.#shouldReconnect = false;+   this.#onClose("io client disconnect");+ }}function isPacketValid(packet) {  switch (packet.type) {    case SIOPacketType.CONNECT:      return typeof packet.data === "object";+   case SIOPacketType.DISCONNECT:+     return packet.data === undefined;    case SIOPacketType.EVENT: {      const args = packet.data;      return (        Array.isArray(args) && args.length > 0 && typeof args[0] === "string"      );    }    default:      return false;  }}
```

# https://socket.io/how-to/check-the-latency-of-the-connection

# How to check the latency of the Socket.IO connection

You can test the latency of your application by sending a ping event to the server and acknowledging it on the other side:

Client

Server

Please note that most of the latency will likely come from the network, and not Socket.IO (which has about the same overhead as the underlying WebSocket connection).

The latency can be impacted by a lot of factors, the major one being obviously the distance between the server and the client.

That being said, a client stuck in HTTP long-polling will see a higher latency compared to WebSocket, as the latter keeps an open TCP connection between the server and the client and does not need to send the HTTP headers on each request.

Related:

- The connection is stuck in HTTP long-polling
- Performance tuning
- What is latency?
```js
import { io } from "socket.io-client";const socket = io("wss://example.com");setInterval(() => {  const start = Date.now();  socket.emit("ping", () => {    const duration = Date.now() - start;    console.log(duration);  });}, 1000);
```

```js
import { Server } from "socket.io";const io = new Server(3000);io.on("connection", (socket) => {  socket.on("ping", (callback) => {    callback();  });});
```

```js
import { io } from "socket.io-client";const socket = io("wss://example.com");setInterval(() => {  const start = Date.now();  socket.emit("ping", () => {    const duration = Date.now() - start;    console.log(duration);  });}, 1000);
```

```js
import { Server } from "socket.io";const io = new Server(3000);io.on("connection", (socket) => {  socket.on("ping", (callback) => {    callback();  });});
```

# https://socket.io/how-to/count-connected-clients

# How to count the number of connected clients

## Standalone​

## Cluster​

### Globally​

### In the main namespace​

### In a namespace​

### In a room​

### Solution 1: fetchSockets()​

### Solution 2: serverSideEmit()​

### Solution 3: external store​

The following snippets apply when using a single Socket.IO server:

This value is the number of low-level connections on the server.

If you are using a single namespace without any middleware, this value will be equal to io.engine.clientsCount.

If you are using multiple namespaces, for example when:

Then in that case io.engine.clientsCount will be 3, while totalCount() is only 2.

When scaling to multiple Socket.IO servers, computing the number of connected clients is a bit more complex.

Let's review several solutions and their pros and cons:

The fetchSockets() method sends a request to every node in the cluster, which respond with their local socket instances (the ones that are currently connected to the node).

However, this solution is not recommended, as it includes a lot of details about the socket instances (id, rooms, handshake data) and thus will not scale well.

Reference: fetchSockets()

Similarly, serverSideEmit() method sends an event to every node in the cluster, and waits for their responses.

This method is a bit better, as each server only returns the number of connected clients. However, it may not be suitable if called frequently, as it will generate a lot of chatter between the servers.

Reference: serverSideEmitWithAck()

The most efficient solution for this use case is to use an external store such as Redis.

Here's a naive implementation using the redis package:

The only problem with the solution above is that, if one server abruptly crashes, then the counter will not be updated properly and will then report a number that is higher than the reality.

To prevent this, one common solution is to have a counter per Socket.IO server, and a cleanup process which periodically checks the state of each server:

In Redis:

On each node:

Cleanup process:

That's all folks, thanks for reading!

See also: How to count the number of connected users

Back to the list of examples

- client A is connected to the main namespace (/)
- client B is connected to the /orders namespace
- client C is connected to both the main and the /orders namespaces (multiplexed over a single connection)
- in the main namespace
- in a room
- in the main namespace
- in a room
- StandaloneGloballyIn the main namespaceIn a namespaceIn a room
- Globally
- In the main namespace
- In a namespace
- In a room
- ClusterSolution 1: fetchSockets()Solution 2: serverSideEmit()Solution 3: external store
- Solution 1: fetchSockets()
- Solution 2: serverSideEmit()
- Solution 3: external store
```js
function totalCount() {  return io.engine.clientsCount;}const count = totalCount();
```

```js
function totalCount() {  return io.of("/").sockets.size;}const count = totalCount();
```

```js
function countInNamespace(namespace) {  return io.of(namespace).sockets.size;}const count = countInNamespace("/chat");
```

```js
function countInRoom(room) {  return io.of("/").adapter.rooms.get(room)?.size || 0;}const count = countInRoom("news");
```

```js
async function totalCount() {  const sockets = await io.fetchSockets();  return sockets.length;}const count = await totalCount();
```

```js
async function totalCount(room) {  const sockets = await io.in(room).fetchSockets();  return sockets.length;}const count = await totalCount("news");
```

```js
function localCount() {  return io.of("/").sockets.size;}io.on("totalCount", (cb) => {  cb(localCount());});async function totalCount() {  const remoteCounts = await io.serverSideEmitWithAck("totalCount");  return remoteCounts.reduce((a, b) => a + b, localCount());}const count = await totalCount();
```

```js
function localCount(room) {  return io.of("/").adapter.rooms.get(room)?.size || 0;}io.on("totalCount", (room, cb) => {  cb(localCount(room));});async function totalCount(room) {  const remoteCounts = await io.serverSideEmitWithAck("totalCount", room);    return remoteCounts.reduce((a, b) => a + b, localCount(room));}const count = await totalCount("news");
```

```js
io.on("connection", async (socket) => {  socket.on("disconnect", async () => {    await redisClient.decr("total-clients");  });    // remember to always run async methods after registering event handlers!  await redisClient.incr("total-clients");});async function totalCount() {  const val = await redisClient.get("total-clients");  return val || 0;}const count = await totalCount();
```

```js
// on startupconst processId = randomUUID();await redisClient.multi()  .sAdd("processes", processId)  .set(`${processId}:is-up`, "1", { EX: 10 })  .exec();setInterval(async () => {  await redisClient.expire(`${processId}:is-up`, 10);}, 5000);process.on("SIGINT", async () => {  await io.close(); // cleanly close the server and run the "disconnect" event handlers  process.exit(0);});io.on("connection", async (socket) => {  socket.on("disconnect", async () => {    await redisClient.multi()      .decr(`${processId}:total-clients`)      .decr("total-clients")      .exec();  });  await redisClient.multi()    .incr(`${processId}:total-clients`)    .incr("total-clients")    .exec();});async function totalCount() {  const val = await redisClient.get("total-clients");  return val || 0;}const count = await totalCount();
```

```js
setInterval(async () => {  const processes = await redisClient.sMembers("processes");  const states = await redisClient.mGet(processes.map(p => `${p}:is-up`));  for (let i = 0; i < processes.length; i++) {    if (states[i] === "1") {      continue;    }    const processId = processes[i];    const count = await redisClient.get(`${processId}:total-clients`);    await redisClient.multi()      .sRem("processes", processId)      .del(`${processId}:total-clients}`)      .decrBy("total-clients", count || 0)      .exec();  }}, 5000);
```

```js
function totalCount() {  return io.engine.clientsCount;}const count = totalCount();
```

```js
function totalCount() {  return io.of("/").sockets.size;}const count = totalCount();
```

```js
io.engine.clientsCount
```

```js
/orders
```

```js
/orders
```

```js
io.engine.clientsCount
```

```js
totalCount()
```

```js
function countInNamespace(namespace) {  return io.of(namespace).sockets.size;}const count = countInNamespace("/chat");
```

```js
function countInRoom(room) {  return io.of("/").adapter.rooms.get(room)?.size || 0;}const count = countInRoom("news");
```

```js
fetchSockets()
```

```js
fetchSockets()
```

```js
async function totalCount() {  const sockets = await io.fetchSockets();  return sockets.length;}const count = await totalCount();
```

```js
async function totalCount(room) {  const sockets = await io.in(room).fetchSockets();  return sockets.length;}const count = await totalCount("news");
```

```js
fetchSockets()
```

```js
serverSideEmit()
```

```js
serverSideEmit()
```

```js
function localCount() {  return io.of("/").sockets.size;}io.on("totalCount", (cb) => {  cb(localCount());});async function totalCount() {  const remoteCounts = await io.serverSideEmitWithAck("totalCount");  return remoteCounts.reduce((a, b) => a + b, localCount());}const count = await totalCount();
```

```js
function localCount(room) {  return io.of("/").adapter.rooms.get(room)?.size || 0;}io.on("totalCount", (room, cb) => {  cb(localCount(room));});async function totalCount(room) {  const remoteCounts = await io.serverSideEmitWithAck("totalCount", room);    return remoteCounts.reduce((a, b) => a + b, localCount(room));}const count = await totalCount("news");
```

```js
serverSideEmitWithAck()
```

```js
redis
```

```js
io.on("connection", async (socket) => {  socket.on("disconnect", async () => {    await redisClient.decr("total-clients");  });    // remember to always run async methods after registering event handlers!  await redisClient.incr("total-clients");});async function totalCount() {  const val = await redisClient.get("total-clients");  return val || 0;}const count = await totalCount();
```

```js
processes
```

```js
[process1, process2]
```

```js
process1:is-up
```

```js
process2:is-up
```

```js
total-clients
```

```js
process1:total-clients
```

```js
process2:total-clients
```

```js
// on startupconst processId = randomUUID();await redisClient.multi()  .sAdd("processes", processId)  .set(`${processId}:is-up`, "1", { EX: 10 })  .exec();setInterval(async () => {  await redisClient.expire(`${processId}:is-up`, 10);}, 5000);process.on("SIGINT", async () => {  await io.close(); // cleanly close the server and run the "disconnect" event handlers  process.exit(0);});io.on("connection", async (socket) => {  socket.on("disconnect", async () => {    await redisClient.multi()      .decr(`${processId}:total-clients`)      .decr("total-clients")      .exec();  });  await redisClient.multi()    .incr(`${processId}:total-clients`)    .incr("total-clients")    .exec();});async function totalCount() {  const val = await redisClient.get("total-clients");  return val || 0;}const count = await totalCount();
```

```js
setInterval(async () => {  const processes = await redisClient.sMembers("processes");  const states = await redisClient.mGet(processes.map(p => `${p}:is-up`));  for (let i = 0; i < processes.length; i++) {    if (states[i] === "1") {      continue;    }    const processId = processes[i];    const count = await redisClient.get(`${processId}:total-clients`);    await redisClient.multi()      .sRem("processes", processId)      .del(`${processId}:total-clients}`)      .decrBy("total-clients", count || 0)      .exec();  }}, 5000);
```

```js
fetchSockets()
```

```js
serverSideEmit()
```

# https://socket.io/how-to/count-connected-users

# How to count the number of connected users

## Standalone​

## Cluster​

### Single user presence​

### All users presence​

Counting connected users is a bit more complex than counting clients, because a single user can be connected across multiple tabs, browsers or even devices.

When using a single Socket.IO server, a Map should be sufficient:

In that case, computing the user presence is quite straightforward:

A simple yet effective solution to check whether a given user is online is to use the fetchSockets() method with one room per user ID:

The fetchSockets() method sends a request to every node in the cluster, which respond with their local socket instances (the ones that are currently connected to the node).

Reference: fetchSockets()

This works, however the fetchSockets() method includes a lot of details about the socket instances (id, rooms, handshake data). This can be slightly improved with the serverSideEmit() method:

The serverSideEmit() method sends an event to every node in the cluster, and waits for their responses.

Reference: serverSideEmitWithAck()

However, both methods do not allow to efficiently count and/or list all connected users.

The most efficient solution for this use case is to use an external store like Redis.

In Redis:

Notes:

Let's start by creating a custom HDECR method, which will decrement a field of the hash, and delete it if it drops to 0. We will use a Lua script, so both commands are executed atomically:

Now we'll simply:

Here we go:

Finally, we can use the users hash to compute the user presence:

The cleanup process periodically checks for dead processes:

That's all folks, thanks for reading!

See also: How to count the number of connected clients

Back to the list of examples

- the users hash tracks the number of socket instances per user ID
- the <processId>:users hashes are used in case one server abruptly crashes and fails to update the users hash
- call HINCRBY upon connection
- call our custom HDECR command upon disconnection
- Standalone
- ClusterSingle user presenceAll users presence
- Single user presence
- All users presence
```js
function computeUserId(socket) {  // parse cookie / read JWT token / ... and retrieve the user ID (to be implemented)}const users = new Map();function handleConnection(userId) {  const count = users.get(userId) || 0;  users.set(userId, count + 1);  return count === 0;}function handleDisconnection(userId) {  const count = users.get(userId) - 1;  if (count === 0) {    users.delete(userId);  } else {    users.set(userId, count);  }  return count === 0;}io.on("connection", (socket) => {  const userId = computeUserId(socket);  const hasConnected = handleConnection(userId);  if (hasConnected) {    io.emit("user has connected", userId);  }  socket.on("disconnect", () => {    const hasDisconnected = handleDisconnection(userId);    if (hasDisconnected) {      io.emit("user has disconnected", userId);    }  });});
```

```js
function isUserConnected(userId) {  return users.has(userId);}function usersCount() {  return users.size;}function usersList() {  return [...users.keys()];}
```

```js
io.on("connection", (socket) => {  const userId = computeUserId(socket);  socket.join(userId);});async function isUserConnected(userId) {  const sockets = await io.in(userId).fetchSockets();  return sockets.length > 0;}
```

```js
const users = new Map();io.on("connection", (socket) => {  // update the `users` map (see the "Standalone" section above)});function isUserConnectedOnThisNode(userId) {  return users.has(userId);}io.on("isUserConnected", (userId, cb) => {  cb(isUserConnectedOnThisNode(userId));});async function isUserConnected(userId) {  if (isUserConnectedOnThisNode(userId)) {    return true;  }  const responses = await io.serverSideEmitWithAck("isUserConnected", userId);  return responses.some(r => r);}
```

```js
import { createClient, defineScript } from "redis";const redisClient = createClient({  url: "redis://...",  scripts: {    hDecr: defineScript({      NUMBER_OF_KEYS: 1,      SCRIPT:        `          local count = redis.call('HINCRBY', KEYS[1], ARGV[1], -1)          if count == 0 then            redis.call('HDEL', KEYS[1], ARGV[1])          end          return count        `,      transformArguments(key, userId) {        return [key, userId];      }    }),  },});
```

```js
const processId = randomUUID();// add the process ID to the "processes" setawait redisClient.multi()  .sAdd("processes", processId)  .set(`${processId}:is-up`, "1", { EX: 10 })  .exec();setInterval(async () => {  // notify that the process is still alive  await redisClient.expire(`${processId}:is-up`, 10);}, 5000);async function handleConnection(userId) {  // atomically increment the `userId` field in both hashes  const [res] = await redisClient.multi()    .hIncrBy("users", userId, 1)    .hIncrBy(`${processId}:users`, userId, 1)    .exec();  return res === 1;}async function handleDisconnection(userId) {  // atomically decrement the `userId` field in both hashes  const [res] = await redisClient.multi()    .hDecr("users", userId)    .hDecr(`${processId}:users`, userId)    .exec();  return res === 0;}io.on("connection", async (socket) => {  const userId = computeUserId(socket);  const hasConnected = await handleConnection(userId);  if (hasConnected) {    io.emit("user has connected", userId);  }  socket.on("disconnect", async () => {    const hasDisconnected = await handleDisconnection(userId);    if (hasDisconnected) {      io.emit("user has disconnected", userId);    }  });});
```

```js
function isUserConnected(userId) {  return redisClient.hExists("users", userId);}function usersCount() {  return redisClient.hLen("users");}function usersList() {  return redisClient.hKeys("users");}
```

```js
import { createClient, defineScript } from "redis";const redisClient = createClient({  url: "redis://...",  scripts: {    cleanup: defineScript({      NUMBER_OF_KEYS: 2,      SCRIPT:        `          local disconnected_users = {}          local values = redis.call('HGETALL', KEYS[2])          for i = 1, #values, 2 do            local user_id = values[i]            local socket_count = tonumber(values[i + 1])            local count = redis.call('HINCRBY', KEYS[1], user_id, -socket_count)            if count == 0 then              redis.call('HDEL', KEYS[1], user_id)              table.insert(disconnected_users, user_id)            end          end          redis.call('DEL', KEYS[2])          return disconnected_users        `,      transformArguments(key, processKey) {        return [key, processKey];      }    }),  },});await redisClient.connect();setInterval(async () => {  const processes = await redisClient.sMembers("processes");  const states = await redisClient.mGet(processes.map(p => `${p}:is-up`));  for (let i = 0; i < processes.length; i++) {    if (states[i] === "1") {      continue;    }    const processId = processes[i];    await redisClient.multi()      .cleanup("users", `${processId}:users`)      .sRem("processes", processId)      .exec();    // TODO emit the "user has disconnected" events  }}, 5000);
```

```js
function computeUserId(socket) {  // parse cookie / read JWT token / ... and retrieve the user ID (to be implemented)}const users = new Map();function handleConnection(userId) {  const count = users.get(userId) || 0;  users.set(userId, count + 1);  return count === 0;}function handleDisconnection(userId) {  const count = users.get(userId) - 1;  if (count === 0) {    users.delete(userId);  } else {    users.set(userId, count);  }  return count === 0;}io.on("connection", (socket) => {  const userId = computeUserId(socket);  const hasConnected = handleConnection(userId);  if (hasConnected) {    io.emit("user has connected", userId);  }  socket.on("disconnect", () => {    const hasDisconnected = handleDisconnection(userId);    if (hasDisconnected) {      io.emit("user has disconnected", userId);    }  });});
```

```js
function isUserConnected(userId) {  return users.has(userId);}function usersCount() {  return users.size;}function usersList() {  return [...users.keys()];}
```

```js
fetchSockets()
```

```js
fetchSockets()
```

```js
fetchSockets()
```

```js
io.on("connection", (socket) => {  const userId = computeUserId(socket);  socket.join(userId);});async function isUserConnected(userId) {  const sockets = await io.in(userId).fetchSockets();  return sockets.length > 0;}
```

```js
fetchSockets()
```

```js
serverSideEmit()
```

```js
serverSideEmit()
```

```js
serverSideEmitWithAck()
```

```js
const users = new Map();io.on("connection", (socket) => {  // update the `users` map (see the "Standalone" section above)});function isUserConnectedOnThisNode(userId) {  return users.has(userId);}io.on("isUserConnected", (userId, cb) => {  cb(isUserConnectedOnThisNode(userId));});async function isUserConnected(userId) {  if (isUserConnectedOnThisNode(userId)) {    return true;  }  const responses = await io.serverSideEmitWithAck("isUserConnected", userId);  return responses.some(r => r);}
```

```js
processes
```

```js
[process1, process2]
```

```js
process1:is-up
```

```js
process2:is-up
```

```js
users
```

```js
{ user1: 2, user2: 1 }
```

```js
process1:users
```

```js
{ user1: 1, user2: 1 }
```

```js
process2:users
```

```js
{ user1: 1 }
```

```js
users
```

```js
<processId>:users
```

```js
users
```

```js
HDECR
```

```js
import { createClient, defineScript } from "redis";const redisClient = createClient({  url: "redis://...",  scripts: {    hDecr: defineScript({      NUMBER_OF_KEYS: 1,      SCRIPT:        `          local count = redis.call('HINCRBY', KEYS[1], ARGV[1], -1)          if count == 0 then            redis.call('HDEL', KEYS[1], ARGV[1])          end          return count        `,      transformArguments(key, userId) {        return [key, userId];      }    }),  },});
```

```js
HINCRBY
```

```js
HDECR
```

```js
const processId = randomUUID();// add the process ID to the "processes" setawait redisClient.multi()  .sAdd("processes", processId)  .set(`${processId}:is-up`, "1", { EX: 10 })  .exec();setInterval(async () => {  // notify that the process is still alive  await redisClient.expire(`${processId}:is-up`, 10);}, 5000);async function handleConnection(userId) {  // atomically increment the `userId` field in both hashes  const [res] = await redisClient.multi()    .hIncrBy("users", userId, 1)    .hIncrBy(`${processId}:users`, userId, 1)    .exec();  return res === 1;}async function handleDisconnection(userId) {  // atomically decrement the `userId` field in both hashes  const [res] = await redisClient.multi()    .hDecr("users", userId)    .hDecr(`${processId}:users`, userId)    .exec();  return res === 0;}io.on("connection", async (socket) => {  const userId = computeUserId(socket);  const hasConnected = await handleConnection(userId);  if (hasConnected) {    io.emit("user has connected", userId);  }  socket.on("disconnect", async () => {    const hasDisconnected = await handleDisconnection(userId);    if (hasDisconnected) {      io.emit("user has disconnected", userId);    }  });});
```

```js
users
```

```js
function isUserConnected(userId) {  return redisClient.hExists("users", userId);}function usersCount() {  return redisClient.hLen("users");}function usersList() {  return redisClient.hKeys("users");}
```

```js
import { createClient, defineScript } from "redis";const redisClient = createClient({  url: "redis://...",  scripts: {    cleanup: defineScript({      NUMBER_OF_KEYS: 2,      SCRIPT:        `          local disconnected_users = {}          local values = redis.call('HGETALL', KEYS[2])          for i = 1, #values, 2 do            local user_id = values[i]            local socket_count = tonumber(values[i + 1])            local count = redis.call('HINCRBY', KEYS[1], user_id, -socket_count)            if count == 0 then              redis.call('HDEL', KEYS[1], user_id)              table.insert(disconnected_users, user_id)            end          end          redis.call('DEL', KEYS[2])          return disconnected_users        `,      transformArguments(key, processKey) {        return [key, processKey];      }    }),  },});await redisClient.connect();setInterval(async () => {  const processes = await redisClient.sMembers("processes");  const states = await redisClient.mGet(processes.map(p => `${p}:is-up`));  for (let i = 0; i < processes.length; i++) {    if (states[i] === "1") {      continue;    }    const processId = processes[i];    await redisClient.multi()      .cleanup("users", `${processId}:users`)      .sRem("processes", processId)      .exec();    // TODO emit the "user has disconnected" events  }}, 5000);
```

# https://socket.io/how-to/deal-with-cookies

# How to deal with cookies

## Cookie-based sticky session​

## Application cookies​

## Node.js client and cookies​

When using the cookie option, the server will send a cookie upon handshake (the first HTTP request of the session), with the value of the Engine.IO session ID.

You can test it with a curl:

Available options (from the cookie package):

This cookie can then be used for cookie-based sticky session, when scaling to multiple nodes (example with HAProxy here).

You can also customize the headers sent by the server:

Please note that event emitters are synchronous:

If you need to do some async operations, you will need to use the allowRequest option.

Please check this example with express-session for reference.

Starting with version 4.7.0, when setting the withCredentials option to true, the Node.js client will now include the cookies in the HTTP requests, making it easier to use it with cookie-based sticky sessions.

- domain
- encode
- expires
- httpOnly
- maxAge
- path
- sameSite
- secure
- Cookie-based sticky session
- Application cookies
- Node.js client and cookies
```js
const io = new Server(httpServer, {  cookie: true});// is similar toconst io = new Server(httpServer, {  cookie: {    name: "io",    path: "/",    httpOnly: true,    sameSite: "lax"  }});
```

```js
$ curl "https://mydomain.com/socket.io/?EIO=4&transport=polling" -v< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-8< Content-Length: 97< Set-Cookie: io=G4J3Ci0cNDWd_Fz-AAAC; Path=/; HttpOnly; SameSite=Lax<0{"sid":"G4J3Ci0cNDWd_Fz-AAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}
```

```js
import { serialize, parse } from "cookie";// called during the handshakeio.engine.on("initial_headers", (headers, request) => {  headers["set-cookie"] = serialize("uid", "1234", { sameSite: "strict" });});// called for each HTTP request (including the WebSocket upgrade)io.engine.on("headers", (headers, request) => {  if (!request.headers.cookie) return;  const cookies = parse(request.headers.cookie);  if (!cookies.randomId) {    headers["set-cookie"] = serialize("randomId", "abc", { maxAge: 86400 });  }});
```

```js
io.engine.on("initial_headers", async (headers, request) => {  // WARNING! this won't work  const session = await fetchSession(request);  headers["set-cookie"] = serialize("sid", session.id, { sameSite: "strict" });});
```

```js
cookie
```

```js
const io = new Server(httpServer, {  cookie: true});// is similar toconst io = new Server(httpServer, {  cookie: {    name: "io",    path: "/",    httpOnly: true,    sameSite: "lax"  }});
```

```js
curl
```

```js
$ curl "https://mydomain.com/socket.io/?EIO=4&transport=polling" -v< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-8< Content-Length: 97< Set-Cookie: io=G4J3Ci0cNDWd_Fz-AAAC; Path=/; HttpOnly; SameSite=Lax<0{"sid":"G4J3Ci0cNDWd_Fz-AAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}
```

```js
cookie
```

```js
import { serialize, parse } from "cookie";// called during the handshakeio.engine.on("initial_headers", (headers, request) => {  headers["set-cookie"] = serialize("uid", "1234", { sameSite: "strict" });});// called for each HTTP request (including the WebSocket upgrade)io.engine.on("headers", (headers, request) => {  if (!request.headers.cookie) return;  const cookies = parse(request.headers.cookie);  if (!cookies.randomId) {    headers["set-cookie"] = serialize("randomId", "abc", { maxAge: 86400 });  }});
```

```js
io.engine.on("initial_headers", async (headers, request) => {  // WARNING! this won't work  const session = await fetchSession(request);  headers["set-cookie"] = serialize("sid", session.id, { sameSite: "strict" });});
```

```js
allowRequest
```

```js
express-session
```

```js
4.7.0
```

```js
withCredentials
```

```js
true
```

# https://socket.io/how-to/disconnect-a-specific-client

# How to disconnect a specific client

## Standalone​

## Cluster​

### Without acknowledgement​

### With acknowledgement​

Reference: server.disconnectSockets([close])

This method can also be used to disconnect a given user:

Reference: server.serverSideEmitWithAck(eventName[, ...args]);

< Back to the list of examples

- Standalone
- ClusterWithout acknowledgementWith acknowledgement
- Without acknowledgement
- With acknowledgement
```js
function disconnectSocket(id) {  io.of("/").sockets.get(id)?.disconnect();}
```

```js
function disconnectSocket(id) {  io.in(id).disconnectSockets();}
```

```js
function computeUserId(socket) {  // to be implemented}io.on("connection", (socket) => {  const userId = computeUserId(socket);  socket.join(userId); // use a room named after the user ID});function disconnectUser(userId) {  io.in(userId).disconnectSockets();}
```

```js
function disconnectLocalSocket(id) {  return io.of("/").sockets.get(id)?.disconnect() !== undefined;}io.on("disconnectSocket", (id, cb) => {  cb(disconnectLocalSocket(id));});async function disconnectSocket(id) {  if (disconnectLocalSocket(id)) {    return true;  }  try {    const res = await io.serverSideEmitWithAck("disconnectSocket", id);    return res.some(v => v);  } catch (e) {    // something went wrong  }}
```

```js
function disconnectSocket(id) {  io.of("/").sockets.get(id)?.disconnect();}
```

```js
function disconnectSocket(id) {  io.in(id).disconnectSockets();}
```

```js
server.disconnectSockets([close])
```

```js
function computeUserId(socket) {  // to be implemented}io.on("connection", (socket) => {  const userId = computeUserId(socket);  socket.join(userId); // use a room named after the user ID});function disconnectUser(userId) {  io.in(userId).disconnectSockets();}
```

```js
function disconnectLocalSocket(id) {  return io.of("/").sockets.get(id)?.disconnect() !== undefined;}io.on("disconnectSocket", (id, cb) => {  cb(disconnectLocalSocket(id));});async function disconnectSocket(id) {  if (disconnectLocalSocket(id)) {    return true;  }  try {    const res = await io.serverSideEmitWithAck("disconnectSocket", id);    return res.some(v => v);  } catch (e) {    // something went wrong  }}
```

```js
server.serverSideEmitWithAck(eventName[, ...args]);
```

# https://socket.io/how-to/get-the-ip-address-of-the-client

# How to get the IP address of the client

## Direct connection​

## Behind a proxy​

### X-Forwarded-For header​

### Forwarded header​

### CloudFlare​

### Fastly​

The IP address of the client can be found in the handshake object:

If you are behind a proxy like nginx, the address attribute will be the IP address of the proxy.

In that case, the IP address of the client will be found in the request headers.

The X-Forwarded-For request header was a de-facto standard header for identifying the originating IP address of a client connecting to a web server through a proxy server.

Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For

Format:

Here's how you can retrieve the IP address of the client:

The X-Forwarded-For header is now deprecated (although still widely used) in favor of the standard Forwarded header.

The Forwarded request header is the standard header for identifying the originating IP address of a client connecting to a web server through a proxy server.

Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded

Format:

Here's how you can retrieve the IP address of the client:

This parseHeader() method does not cover every edge case allowed by the specification. If you need a more robust method, please check the forwarded-parse package.

CloudFlare uses a specific header: cf-connecting-ip

Reference: https://developers.cloudflare.com/fundamentals/reference/http-request-headers/

Here's how you can retrieve the IP address of the client:

Fastly uses a specific header: fastly-client-ip

Reference: https://developer.fastly.com/reference/http/http-headers/Fastly-Client-IP/

Here's how you can retrieve the IP address of the client:

- Direct connection
- Behind a proxyX-Forwarded-For headerForwarded headerCloudFlareFastly
- X-Forwarded-For header
- Forwarded header
- CloudFlare
- Fastly
```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.address;  console.log(ipAddress); // prints something like "203.0.113.195" (IPv4) or "2001:db8:85a3:8d3:1319:8a2e:370:7348" (IPv6)});
```

```js
X-Forwarded-For: <client>, <proxy1>, <proxy2>
```

```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.headers["x-forwarded-for"].split(",")[0];  console.log(ipAddress);});
```

```js
Forwarded: by=<identifier>;for=<identifier>;host=<host>;proto=<http|https>
```

```js
function parseHeader(header) {  for (const directive of header.split(",")[0].split(";")) {    if (directive.startsWith("for=")) {      return directive.substring(4);    }  }}io.on("connection", (socket) => {  const ipAddress = parseHeader(socket.handshake.headers["forwarded"] || "");  console.log(ipAddress);});
```

```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.headers["cf-connecting-ip"];  console.log(ipAddress);});
```

```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.headers["fastly-client-ip"];  console.log(ipAddress);});
```

```js
handshake
```

```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.address;  console.log(ipAddress); // prints something like "203.0.113.195" (IPv4) or "2001:db8:85a3:8d3:1319:8a2e:370:7348" (IPv6)});
```

```js
address
```

```js
X-Forwarded-For
```

```js
X-Forwarded-For
```

```js
X-Forwarded-For: <client>, <proxy1>, <proxy2>
```

```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.headers["x-forwarded-for"].split(",")[0];  console.log(ipAddress);});
```

```js
X-Forwarded-For
```

```js
Forwarded
```

```js
Forwarded
```

```js
Forwarded
```

```js
Forwarded: by=<identifier>;for=<identifier>;host=<host>;proto=<http|https>
```

```js
function parseHeader(header) {  for (const directive of header.split(",")[0].split(";")) {    if (directive.startsWith("for=")) {      return directive.substring(4);    }  }}io.on("connection", (socket) => {  const ipAddress = parseHeader(socket.handshake.headers["forwarded"] || "");  console.log(ipAddress);});
```

```js
parseHeader()
```

```js
forwarded-parse
```

```js
cf-connecting-ip
```

```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.headers["cf-connecting-ip"];  console.log(ipAddress);});
```

```js
fastly-client-ip
```

```js
io.on("connection", (socket) => {  const ipAddress = socket.handshake.headers["fastly-client-ip"];  console.log(ipAddress);});
```

```js
X-Forwarded-For
```

```js
Forwarded
```

# https://socket.io/how-to/handle-eaddrinused-errors

# How to handle EADDRINUSE errors

One of the most common errors raised when starting a HTTP server is EADDRINUSE. This happens when another server is already listening on the requested port/path/handle:

On Linux, you can use the netstat command to identify which process currently uses the port:

When testing, you might not need to use a specific port. You can simply omit the port (or use 0) and the operating system will automatically pick an arbitrary unused port for you:

Back to the list of examples

- CommonJS
- ES modules
- TypeScript
```js
node:events:489      throw er; // Unhandled 'error' event      ^Error: listen EADDRINUSE: address already in use :::8080    at Server.setupListenHandle [as _listen2] (node:net:1829:16)    at listenInCluster (node:net:1877:12)    at Server.listen (node:net:1965:7)
```

```js
$ netstat -ap | grep 8080 | grep LISTENtcp        0      0 localhost:8080          0.0.0.0:*               LISTEN      12345/node
```

```js
const { createServer } = require("node:http");const { Server } = require("socket.io");const httpServer = createServer();const io = new Server(httpServer);httpServer.listen(() => {  const port = httpServer.address().port;  // ...});
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer);httpServer.listen(() => {  const port = httpServer.address().port;  // ...});
```

```js
import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer);httpServer.listen(() => {  const port = (httpServer.address() as AddressInfo).port;  // ...});
```

```js
EADDRINUSE
```

```js
EADDRINUSE
```

```js
port
```

```js
path
```

```js
handle
```

```js
node:events:489      throw er; // Unhandled 'error' event      ^Error: listen EADDRINUSE: address already in use :::8080    at Server.setupListenHandle [as _listen2] (node:net:1829:16)    at listenInCluster (node:net:1877:12)    at Server.listen (node:net:1965:7)
```

```js
netstat
```

```js
$ netstat -ap | grep 8080 | grep LISTENtcp        0      0 localhost:8080          0.0.0.0:*               LISTEN      12345/node
```

```js
const { createServer } = require("node:http");const { Server } = require("socket.io");const httpServer = createServer();const io = new Server(httpServer);httpServer.listen(() => {  const port = httpServer.address().port;  // ...});
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer);httpServer.listen(() => {  const port = httpServer.address().port;  // ...});
```

```js
import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer);httpServer.listen(() => {  const port = (httpServer.address() as AddressInfo).port;  // ...});
```

# https://socket.io/how-to/implement-a-subscription-model

# How to implement a subscription model

## Client​

## Server​

## Additional notes​

### List of subscriptions​

### Connection state recovery​

By default, events are sent over the wire even if there is no registered event handler on the other side.

You can catch those missing event handlers with a catch-all listener:

Reference:  onAny() method

To only receive a list of specific events (for example, if a part of your application only needs a handful of events), you can implement a subscription model:

We could have used a ES6 Set for the subscriptions on the client side:

Which is cleaner (no need to handle duplicate subscriptions, for example) but would require a polyfill if you need to target old platforms.

In the "connect" handler:

The !socket.recovered condition is related to the Connection state recovery feature.

If the connection state was successfully recovered, then the subscriptions (the rooms on the server side) will be automatically restored.

Reference: socket.recovered attribute

- Client
- Server
- Additional notesList of subscriptionsConnection state recovery
- List of subscriptions
- Connection state recovery
```js
socket.onAny((event) => {  if (socket.listeners(event).length === 0) {    console.log(`missing handler for event ${event}`);  }});
```

```js
const subscriptions = [];function subscribe(topic) {  subscriptions.push(topic);  if (socket.connected) {    socket.emit("subscribe", [topic]);  }}function unsubscribe(topic) {  const i = subscriptions.indexOf(topic);  if (i !== -1) {    subscriptions.splice(i, 1);    if (socket.connected) {      socket.emit("unsubscribe", topic);    }  }}// restore the subscriptions upon reconnectionsocket.on("connect", () => {  if (subscriptions.length && !socket.recovered) {    socket.emit("subscribe", subscriptions);  }});subscribe("foo");
```

```js
io.on("connection", (socket) => {  socket.on("subscribe", (topics) => {    socket.join(topics);  });  socket.on("unsubscribe", (topic) => {    socket.leave(topic);  });  // send an event only to clients that have shown interest in the "foo" topic  io.to("foo").emit("foo");});
```

```js
const subscriptions = new Set();function subscribe(topic) {  subscriptions.add(topic);  if (socket.connected) {    socket.emit("subscribe", [topic]);  }}function unsubscribe(topic) {  const deleted = subscriptions.delete(topic);  if (deleted && socket.connected) {    socket.emit("unsubscribe", topic);  }}// restore the subscriptions upon reconnectionsocket.on("connect", () => {  if (subscriptions.size) {    socket.emit("subscribe", [...subscriptions]);  }});
```

```js
socket.on("connect", () => {  if (subscriptions.length && !socket.recovered) {    socket.emit("subscribe", subscriptions);  }});
```

```js
socket.onAny((event) => {  if (socket.listeners(event).length === 0) {    console.log(`missing handler for event ${event}`);  }});
```

```js
onAny()
```

```js
const subscriptions = [];function subscribe(topic) {  subscriptions.push(topic);  if (socket.connected) {    socket.emit("subscribe", [topic]);  }}function unsubscribe(topic) {  const i = subscriptions.indexOf(topic);  if (i !== -1) {    subscriptions.splice(i, 1);    if (socket.connected) {      socket.emit("unsubscribe", topic);    }  }}// restore the subscriptions upon reconnectionsocket.on("connect", () => {  if (subscriptions.length && !socket.recovered) {    socket.emit("subscribe", subscriptions);  }});subscribe("foo");
```

```js
io.on("connection", (socket) => {  socket.on("subscribe", (topics) => {    socket.join(topics);  });  socket.on("unsubscribe", (topic) => {    socket.leave(topic);  });  // send an event only to clients that have shown interest in the "foo" topic  io.to("foo").emit("foo");});
```

```js
const subscriptions = new Set();function subscribe(topic) {  subscriptions.add(topic);  if (socket.connected) {    socket.emit("subscribe", [topic]);  }}function unsubscribe(topic) {  const deleted = subscriptions.delete(topic);  if (deleted && socket.connected) {    socket.emit("unsubscribe", topic);  }}// restore the subscriptions upon reconnectionsocket.on("connect", () => {  if (subscriptions.size) {    socket.emit("subscribe", [...subscriptions]);  }});
```

```js
socket.on("connect", () => {  if (subscriptions.length && !socket.recovered) {    socket.emit("subscribe", subscriptions);  }});
```

```js
!socket.recovered
```

```js
socket.recovered
```

# https://socket.io/how-to/register-a-global-middleware

# How to register a global middleware

In Socket.IO v2, a middleware that was registered for the main namespace would act as a global middleware, applying to all namespaces, since a client would first connect to the main namespace, and then to the custom namespace:

This is not the case any more starting with Socket.IO v3: a middleware attached to the main namespace is only called when a client tries to reach the main namespace:

To create a global middleware in newer versions, you need to attach your middleware to all namespaces:

The namespaces that are registered before the new_namespace listener won't be affected.

Existing namespaces always have priority over dynamic namespaces. For example:

Related:

- either manually:
- or by using the new_namespace event:
- or, when using dynamic namespaces, by registering a middleware on the parent namespace:
- Middleware documentation
- v2 to v3 migration
```js
// Socket.IO v2io.use((socket, next) => {  // always triggered, even if the client tries to reach the custom namespace  next();});io.of("/my-custom-namespace").use((socket, next) => {  // triggered after the global middleware  next();});
```

```js
// Socket.IO v3 and aboveio.use((socket, next) => {  // only triggered when the client tries to reach the main namespace  next();});io.of("/my-custom-namespace").use((socket, next) => {  // only triggered when the client tries to reach this custom namespace  next();});
```

```js
const myGlobalMiddleware = (socket, next) => {  next();}io.use(myGlobalMiddleware);io.of("/my-custom-namespace").use(myGlobalMiddleware);
```

```js
const myGlobalMiddleware = (socket, next) => {  next();}io.use(myGlobalMiddleware);io.on("new_namespace", (namespace) => {  namespace.use(myGlobalMiddleware);});// and then declare the namespacesio.of("/my-custom-namespace");
```

```js
const myGlobalMiddleware = (socket, next) => {  next();}io.use(myGlobalMiddleware);const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.use(myGlobalMiddleware);
```

```js
io.of("/admin");io.of(/.*/).use((socket, next) => {  // won't be called for the main namespace nor for the "/admin" namespace  next();});
```

```js
// Socket.IO v2io.use((socket, next) => {  // always triggered, even if the client tries to reach the custom namespace  next();});io.of("/my-custom-namespace").use((socket, next) => {  // triggered after the global middleware  next();});
```

```js
// Socket.IO v3 and aboveio.use((socket, next) => {  // only triggered when the client tries to reach the main namespace  next();});io.of("/my-custom-namespace").use((socket, next) => {  // only triggered when the client tries to reach this custom namespace  next();});
```

```js
const myGlobalMiddleware = (socket, next) => {  next();}io.use(myGlobalMiddleware);io.of("/my-custom-namespace").use(myGlobalMiddleware);
```

```js
new_namespace
```

```js
const myGlobalMiddleware = (socket, next) => {  next();}io.use(myGlobalMiddleware);io.on("new_namespace", (namespace) => {  namespace.use(myGlobalMiddleware);});// and then declare the namespacesio.of("/my-custom-namespace");
```

```js
new_namespace
```

```js
const myGlobalMiddleware = (socket, next) => {  next();}io.use(myGlobalMiddleware);const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.use(myGlobalMiddleware);
```

```js
io.of("/admin");io.of(/.*/).use((socket, next) => {  // won't be called for the main namespace nor for the "/admin" namespace  next();});
```

# https://socket.io/how-to/upload-a-file

# How to upload a file

## Additional notes​

### maxHttpBufferSize limit​

### Over the wire​

Files can be sent as is:

The file will be received as a Buffer on the server side:

While uploading a file, you might reach the maxHttpBufferSize value, which is the maximum allowed message size in bytes. It defaults to 1 MB.

You can increase this value, according to your use case:

Reference: maxHttpBufferSize option

Like other binary structures (ArrayBuffer, Blob), the arguments of the emit() method will be sent as two WebSocket frames over the wire:

First, a text frame:

And then a binary frame (one per binary structure):

Depending on your use case, you may change this behavior by using a custom parser.

- Additional notesmaxHttpBufferSize limitOver the wire
- maxHttpBufferSize limit
- Over the wire
```js
<!doctype html><html lang="en">  <body>    <input type="file" onchange="upload(this.files)" />    <script src="/path/to/socket.io.js"></script>    <script>      const socket = io();      function upload(files) {        socket.emit("upload", files[0], (status) => {          console.log(status);        });      }    </script>  </body></html>
```

```js
import { writeFile } from "fs";io.on("connection", (socket) => {  socket.on("upload", (file, callback) => {    console.log(file); // <Buffer 25 50 44 ...>    // save the content to the disk, for example    writeFile("/tmp/upload", file, (err) => {      callback({ message: err ? "failure" : "success" });    });  });});
```

```js
import { Server } from "socket.io";const io = new Server({  maxHttpBufferSize: 1e8 // 100 MB});
```

```js
451-["upload",{"_placeholder":true,"num":0}]||||└─ JSON-encoded payload with placeholders for binary attachments|||||||└─ separator||└─ number of binary attachments|└─ socket.io BINARY EVENT packet type└─ engine.io MESSAGE packet type
```

```js
<0x25 0x50 0x44 ...>
```

```js
<!doctype html><html lang="en">  <body>    <input type="file" onchange="upload(this.files)" />    <script src="/path/to/socket.io.js"></script>    <script>      const socket = io();      function upload(files) {        socket.emit("upload", files[0], (status) => {          console.log(status);        });      }    </script>  </body></html>
```

```js
import { writeFile } from "fs";io.on("connection", (socket) => {  socket.on("upload", (file, callback) => {    console.log(file); // <Buffer 25 50 44 ...>    // save the content to the disk, for example    writeFile("/tmp/upload", file, (err) => {      callback({ message: err ? "failure" : "success" });    });  });});
```

```js
maxHttpBufferSize
```

```js
maxHttpBufferSize
```

```js
import { Server } from "socket.io";const io = new Server({  maxHttpBufferSize: 1e8 // 100 MB});
```

```js
maxHttpBufferSize
```

```js
emit()
```

```js
451-["upload",{"_placeholder":true,"num":0}]||||└─ JSON-encoded payload with placeholders for binary attachments|||||||└─ separator||└─ number of binary attachments|└─ socket.io BINARY EVENT packet type└─ engine.io MESSAGE packet type
```

```js
<0x25 0x50 0x44 ...>
```

```js
maxHttpBufferSize
```

# https://socket.io/how-to/use-with-express-session

# How to use with express-session

## Sharing the session context​

## Using the session ID​

## Modifying the session​

## Handling session expiration​

## Notes for cross-site requests​

Let's start from a basic application:

You'll need those additional types:

The session context can be shared with the Socket.IO server by calling:

As simple as that! You'll now have access to the session object:

You can use the session ID to make the link between Express and Socket.IO:

You can then notify every connected client in the /incr handler:

Same for the log-out flow:

Since it is not bound to a single HTTP request, the session must be manually reloaded and saved:

You can also use a middleware which will be triggered for each incoming packet:

Calling req.session.reload() updates the req.session object:

You may also want to periodically reload the session, in case it expires (for example if the client does not send any event for an extended period of time):

express-session relies on a cookie to persist the session in the browser. So if your frontend domain is different from your backend domain (for example, if you have a SPA running on your machine but on a different port), then you will need to send the appropriate CORS headers:

You will also need to set the withCredentials option to true on the client side:

That's it for the compatibility with express-session. Thanks for reading!

You can run this example directly in your browser on:

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
- Sharing the session context
- Using the session ID
- Modifying the session
- Handling session expiration
- Notes for cross-site requests
```js
const express = require("express");const { createServer } = require("node:http");const { join } = require("node:path");const { Server } = require("socket.io");const session = require("express-session");const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { createServer } from "node:http";import { Server } from "socket.io";import session from "express-session";const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.get("/", (req, res) => {  res.sendFile(new URL("./index.html", import.meta.url).pathname);});app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express = require("express");import { createServer } from "node:http";import { Server } from "socket.io";import session from "express-session";declare module "express-session" {  interface SessionData {    count: number;  }}const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.get("/", (req, res) => {  res.sendFile(new URL("./index.html", import.meta.url).pathname);});app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
npm install @types/express @types/express-session
```

```js
io.engine.use(sessionMiddleware);
```

```js
io.on("connection", (socket) => {  const session = socket.request.session;});
```

```js
io.on("connection", (socket) => {  const sessionId = socket.request.session.id;  // the session ID is used as a room  socket.join(sessionId);});
```

```js
app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);  io.to(session.id).emit("current count", session.count);});
```

```js
app.post("/logout", (req, res) => {  const sessionId = req.session.id;  req.session.destroy(() => {    // disconnect all Socket.IO connections linked to this session ID    io.in(sessionId).disconnectSockets();    res.status(204).end();  });});
```

```js
io.on("connection", (socket) => {  const req = socket.request;  socket.on("my event", () => {    req.session.reload((err) => {      if (err) {        return socket.disconnect();      }      req.session.count++;      req.session.save();    });  });});
```

```js
io.on("connection", (socket) => {  const req = socket.request;  socket.on("my event", () => {    req.session.reload((err) => {      if (err) {        return socket.disconnect();      }      req.session.count++;      req.session.save();    });  });});
```

```js
import { type Request } from "express";io.on("connection", (socket) => {  const req = socket.request as Request;  socket.on("my event", () => {    req.session.reload((err) => {      if (err) {        return socket.disconnect();      }      req.session.count++;      req.session.save();    });  });});
```

```js
io.on("connection", (socket) => {  const req = socket.request;  socket.use((__, next) => {    req.session.reload((err) => {      if (err) {        socket.disconnect();      } else {        next();      }    });  });  // and then simply  socket.on("my event", () => {    req.session.count++;    req.session.save();  });});
```

```js
io.on("connection", (socket) => {  const session = socket.request.session;  socket.use((__, next) => {    session.reload(() => {      // WARNING! "session" still points towards the previous session object    });  });});
```

```js
const SESSION_RELOAD_INTERVAL = 30 * 1000;io.on("connection", (socket) => {  const timer = setInterval(() => {    socket.request.session.reload((err) => {      if (err) {        // forces the client to reconnect        socket.conn.close();        // you can also use socket.disconnect(), but in that case the client        // will not try to reconnect      }    });  }, SESSION_RELOAD_INTERVAL);  socket.on("disconnect", () => {    clearInterval(timer);  });});
```

```js
const cors = require("cors");    const corsOptions = {  origin: ["http://localhost:4200"],  credentials: true};// for Expressapp.use(cors(corsOptions));// for Socket.IOconst io = new Server(httpServer, {  cors: corsOptions});
```

```js
import cors from "cors";    const corsOptions = {  origin: ["http://localhost:4200"],  credentials: true};// for Expressapp.use(cors(corsOptions));// for Socket.IOconst io = new Server(httpServer, {  cors: corsOptions});
```

```js
import cors = require("cors");    const corsOptions = {  origin: ["http://localhost:4200"],  credentials: true};// for Expressapp.use(cors(corsOptions));// for Socket.IOconst io = new Server(httpServer, {  cors: corsOptions});
```

```js
import { io } from "socket.io-client";const socket = io("http://localhost:3000", {  withCredentials: true});
```

```js
express-session
```

```js
const express = require("express");const { createServer } = require("node:http");const { join } = require("node:path");const { Server } = require("socket.io");const session = require("express-session");const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { createServer } from "node:http";import { Server } from "socket.io";import session from "express-session";const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.get("/", (req, res) => {  res.sendFile(new URL("./index.html", import.meta.url).pathname);});app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express = require("express");import { createServer } from "node:http";import { Server } from "socket.io";import session from "express-session";declare module "express-session" {  interface SessionData {    count: number;  }}const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.get("/", (req, res) => {  res.sendFile(new URL("./index.html", import.meta.url).pathname);});app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
npm install @types/express @types/express-session
```

```js
io.engine.use(sessionMiddleware);
```

```js
session
```

```js
io.on("connection", (socket) => {  const session = socket.request.session;});
```

```js
io.on("connection", (socket) => {  const sessionId = socket.request.session.id;  // the session ID is used as a room  socket.join(sessionId);});
```

```js
/incr
```

```js
app.post("/incr", (req, res) => {  const session = req.session;  session.count = (session.count || 0) + 1;  res.status(200).end("" + session.count);  io.to(session.id).emit("current count", session.count);});
```

```js
app.post("/logout", (req, res) => {  const sessionId = req.session.id;  req.session.destroy(() => {    // disconnect all Socket.IO connections linked to this session ID    io.in(sessionId).disconnectSockets();    res.status(204).end();  });});
```

```js
io.on("connection", (socket) => {  const req = socket.request;  socket.on("my event", () => {    req.session.reload((err) => {      if (err) {        return socket.disconnect();      }      req.session.count++;      req.session.save();    });  });});
```

```js
io.on("connection", (socket) => {  const req = socket.request;  socket.on("my event", () => {    req.session.reload((err) => {      if (err) {        return socket.disconnect();      }      req.session.count++;      req.session.save();    });  });});
```

```js
import { type Request } from "express";io.on("connection", (socket) => {  const req = socket.request as Request;  socket.on("my event", () => {    req.session.reload((err) => {      if (err) {        return socket.disconnect();      }      req.session.count++;      req.session.save();    });  });});
```

```js
io.on("connection", (socket) => {  const req = socket.request;  socket.use((__, next) => {    req.session.reload((err) => {      if (err) {        socket.disconnect();      } else {        next();      }    });  });  // and then simply  socket.on("my event", () => {    req.session.count++;    req.session.save();  });});
```

```js
req.session.reload()
```

```js
req.session
```

```js
io.on("connection", (socket) => {  const session = socket.request.session;  socket.use((__, next) => {    session.reload(() => {      // WARNING! "session" still points towards the previous session object    });  });});
```

```js
const SESSION_RELOAD_INTERVAL = 30 * 1000;io.on("connection", (socket) => {  const timer = setInterval(() => {    socket.request.session.reload((err) => {      if (err) {        // forces the client to reconnect        socket.conn.close();        // you can also use socket.disconnect(), but in that case the client        // will not try to reconnect      }    });  }, SESSION_RELOAD_INTERVAL);  socket.on("disconnect", () => {    clearInterval(timer);  });});
```

```js
express-session
```

```js
const cors = require("cors");    const corsOptions = {  origin: ["http://localhost:4200"],  credentials: true};// for Expressapp.use(cors(corsOptions));// for Socket.IOconst io = new Server(httpServer, {  cors: corsOptions});
```

```js
import cors from "cors";    const corsOptions = {  origin: ["http://localhost:4200"],  credentials: true};// for Expressapp.use(cors(corsOptions));// for Socket.IOconst io = new Server(httpServer, {  cors: corsOptions});
```

```js
import cors = require("cors");    const corsOptions = {  origin: ["http://localhost:4200"],  credentials: true};// for Expressapp.use(cors(corsOptions));// for Socket.IOconst io = new Server(httpServer, {  cors: corsOptions});
```

```js
withCredentials
```

```js
true
```

```js
import { io } from "socket.io-client";const socket = io("http://localhost:3000", {  withCredentials: true});
```

```js
express-session
```

# https://socket.io/how-to/use-with-jwt

# How to use with JSON Web Tokens

## Sharing the user context​

## Manual parsing​

## Using the user ID​

JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed.

It is often used for authentication, because of its small overhead and its ability to be easily used across different domains.

More information here.

Let's start from a basic application:

You'll need those additional types:

In this example, we manually create the token in the /login handler, but it might come from somewhere else in your own application.

On the client side, the token is included in the Authorization header:

This only works if HTTP long-polling is enabled and used first, as the browsers do not provide a way to provide additional headers for WebSocket connections:

The user context can be shared with the Socket.IO server by calling:

The isHandshake check ensures that the middleware is only applied to the first HTTP request of the session.

You'll now have access to the user object:

In the example above, we use the passport-jwt package, but you can totally verify the bearer token manually with the jsonwebtoken package:

You can use the user ID to make the link between Express and Socket.IO:

Which allows you to easily broadcast an event to all the connections of a given user:

You can also check whether a user is currently connected:

That's it for the compatibility with JSON Web Tokens. Thanks for reading!

The complete example can be found here.

You can run this example directly in your browser on:

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
- Sharing the user context
- Manual parsing
- Using the user ID
```js
const express = require("express");const { createServer } = require("node:http");const { join } = require("node:path");const passport = require("passport");const passportJwt = require("passport-jwt");const JwtStrategy = passportJwt.Strategy;const ExtractJwt = passportJwt.ExtractJwt;const bodyParser = require("body-parser");const { Server } = require("socket.io");const jwt = require("jsonwebtoken");const port = process.env.PORT || 3000;const jwtSecret = "Mys3cr3t";const app = express();const httpServer = createServer(app);app.use(bodyParser.json());app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.get(  "/self",  passport.authenticate("jwt", { session: false }),  (req, res) => {    if (req.user) {      res.send(req.user);    } else {      res.status(401).end();    }  },);app.post("/login", (req, res) => {  if (req.body.username === "john" && req.body.password === "changeit") {    console.log("authentication OK");    const user = {      id: 1,      username: "john",    };    const token = jwt.sign(      {        data: user,      },      jwtSecret,      {        issuer: "accounts.examplesoft.com",        audience: "yoursite.net",        expiresIn: "1h",      },    );    res.json({ token });  } else {    console.log("wrong credentials");    res.status(401).end();  }});const jwtDecodeOptions = {  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  secretOrKey: jwtSecret,  issuer: "accounts.examplesoft.com",  audience: "yoursite.net",};passport.use(  new JwtStrategy(jwtDecodeOptions, (payload, done) => {    return done(null, payload.data);  }),);const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { createServer } from "node:http";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";import passport from "passport";import { Strategy as JwtStrategy, ExtractJwt } from "passport-jwt";import bodyParser from "body-parser";import { Server } from "socket.io";import jwt from "jsonwebtoken";const port = process.env.PORT || 3000;const jwtSecret = "Mys3cr3t";const app = express();const httpServer = createServer(app);app.use(bodyParser.json());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.get(  "/self",  passport.authenticate("jwt", { session: false }),  (req, res) => {    if (req.user) {      res.send(req.user);    } else {      res.status(401).end();    }  },);app.post("/login", (req, res) => {  if (req.body.username === "john" && req.body.password === "changeit") {    console.log("authentication OK");    const user = {      id: 1,      username: "john",    };    const token = jwt.sign(      {        data: user,      },      jwtSecret,      {        issuer: "accounts.examplesoft.com",        audience: "yoursite.net",        expiresIn: "1h",      },    );    res.json({ token });  } else {    console.log("wrong credentials");    res.status(401).end();  }});const jwtDecodeOptions = {  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  secretOrKey: jwtSecret,  issuer: "accounts.examplesoft.com",  audience: "yoursite.net",};passport.use(  new JwtStrategy(jwtDecodeOptions, (payload, done) => {    return done(null, payload.data);  }),);const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { type Request, type Response } from "express";import { createServer } from "node:http";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";import passport from "passport";import { Strategy as JwtStrategy, ExtractJwt } from "passport-jwt";import bodyParser from "body-parser";import { Server } from "socket.io";import jwt from "jsonwebtoken";declare global {  namespace Express {    interface User {      id: number;      username: string;    }  }}const port = process.env.PORT || 3000;const jwtSecret = "Mys3cr3t";const app = express();const httpServer = createServer(app);app.use(bodyParser.json());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.get(  "/self",  passport.authenticate("jwt", { session: false }),  (req, res) => {    if (req.user) {      res.send(req.user);    } else {      res.status(401).end();    }  },);app.post("/login", (req, res) => {  if (req.body.username === "john" && req.body.password === "changeit") {    console.log("authentication OK");    const user = {      id: 1,      username: "john",    };    const token = jwt.sign(      {        data: user,      },      jwtSecret,      {        issuer: "accounts.examplesoft.com",        audience: "yoursite.net",        expiresIn: "1h",      },    );    res.json({ token });  } else {    console.log("wrong credentials");    res.status(401).end();  }});const jwtDecodeOptions = {  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  secretOrKey: jwtSecret,  issuer: "accounts.examplesoft.com",  audience: "yoursite.net",};passport.use(  new JwtStrategy(jwtDecodeOptions, (payload, done) => {    return done(null, payload.data);  }),);const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
npm install @types/express @types/jsonwebtoken @types/passport @types/passport-jwt
```

```js
const socket = io({  extraHeaders: {    authorization: `bearer ${myToken}`  }});
```

```js
// THIS WON'T WORKconst socket = io({  transports: ["websocket"],  extraHeaders: {    authorization: `bearer ${myToken}`  }});
```

```js
io.engine.use((req, res, next) => {  const isHandshake = req._query.sid === undefined;  if (isHandshake) {    passport.authenticate("jwt", { session: false })(req, res, next);  } else {    next();  }});
```

```js
io.on("connection", (socket) => {  const user = socket.request.user;});
```

```js
io.engine.use((req, res, next) => {  const isHandshake = req._query.sid === undefined;  if (!isHandshake) {    return next();  }  const header = req.headers["authorization"];  if (!header) {    return next(new Error("no token"));  }  if (!header.startsWith("bearer ")) {    return next(new Error("invalid token"));  }  const token = header.substring(7);  jwt.verify(token, jwtSecret, (err, decoded) => {    if (err) {      return next(new Error("invalid token"));    }    req.user = decoded.data;    next();  });});
```

```js
io.on("connection", (socket) => {  const userId = socket.request.user.id;  // the user ID is used as a room  socket.join(`user:${userId}`);});
```

```js
io.to(`user:${userId}`).emit("foo", "bar");
```

```js
const sockets = await io.in(`user:${userId}`).fetchSockets();const isUserConnected = sockets.length > 0;
```

```js
const express = require("express");const { createServer } = require("node:http");const { join } = require("node:path");const passport = require("passport");const passportJwt = require("passport-jwt");const JwtStrategy = passportJwt.Strategy;const ExtractJwt = passportJwt.ExtractJwt;const bodyParser = require("body-parser");const { Server } = require("socket.io");const jwt = require("jsonwebtoken");const port = process.env.PORT || 3000;const jwtSecret = "Mys3cr3t";const app = express();const httpServer = createServer(app);app.use(bodyParser.json());app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.get(  "/self",  passport.authenticate("jwt", { session: false }),  (req, res) => {    if (req.user) {      res.send(req.user);    } else {      res.status(401).end();    }  },);app.post("/login", (req, res) => {  if (req.body.username === "john" && req.body.password === "changeit") {    console.log("authentication OK");    const user = {      id: 1,      username: "john",    };    const token = jwt.sign(      {        data: user,      },      jwtSecret,      {        issuer: "accounts.examplesoft.com",        audience: "yoursite.net",        expiresIn: "1h",      },    );    res.json({ token });  } else {    console.log("wrong credentials");    res.status(401).end();  }});const jwtDecodeOptions = {  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  secretOrKey: jwtSecret,  issuer: "accounts.examplesoft.com",  audience: "yoursite.net",};passport.use(  new JwtStrategy(jwtDecodeOptions, (payload, done) => {    return done(null, payload.data);  }),);const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { createServer } from "node:http";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";import passport from "passport";import { Strategy as JwtStrategy, ExtractJwt } from "passport-jwt";import bodyParser from "body-parser";import { Server } from "socket.io";import jwt from "jsonwebtoken";const port = process.env.PORT || 3000;const jwtSecret = "Mys3cr3t";const app = express();const httpServer = createServer(app);app.use(bodyParser.json());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.get(  "/self",  passport.authenticate("jwt", { session: false }),  (req, res) => {    if (req.user) {      res.send(req.user);    } else {      res.status(401).end();    }  },);app.post("/login", (req, res) => {  if (req.body.username === "john" && req.body.password === "changeit") {    console.log("authentication OK");    const user = {      id: 1,      username: "john",    };    const token = jwt.sign(      {        data: user,      },      jwtSecret,      {        issuer: "accounts.examplesoft.com",        audience: "yoursite.net",        expiresIn: "1h",      },    );    res.json({ token });  } else {    console.log("wrong credentials");    res.status(401).end();  }});const jwtDecodeOptions = {  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  secretOrKey: jwtSecret,  issuer: "accounts.examplesoft.com",  audience: "yoursite.net",};passport.use(  new JwtStrategy(jwtDecodeOptions, (payload, done) => {    return done(null, payload.data);  }),);const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { type Request, type Response } from "express";import { createServer } from "node:http";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";import passport from "passport";import { Strategy as JwtStrategy, ExtractJwt } from "passport-jwt";import bodyParser from "body-parser";import { Server } from "socket.io";import jwt from "jsonwebtoken";declare global {  namespace Express {    interface User {      id: number;      username: string;    }  }}const port = process.env.PORT || 3000;const jwtSecret = "Mys3cr3t";const app = express();const httpServer = createServer(app);app.use(bodyParser.json());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  res.sendFile(join(__dirname, "index.html"));});app.get(  "/self",  passport.authenticate("jwt", { session: false }),  (req, res) => {    if (req.user) {      res.send(req.user);    } else {      res.status(401).end();    }  },);app.post("/login", (req, res) => {  if (req.body.username === "john" && req.body.password === "changeit") {    console.log("authentication OK");    const user = {      id: 1,      username: "john",    };    const token = jwt.sign(      {        data: user,      },      jwtSecret,      {        issuer: "accounts.examplesoft.com",        audience: "yoursite.net",        expiresIn: "1h",      },    );    res.json({ token });  } else {    console.log("wrong credentials");    res.status(401).end();  }});const jwtDecodeOptions = {  jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),  secretOrKey: jwtSecret,  issuer: "accounts.examplesoft.com",  audience: "yoursite.net",};passport.use(  new JwtStrategy(jwtDecodeOptions, (payload, done) => {    return done(null, payload.data);  }),);const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
npm install @types/express @types/jsonwebtoken @types/passport @types/passport-jwt
```

```js
/login
```

```js
Authorization
```

```js
const socket = io({  extraHeaders: {    authorization: `bearer ${myToken}`  }});
```

```js
// THIS WON'T WORKconst socket = io({  transports: ["websocket"],  extraHeaders: {    authorization: `bearer ${myToken}`  }});
```

```js
io.engine.use((req, res, next) => {  const isHandshake = req._query.sid === undefined;  if (isHandshake) {    passport.authenticate("jwt", { session: false })(req, res, next);  } else {    next();  }});
```

```js
isHandshake
```

```js
user
```

```js
io.on("connection", (socket) => {  const user = socket.request.user;});
```

```js
passport-jwt
```

```js
jsonwebtoken
```

```js
io.engine.use((req, res, next) => {  const isHandshake = req._query.sid === undefined;  if (!isHandshake) {    return next();  }  const header = req.headers["authorization"];  if (!header) {    return next(new Error("no token"));  }  if (!header.startsWith("bearer ")) {    return next(new Error("invalid token"));  }  const token = header.substring(7);  jwt.verify(token, jwtSecret, (err, decoded) => {    if (err) {      return next(new Error("invalid token"));    }    req.user = decoded.data;    next();  });});
```

```js
io.on("connection", (socket) => {  const userId = socket.request.user.id;  // the user ID is used as a room  socket.join(`user:${userId}`);});
```

```js
io.to(`user:${userId}`).emit("foo", "bar");
```

```js
const sockets = await io.in(`user:${userId}`).fetchSockets();const isUserConnected = sockets.length > 0;
```

# https://socket.io/how-to/use-with-nextjs

# How to use with Next.js

## Server​

## Client​

This guide shows how to use Socket.IO within a Next.js application.

You won't be able to deploy your application on Vercel, as it does not support WebSocket connections.

Reference: https://vercel.com/guides/do-vercel-serverless-functions-support-websocket-connections

The Socket.IO server can share the same underlying HTTP server with Next.js. You just have to create a server.js file at the root of your project:

The server.js file becomes the entrypoint of your application:

And voilà!

Reference: https://nextjs.org/docs/pages/building-your-application/configuring/custom-server

This works with both the App router and the Pages router.

From the Next.js documentation:

On the client side, all tips from our React guide are valid.

The only difference is that you need to exclude the Socket.IO client from server-side rendering (SSR):

Structure:

"use client" indicates that the file is part of the client bundle, and won't be server-rendered.

Reference: https://nextjs.org/docs/app/building-your-application/rendering/client-components

Structure:

The isBrowser check is important, as it prevents Next.js from trying to create a Socket.IO client when doing server-side rendering.

Reference: https://nextjs.org/docs/pages/building-your-application/rendering/client-side-rendering

We could have used:

instead of:

but this triggers some warnings from the Next.js compiler, as the client-rendered page may not match the server-rendered output.

Uncaught Error: Text content does not match server-rendered HTML.

In the example above, the transport variable is the low-level transport used to establish the Socket.IO connection, which can be either:

If everything went well, you should see:

You can then exchange messages between the Socket.IO server and client with:

That's all folks, thanks for reading!

Back to the list of examples

- Before deciding to use a custom server, please keep in mind that it should only be used when the integrated router of Next.js can't meet your app requirements. A custom server will remove important performance optimizations, like serverless functions and Automatic Static Optimization.
- A custom server cannot be deployed on Vercel.
- Standalone output mode, does not trace custom server files and this mode outputs a separate minimal server.js file instead.
- App router
- Pages router
- HTTP long-polling ("polling")
- WebSocket ("websocket")
- WebTransport ("webtransport")
- socket.emit() to send messages
- socket.on() to receive messages
- Server
- Client
```js
import { createServer } from "node:http";import next from "next";import { Server } from "socket.io";const dev = process.env.NODE_ENV !== "production";const hostname = "localhost";const port = 3000;// when using middleware `hostname` and `port` must be provided belowconst app = next({ dev, hostname, port });const handler = app.getRequestHandler();app.prepare().then(() => {  const httpServer = createServer(handler);  const io = new Server(httpServer);  io.on("connection", (socket) => {    // ...  });  httpServer    .once("error", (err) => {      console.error(err);      process.exit(1);    })    .listen(port, () => {      console.log(`> Ready on http://${hostname}:${port}`);    });});
```

```js
{  "scripts": {-   "dev": "next dev",+   "dev": "node server.js",    "build": "next build",-   "start": "next start",+   "start": "NODE_ENV=production node server.js",    "lint": "next lint"  }}
```

```js
├── src│ ├── app│ │ └── page.js│ └── socket.js└── package.json
```

```js
"use client";import { io } from "socket.io-client";export const socket = io();
```

```js
"use client";import { useEffect, useState } from "react";import { socket } from "../socket";export default function Home() {  const [isConnected, setIsConnected] = useState(false);  const [transport, setTransport] = useState("N/A");  useEffect(() => {    if (socket.connected) {      onConnect();    }    function onConnect() {      setIsConnected(true);      setTransport(socket.io.engine.transport.name);      socket.io.engine.on("upgrade", (transport) => {        setTransport(transport.name);      });    }    function onDisconnect() {      setIsConnected(false);      setTransport("N/A");    }    socket.on("connect", onConnect);    socket.on("disconnect", onDisconnect);    return () => {      socket.off("connect", onConnect);      socket.off("disconnect", onDisconnect);    };  }, []);  return (    <div>      <p>Status: { isConnected ? "connected" : "disconnected" }</p>      <p>Transport: { transport }</p>    </div>  );}
```

```js
├── src│ ├── pages│ │ └── index.js│ └── socket.js└── package.json
```

```js
import { io } from "socket.io-client";const isBrowser = typeof window !== "undefined";export const socket = isBrowser ? io() : {};
```

```js
import { useEffect, useState } from "react";import { socket } from "../socket";export default function Home() {  const [isConnected, setIsConnected] = useState(false);  const [transport, setTransport] = useState("N/A");  useEffect(() => {    if (socket.connected) {      onConnect();    }    function onConnect() {      setIsConnected(true);      setTransport(socket.io.engine.transport.name);      socket.io.engine.on("upgrade", (transport) => {        setTransport(transport.name);      });    }    function onDisconnect() {      setIsConnected(false);      setTransport("N/A");    }    socket.on("connect", onConnect);    socket.on("disconnect", onDisconnect);    return () => {      socket.off("connect", onConnect);      socket.off("disconnect", onDisconnect);    };  }, []);  return (    <div>      <p>Status: { isConnected ? "connected" : "disconnected" }</p>      <p>Transport: { transport }</p>    </div>  );}
```

```js
const [isConnected, setIsConnected] = useState(socket.connected);
```

```js
const [isConnected, setIsConnected] = useState(false);useEffect(() => {  if (socket.connected) {    onConnect();  }  // ...});
```

```js
Status: connectedTransport: websocket
```

```js
socket.emit("hello", "world");
```

```js
socket.on("hello", (value) => {  // ...});
```

```js
server.js
```

```js
import { createServer } from "node:http";import next from "next";import { Server } from "socket.io";const dev = process.env.NODE_ENV !== "production";const hostname = "localhost";const port = 3000;// when using middleware `hostname` and `port` must be provided belowconst app = next({ dev, hostname, port });const handler = app.getRequestHandler();app.prepare().then(() => {  const httpServer = createServer(handler);  const io = new Server(httpServer);  io.on("connection", (socket) => {    // ...  });  httpServer    .once("error", (err) => {      console.error(err);      process.exit(1);    })    .listen(port, () => {      console.log(`> Ready on http://${hostname}:${port}`);    });});
```

```js
server.js
```

```js
{  "scripts": {-   "dev": "next dev",+   "dev": "node server.js",    "build": "next build",-   "start": "next start",+   "start": "NODE_ENV=production node server.js",    "lint": "next lint"  }}
```

```js
├── src│ ├── app│ │ └── page.js│ └── socket.js└── package.json
```

```js
"use client";import { io } from "socket.io-client";export const socket = io();
```

```js
"use client"
```

```js
"use client";import { useEffect, useState } from "react";import { socket } from "../socket";export default function Home() {  const [isConnected, setIsConnected] = useState(false);  const [transport, setTransport] = useState("N/A");  useEffect(() => {    if (socket.connected) {      onConnect();    }    function onConnect() {      setIsConnected(true);      setTransport(socket.io.engine.transport.name);      socket.io.engine.on("upgrade", (transport) => {        setTransport(transport.name);      });    }    function onDisconnect() {      setIsConnected(false);      setTransport("N/A");    }    socket.on("connect", onConnect);    socket.on("disconnect", onDisconnect);    return () => {      socket.off("connect", onConnect);      socket.off("disconnect", onDisconnect);    };  }, []);  return (    <div>      <p>Status: { isConnected ? "connected" : "disconnected" }</p>      <p>Transport: { transport }</p>    </div>  );}
```

```js
├── src│ ├── pages│ │ └── index.js│ └── socket.js└── package.json
```

```js
import { io } from "socket.io-client";const isBrowser = typeof window !== "undefined";export const socket = isBrowser ? io() : {};
```

```js
isBrowser
```

```js
import { useEffect, useState } from "react";import { socket } from "../socket";export default function Home() {  const [isConnected, setIsConnected] = useState(false);  const [transport, setTransport] = useState("N/A");  useEffect(() => {    if (socket.connected) {      onConnect();    }    function onConnect() {      setIsConnected(true);      setTransport(socket.io.engine.transport.name);      socket.io.engine.on("upgrade", (transport) => {        setTransport(transport.name);      });    }    function onDisconnect() {      setIsConnected(false);      setTransport("N/A");    }    socket.on("connect", onConnect);    socket.on("disconnect", onDisconnect);    return () => {      socket.off("connect", onConnect);      socket.off("disconnect", onDisconnect);    };  }, []);  return (    <div>      <p>Status: { isConnected ? "connected" : "disconnected" }</p>      <p>Transport: { transport }</p>    </div>  );}
```

```js
const [isConnected, setIsConnected] = useState(socket.connected);
```

```js
const [isConnected, setIsConnected] = useState(false);useEffect(() => {  if (socket.connected) {    onConnect();  }  // ...});
```

```js
transport
```

```js
"polling"
```

```js
"websocket"
```

```js
"webtransport"
```

```js
Status: connectedTransport: websocket
```

```js
socket.emit()
```

```js
socket.emit("hello", "world");
```

```js
socket.on()
```

```js
socket.on("hello", (value) => {  // ...});
```

# https://socket.io/how-to/use-with-nuxt

# How to use with Nuxt

## Server​

## Client​

### Enable WebSockets​

### Hook the Socket.IO server​

This guide shows how to use Socket.IO within a Nuxt application.

Under the hood, Nuxt uses Nitro to handle the HTTP requests.

There are two steps to attach a Socket.IO server to a Nitro server:

WebSockets support in Nitro is currently experimental, so it needs to be manually enabled:

Reference: https://nitro.unjs.io/guide/websocket

Our Socket.IO server is created in a Nitro plugin:

And voilà!

On the client side, all tips from our Vue 3 guide are valid.

The only difference is that you need to exclude the Socket.IO client from server-side rendering (SSR):

Structure:

The .client suffix in Connection.client.vue indicates that the component is meant to be rendered only client-side (no SSR).

Reference: https://nuxt.com/docs/guide/directory-structure/components#client-components

In the example above, the transport variable is the low-level transport used to establish the Socket.IO connection, which can be either:

If everything went well, you should see:

You can then exchange messages between the Socket.IO server and client with:

That's all folks, thanks for reading!

Back to the list of examples

- HTTP long-polling ("polling")
- WebSocket ("websocket")
- WebTransport ("webtransport")
- socket.emit() to send messages
- socket.on() to receive messages
- ServerEnable WebSocketsHook the Socket.IO server
- Enable WebSockets
- Hook the Socket.IO server
- Client
```js
// https://nuxt.com/docs/api/configuration/nuxt-configexport default defineNuxtConfig({  devtools: {    enabled: true  },+ nitro: {+   experimental: {+     websocket: true+   },+ }})
```

```js
import type { NitroApp } from "nitropack";import { Server as Engine } from "engine.io";import { Server } from "socket.io";import { defineEventHandler } from "h3";export default defineNitroPlugin((nitroApp: NitroApp) => {  const engine = new Engine();  const io = new Server();  io.bind(engine);  io.on("connection", (socket) => {    // ...  });  nitroApp.router.use("/socket.io/", defineEventHandler({    handler(event) {      engine.handleRequest(event.node.req, event.node.res);      event._handled = true;    },    websocket: {      open(peer) {        // @ts-expect-error private method and property        engine.prepare(peer._internal.nodeReq);        // @ts-expect-error private method and property        engine.onWebSocket(peer._internal.nodeReq, peer._internal.nodeReq.socket, peer.websocket);      }    }  }));});
```

```js
├── components│ ├── Connection.client.vue│ └── socket.ts...
```

```js
import { io } from "socket.io-client";export const socket = io();
```

```js
<script setup>import { socket } from "./socket";const isConnected = ref(false);const transport = ref("N/A");if (socket.connected) {  onConnect();}function onConnect() {  isConnected.value = true;  transport.value = socket.io.engine.transport.name;  socket.io.engine.on("upgrade", (rawTransport) => {    transport.value = rawTransport.name;  });}function onDisconnect() {  isConnected.value = false;  transport.value = "N/A";}socket.on("connect", onConnect);socket.on("disconnect", onDisconnect);onBeforeUnmount(() => {  socket.off("connect", onConnect);  socket.off("disconnect", onDisconnect);});</script><template><div>  <p>Status: {{ isConnected ? "connected" : "disconnected" }}</p>  <p>Transport: {{ transport }}</p></div></template>
```

```js
Status: connectedTransport: websocket
```

```js
socket.emit("hello", "world");
```

```js
socket.on("hello", (value) => {  // ...});
```

```js
// https://nuxt.com/docs/api/configuration/nuxt-configexport default defineNuxtConfig({  devtools: {    enabled: true  },+ nitro: {+   experimental: {+     websocket: true+   },+ }})
```

```js
import type { NitroApp } from "nitropack";import { Server as Engine } from "engine.io";import { Server } from "socket.io";import { defineEventHandler } from "h3";export default defineNitroPlugin((nitroApp: NitroApp) => {  const engine = new Engine();  const io = new Server();  io.bind(engine);  io.on("connection", (socket) => {    // ...  });  nitroApp.router.use("/socket.io/", defineEventHandler({    handler(event) {      engine.handleRequest(event.node.req, event.node.res);      event._handled = true;    },    websocket: {      open(peer) {        // @ts-expect-error private method and property        engine.prepare(peer._internal.nodeReq);        // @ts-expect-error private method and property        engine.onWebSocket(peer._internal.nodeReq, peer._internal.nodeReq.socket, peer.websocket);      }    }  }));});
```

```js
├── components│ ├── Connection.client.vue│ └── socket.ts...
```

```js
import { io } from "socket.io-client";export const socket = io();
```

```js
<script setup>import { socket } from "./socket";const isConnected = ref(false);const transport = ref("N/A");if (socket.connected) {  onConnect();}function onConnect() {  isConnected.value = true;  transport.value = socket.io.engine.transport.name;  socket.io.engine.on("upgrade", (rawTransport) => {    transport.value = rawTransport.name;  });}function onDisconnect() {  isConnected.value = false;  transport.value = "N/A";}socket.on("connect", onConnect);socket.on("disconnect", onDisconnect);onBeforeUnmount(() => {  socket.off("connect", onConnect);  socket.off("disconnect", onDisconnect);});</script><template><div>  <p>Status: {{ isConnected ? "connected" : "disconnected" }}</p>  <p>Transport: {{ transport }}</p></div></template>
```

```js
.client
```

```js
Connection.client.vue
```

```js
transport
```

```js
"polling"
```

```js
"websocket"
```

```js
"webtransport"
```

```js
Status: connectedTransport: websocket
```

```js
socket.emit()
```

```js
socket.emit("hello", "world");
```

```js
socket.on()
```

```js
socket.on("hello", (value) => {  // ...});
```

# https://socket.io/how-to/use-with-nwjs

# How to use with NW.js

## Usage​

## Sample project​

### Browser context​

### Node context​

This guide shows how to use Socket.IO within a NW.js (previously known as node-webkit) application.

By default, NW.js creates two different JavaScript contexts:

Reference: https://nwjs.readthedocs.io/en/latest/For%20Users/Advanced/JavaScript%20Contexts%20in%20NW.js/

The Socket.IO client can be created in both context, depending on your use case.

In that case, the Socket.IO client will use the WebSocket object provided by the browser.

In that case, the Socket.IO client will use the WebSocket object provided by the ws package.

the Socket.IO connection will be shared between the different windows of your application

the client supports additional options specific to Node.js such as agent, ca or cert

https://github.com/socketio/socket.io/tree/main/examples/nwjs-example

That's all folks, thanks for reading!

Back to the list of examples

- the Socket.IO connection can be debugged in the DevTools:
- the extraHeaders option will be ignored when using WebSocket only:
- the Socket.IO connection will be shared between the different windows of your application
- the client supports additional options specific to Node.js such as agent, ca or cert
- the extraHeaders option will properly be sent when using WebSocket only:
- the Socket.IO connection cannot be debugged in the DevTools (even when choosing "Inspect Background Page")
- UsageBrowser contextProsConsNode contextProsCons
- Browser contextProsCons
- Pros
- Cons
- Node contextProsCons
- Pros
- Cons
- Sample project
```js
<!doctype html><html lang="en">  <body>    <p>Status: <span id="status"></span></p>    <p>Transport: <span id="transport"></span></p>    <!-- from the socket.io-client package -->    <script src="./node_modules/socket.io-client/dist/socket.io.min.js"></script>    <!-- or from a CDN -->    <!--<script src="https://cdn.socket.io/4.7.5/socket.io.js"></script>-->    <script>      const socket = io("http://localhost:3000");      const statusSpan = document.getElementById("status");      const transportSpan = document.getElementById("transport");      statusSpan.innerText = "Disconnected";      transportSpan.innerText = "N/A";      socket.on("connect", () => {        statusSpan.innerText = "Connected";        transportSpan.innerText = socket.io.engine.transport.name;        socket.io.engine.on("upgrade", (transport) => {          transportSpan.innerText = transport.name;        });        console.log(`connect ${socket.id}`);      });      socket.on("connect_error", (err) => {        console.log(`connect_error due to ${err.message}`);      });      socket.on("disconnect", (reason) => {        statusSpan.innerText = "Disconnected";        transportSpan.innerText = "N/A";        console.log(`disconnect due to ${reason}`);      });      socket.emit("hello", "world");    </script>  </body></html>
```

```js
const socket = io("http://localhost:3000", {  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234" // ignored  }});
```

```js
<!doctype html><html lang="en">  <body>    <p>Status: <span id="status"></span></p>    <p>Transport: <span id="transport"></span></p>    <script>      const statusSpan = document.getElementById("status");      const transportSpan = document.getElementById("transport");      const { registerListeners, emit } = require("./socket");      registerListeners({ statusSpan, transportSpan });      emit("hello", "world");    </script>  </body></html>
```

```js
const { io } = require("socket.io-client");const socket = io("http://localhost:3000");exports.registerListeners = function ({ statusSpan, transportSpan }) {  statusSpan.innerText = "Disconnected";  transportSpan.innerText = "N/A";  function onConnect() {    statusSpan.innerText = "Connected";    transportSpan.innerText = socket.io.engine.transport.name;    socket.io.engine.on("upgrade", (transport) => {      transportSpan.innerText = transport.name;    });    console.log(`connect ${socket.id}`);  }  if (socket.connected) {    onConnect();  }  socket.on("connect", onConnect);  socket.on("connect_error", (err) => {    console.log(`connect_error due to ${err.message}`);  });  socket.on("disconnect", (reason) => {    statusSpan.innerText = "Disconnected";    transportSpan.innerText = "N/A";    console.log(`disconnect due to ${reason}`);  });}exports.emit = function (...args) {  socket.emit(...args);}
```

```js
const socket = io("https://localhost:3000", {  ca: fs.readFileSync("cert.pem")});
```

```js
const socket = io("http://localhost:3000", {  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234"  }});
```

```js
<!doctype html><html lang="en">  <body>    <p>Status: <span id="status"></span></p>    <p>Transport: <span id="transport"></span></p>    <!-- from the socket.io-client package -->    <script src="./node_modules/socket.io-client/dist/socket.io.min.js"></script>    <!-- or from a CDN -->    <!--<script src="https://cdn.socket.io/4.7.5/socket.io.js"></script>-->    <script>      const socket = io("http://localhost:3000");      const statusSpan = document.getElementById("status");      const transportSpan = document.getElementById("transport");      statusSpan.innerText = "Disconnected";      transportSpan.innerText = "N/A";      socket.on("connect", () => {        statusSpan.innerText = "Connected";        transportSpan.innerText = socket.io.engine.transport.name;        socket.io.engine.on("upgrade", (transport) => {          transportSpan.innerText = transport.name;        });        console.log(`connect ${socket.id}`);      });      socket.on("connect_error", (err) => {        console.log(`connect_error due to ${err.message}`);      });      socket.on("disconnect", (reason) => {        statusSpan.innerText = "Disconnected";        transportSpan.innerText = "N/A";        console.log(`disconnect due to ${reason}`);      });      socket.emit("hello", "world");    </script>  </body></html>
```

```js
extraHeaders
```

```js
const socket = io("http://localhost:3000", {  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234" // ignored  }});
```

```js
<!doctype html><html lang="en">  <body>    <p>Status: <span id="status"></span></p>    <p>Transport: <span id="transport"></span></p>    <script>      const statusSpan = document.getElementById("status");      const transportSpan = document.getElementById("transport");      const { registerListeners, emit } = require("./socket");      registerListeners({ statusSpan, transportSpan });      emit("hello", "world");    </script>  </body></html>
```

```js
const { io } = require("socket.io-client");const socket = io("http://localhost:3000");exports.registerListeners = function ({ statusSpan, transportSpan }) {  statusSpan.innerText = "Disconnected";  transportSpan.innerText = "N/A";  function onConnect() {    statusSpan.innerText = "Connected";    transportSpan.innerText = socket.io.engine.transport.name;    socket.io.engine.on("upgrade", (transport) => {      transportSpan.innerText = transport.name;    });    console.log(`connect ${socket.id}`);  }  if (socket.connected) {    onConnect();  }  socket.on("connect", onConnect);  socket.on("connect_error", (err) => {    console.log(`connect_error due to ${err.message}`);  });  socket.on("disconnect", (reason) => {    statusSpan.innerText = "Disconnected";    transportSpan.innerText = "N/A";    console.log(`disconnect due to ${reason}`);  });}exports.emit = function (...args) {  socket.emit(...args);}
```

```js
agent
```

```js
cert
```

```js
const socket = io("https://localhost:3000", {  ca: fs.readFileSync("cert.pem")});
```

```js
extraHeaders
```

```js
const socket = io("http://localhost:3000", {  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234"  }});
```

# https://socket.io/how-to/use-with-passport

# How to use with Passport.js

## Sharing the user context​

## Using the user ID​

Let's start from a basic application:

You'll need those additional types:

The user context can be shared with the Socket.IO server by calling:

Here's what happens:

The onlyForHandshake() method ensures that the middlewares are only applied to the first HTTP request of the session.

You'll now have access to the user object:

You can use the user ID to make the link between Express and Socket.IO:

Which allows you to easily broadcast an event to all the connections of a given user:

You can also check whether a user is currently connected:

That's it for the compatibility with Passport.js. Thanks for reading!

The complete example can be found here.

You can run this example directly in your browser on:

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- CommonJS
- ES modules
- TypeScript
- the express-session middleware retrieves the session context from the cookie
- the passport middleware extracts the user context from the session
- and finally, the handshake is validated if the user context was found
- CommonJS
- ES modules
- TypeScript
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
- Sharing the user context
- Using the user ID
```js
const express = require("express");const { createServer } = require("node:http");const { Server } = require("socket.io");const session = require("express-session");const bodyParser = require("body-parser");const passport = require("passport");const LocalStrategy = require("passport-local").Strategy;const { join } = require("node:path");const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.use(bodyParser.urlencoded({ extended: false }));app.use(passport.session());app.get("/", (req, res) => {  if (!req.user) {    return res.redirect("/login");  }  res.sendFile(join(__dirname, "index.html"));});app.get("/login", (req, res) => {  if (req.user) {    return res.redirect("/");  }  res.sendFile(join(__dirname, "login.html"));});app.post(  "/login",  passport.authenticate("local", {    successRedirect: "/",    failureRedirect: "/",  }),);passport.use(  new LocalStrategy((username, password, done) => {    if (username === "john" && password === "changeit") {      console.log("authentication OK");      return done(null, { id: 1, username });    } else {      console.log("wrong credentials");      return done(null, false);    }  }),);passport.serializeUser((user, cb) => {  console.log(`serializeUser ${user.id}`);  cb(null, user);});passport.deserializeUser((user, cb) => {  console.log(`deserializeUser ${user.id}`);  cb(null, user);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { createServer } from "http";import { Server } from "socket.io";import session from "express-session";import bodyParser from "body-parser";import passport from "passport";import { Strategy as LocalStrategy } from "passport-local";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.use(bodyParser.urlencoded({ extended: false }));app.use(passport.session());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  if (!req.user) {    return res.redirect("/login");  }  res.sendFile(join(__dirname, "index.html"));});app.get("/login", (req, res) => {  if (req.user) {    return res.redirect("/");  }  res.sendFile(join(__dirname, "login.html"));});app.post(  "/login",  passport.authenticate("local", {    successRedirect: "/",    failureRedirect: "/",  }),);app.post("/logout", (req, res) => {  const sessionId = req.session.id;  req.session.destroy(() => {    // disconnect all Socket.IO connections linked to this session ID    io.to(`session:${sessionId}`).disconnectSockets();    res.status(204).end();  });});passport.use(  new LocalStrategy((username, password, done) => {    if (username === "john" && password === "changeit") {      console.log("authentication OK");      return done(null, { id: 1, username });    } else {      console.log("wrong credentials");      return done(null, false);    }  }),);passport.serializeUser((user, cb) => {  console.log(`serializeUser ${user.id}`);  cb(null, user);});passport.deserializeUser((user, cb) => {  console.log(`deserializeUser ${user.id}`);  cb(null, user);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express = require("express");import { createServer } from "http";import { Server } from "socket.io";import session from "express-session";import { type Request, type Response } from "express";import bodyParser = require("body-parser");import passport = require("passport");import { Strategy as LocalStrategy } from "passport-local";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";declare global {  namespace Express {    interface User {      id: number;      username: string;    }  }}const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.use(bodyParser.urlencoded({ extended: false }));app.use(passport.initialize());app.use(passport.session());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  if (!req.user) {    return res.redirect("/login");  }  res.sendFile(join(__dirname, "index.html"));});app.get("/login", (req, res) => {  if (req.user) {    return res.redirect("/");  }  res.sendFile(join(__dirname, "login.html"));});app.post(  "/login",  passport.authenticate("local", {    successRedirect: "/",    failureRedirect: "/",  }),);app.post("/logout", (req, res) => {  const sessionId = req.session.id;  req.session.destroy(() => {    // disconnect all Socket.IO connections linked to this session ID    io.to(`session:${sessionId}`).disconnectSockets();    res.status(204).end();  });});passport.use(  new LocalStrategy((username, password, done) => {    if (username === "john" && password === "changeit") {      console.log("authentication OK");      return done(null, { id: 1, username });    } else {      console.log("wrong credentials");      return done(null, false);    }  }),);passport.serializeUser((user, cb) => {  console.log(`serializeUser ${user.id}`);  cb(null, user);});passport.deserializeUser((user: Express.User, cb) => {  console.log(`deserializeUser ${user.id}`);  cb(null, user);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
npm install @types/express @types/express-session @types/passport @types/passport-local
```

```js
function onlyForHandshake(middleware) {  return (req, res, next) => {    const isHandshake = req._query.sid === undefined;    if (isHandshake) {      middleware(req, res, next);    } else {      next();    }  };}io.engine.use(onlyForHandshake(sessionMiddleware));io.engine.use(onlyForHandshake(passport.session()));io.engine.use(  onlyForHandshake((req, res, next) => {    if (req.user) {      next();    } else {      res.writeHead(401);      res.end();    }  }),);
```

```js
io.on("connection", (socket) => {  const user = socket.request.user;});
```

```js
io.on("connection", (socket) => {  const userId = socket.request.user.id;  // the user ID is used as a room  socket.join(`user:${userId}`);});
```

```js
io.to(`user:${userId}`).emit("foo", "bar");
```

```js
const sockets = await io.in(`user:${userId}`).fetchSockets();const isUserConnected = sockets.length > 0;
```

```js
const express = require("express");const { createServer } = require("node:http");const { Server } = require("socket.io");const session = require("express-session");const bodyParser = require("body-parser");const passport = require("passport");const LocalStrategy = require("passport-local").Strategy;const { join } = require("node:path");const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.use(bodyParser.urlencoded({ extended: false }));app.use(passport.session());app.get("/", (req, res) => {  if (!req.user) {    return res.redirect("/login");  }  res.sendFile(join(__dirname, "index.html"));});app.get("/login", (req, res) => {  if (req.user) {    return res.redirect("/");  }  res.sendFile(join(__dirname, "login.html"));});app.post(  "/login",  passport.authenticate("local", {    successRedirect: "/",    failureRedirect: "/",  }),);passport.use(  new LocalStrategy((username, password, done) => {    if (username === "john" && password === "changeit") {      console.log("authentication OK");      return done(null, { id: 1, username });    } else {      console.log("wrong credentials");      return done(null, false);    }  }),);passport.serializeUser((user, cb) => {  console.log(`serializeUser ${user.id}`);  cb(null, user);});passport.deserializeUser((user, cb) => {  console.log(`deserializeUser ${user.id}`);  cb(null, user);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express from "express";import { createServer } from "http";import { Server } from "socket.io";import session from "express-session";import bodyParser from "body-parser";import passport from "passport";import { Strategy as LocalStrategy } from "passport-local";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.use(bodyParser.urlencoded({ extended: false }));app.use(passport.session());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  if (!req.user) {    return res.redirect("/login");  }  res.sendFile(join(__dirname, "index.html"));});app.get("/login", (req, res) => {  if (req.user) {    return res.redirect("/");  }  res.sendFile(join(__dirname, "login.html"));});app.post(  "/login",  passport.authenticate("local", {    successRedirect: "/",    failureRedirect: "/",  }),);app.post("/logout", (req, res) => {  const sessionId = req.session.id;  req.session.destroy(() => {    // disconnect all Socket.IO connections linked to this session ID    io.to(`session:${sessionId}`).disconnectSockets();    res.status(204).end();  });});passport.use(  new LocalStrategy((username, password, done) => {    if (username === "john" && password === "changeit") {      console.log("authentication OK");      return done(null, { id: 1, username });    } else {      console.log("wrong credentials");      return done(null, false);    }  }),);passport.serializeUser((user, cb) => {  console.log(`serializeUser ${user.id}`);  cb(null, user);});passport.deserializeUser((user, cb) => {  console.log(`deserializeUser ${user.id}`);  cb(null, user);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
import express = require("express");import { createServer } from "http";import { Server } from "socket.io";import session from "express-session";import { type Request, type Response } from "express";import bodyParser = require("body-parser");import passport = require("passport");import { Strategy as LocalStrategy } from "passport-local";import { dirname, join } from "node:path";import { fileURLToPath } from "node:url";declare global {  namespace Express {    interface User {      id: number;      username: string;    }  }}const port = process.env.PORT || 3000;const app = express();const httpServer = createServer(app);const sessionMiddleware = session({  secret: "changeit",  resave: true,  saveUninitialized: true,});app.use(sessionMiddleware);app.use(bodyParser.urlencoded({ extended: false }));app.use(passport.initialize());app.use(passport.session());const __dirname = dirname(fileURLToPath(import.meta.url));app.get("/", (req, res) => {  if (!req.user) {    return res.redirect("/login");  }  res.sendFile(join(__dirname, "index.html"));});app.get("/login", (req, res) => {  if (req.user) {    return res.redirect("/");  }  res.sendFile(join(__dirname, "login.html"));});app.post(  "/login",  passport.authenticate("local", {    successRedirect: "/",    failureRedirect: "/",  }),);app.post("/logout", (req, res) => {  const sessionId = req.session.id;  req.session.destroy(() => {    // disconnect all Socket.IO connections linked to this session ID    io.to(`session:${sessionId}`).disconnectSockets();    res.status(204).end();  });});passport.use(  new LocalStrategy((username, password, done) => {    if (username === "john" && password === "changeit") {      console.log("authentication OK");      return done(null, { id: 1, username });    } else {      console.log("wrong credentials");      return done(null, false);    }  }),);passport.serializeUser((user, cb) => {  console.log(`serializeUser ${user.id}`);  cb(null, user);});passport.deserializeUser((user: Express.User, cb) => {  console.log(`deserializeUser ${user.id}`);  cb(null, user);});const io = new Server(httpServer);httpServer.listen(port, () => {  console.log(`application is running at: http://localhost:${port}`);});
```

```js
npm install @types/express @types/express-session @types/passport @types/passport-local
```

```js
function onlyForHandshake(middleware) {  return (req, res, next) => {    const isHandshake = req._query.sid === undefined;    if (isHandshake) {      middleware(req, res, next);    } else {      next();    }  };}io.engine.use(onlyForHandshake(sessionMiddleware));io.engine.use(onlyForHandshake(passport.session()));io.engine.use(  onlyForHandshake((req, res, next) => {    if (req.user) {      next();    } else {      res.writeHead(401);      res.end();    }  }),);
```

```js
express-session
```

```js
passport
```

```js
onlyForHandshake()
```

```js
user
```

```js
io.on("connection", (socket) => {  const user = socket.request.user;});
```

```js
io.on("connection", (socket) => {  const userId = socket.request.user.id;  // the user ID is used as a room  socket.join(`user:${userId}`);});
```

```js
io.to(`user:${userId}`).emit("foo", "bar");
```

```js
const sockets = await io.in(`user:${userId}`).fetchSockets();const isUserConnected = sockets.length > 0;
```

# https://socket.io/how-to/use-with-pkg

# How to use with pkg

The client files are not automatically included as assets, you need to manually specify them:

index.js

ES modules are not currently supported. More information here: https://github.com/vercel/pkg/issues/1291

pkg.json

And then run:

And voilà!

```js
const { Server } = require("socket.io");const io = new Server();io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
{  "assets": "node_modules/socket.io/client-dist/*.js"}
```

```js
$ pkg -c pkg.json -t node14-linux index.js
```

```js
pkg
```

```js
index.js
```

```js
const { Server } = require("socket.io");const io = new Server();io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
pkg.json
```

```js
{  "assets": "node_modules/socket.io/client-dist/*.js"}
```

```js
$ pkg -c pkg.json -t node14-linux index.js
```

# https://socket.io/how-to/use-with-react

# How to use with React

## Example​

## Remarks about the useEffect hook​

## Important notes​

### Cleanup​

### Dependencies​

### Disconnection​

### Hot module reloading​

### Listeners in a child component​

### Temporary disconnections​

This guide shows how to use Socket.IO within a React application.

Structure:

The Socket.IO client is initialized in the src/socket.js file:

src/socket.js

By default, the Socket.IO client opens a connection to the server right away. You can prevent this behavior with the autoConnect option:

In that case, you will need to call socket.connect() to make the Socket.IO client connect. This can be useful for example when the user must provide some kind of credentials before connecting.

During development, you need to enable CORS on your server:

Reference: Handling CORS

The events listeners are then registered in the App component, which stores the state and pass it down to its child components via props.

See also: https://react.dev/learn/sharing-state-between-components

src/App.js

A few remarks about the usage of the useEffect hook can be found below.

The child components can then use the state and the socket object like this:

Any event listeners registered in the setup function must be removed in the cleanup callback in order to prevent duplicate event registrations.

Also, the event listeners are named functions, so calling socket.off() only removes this specific listener:

The onFooEvent function could also have been written like this:

This works too, but please note that in that case, the onFooEvent listener will be unregistered then registered again on each render.

If you need to close the Socket.IO client when your component is unmounted (for example, if the connection is only needed in a specific part of your application), you should:

In Strict Mode, every Effect is run twice in order to catch bugs during development, so you will see:

You could have two Effects instead:

These remarks are valid for any front-end framework.

The hot reloading of a file that contains the initialization of a Socket.IO client (i.e. the src/socket.js file in the example above) might leave the previous Socket.IO connection alive, which means that:

The only known workaround is to do a full-page reload when this specific file is updated (or disable hot reloading altogether, but that might be a bit extreme).

Reference: https://webpack.js.org/concepts/hot-module-replacement/

We strongly advise against registering event listeners in your child components, because it ties the state of the UI with the time of reception of the events: if the component is not mounted, then some messages might be missed.

src/components/MyComponent.js

While very powerful, WebSocket connections are not always up and running:

Which means you will need to properly handle the temporary disconnections, in order to provide a great experience to your users.

The good news is that Socket.IO includes some features that can help you. Please check:

Back to the list of examples

- src/components/ConnectionState.js
- src/components/Events.js
- src/components/ConnectionManager.js
- src/components/MyForm.js
- ensure socket.connect() is called in the setup phase:
- setup: socket.connect()
- cleanup: socket.disconnect()
- setup: socket.connect()
- have no dependency for this Effect in order to prevent a reconnection on each render:
- you might have multiple connections on your Socket.IO server
- you might receive events from the previous connection
- anything between the user and the Socket.IO server may encounter a temporary failure or be restarted
- the server itself may be killed as part of an autoscaling policy
- the user may lose connection or switch from Wi-Fi to 4G, in case of a mobile browser
- Connection state recovery
- Delivery guarantees
- Example
- Remarks about the useEffect hookCleanupDependenciesDisconnection
- Cleanup
- Dependencies
- Disconnection
- Important notesHot module reloadingListeners in a child componentTemporary disconnections
- Hot module reloading
- Listeners in a child component
- Temporary disconnections
```js
src├── App.js├── components│   ├── ConnectionManager.js│   ├── ConnectionState.js│   ├── Events.js│   └── MyForm.js└── socket.js
```

```js
import { io } from 'socket.io-client';// "undefined" means the URL will be computed from the `window.location` objectconst URL = process.env.NODE_ENV === 'production' ? undefined : 'http://localhost:4000';export const socket = io(URL);
```

```js
export const socket = io(URL, {  autoConnect: false});
```

```js
const io = new Server({  cors: {    origin: "http://localhost:3000"  }});io.listen(4000);
```

```js
import React, { useState, useEffect } from 'react';import { socket } from './socket';import { ConnectionState } from './components/ConnectionState';import { ConnectionManager } from './components/ConnectionManager';import { Events } from "./components/Events";import { MyForm } from './components/MyForm';export default function App() {  const [isConnected, setIsConnected] = useState(socket.connected);  const [fooEvents, setFooEvents] = useState([]);  useEffect(() => {    function onConnect() {      setIsConnected(true);    }    function onDisconnect() {      setIsConnected(false);    }    function onFooEvent(value) {      setFooEvents(previous => [...previous, value]);    }    socket.on('connect', onConnect);    socket.on('disconnect', onDisconnect);    socket.on('foo', onFooEvent);    return () => {      socket.off('connect', onConnect);      socket.off('disconnect', onDisconnect);      socket.off('foo', onFooEvent);    };  }, []);  return (    <div className="App">      <ConnectionState isConnected={ isConnected } />      <Events events={ fooEvents } />      <ConnectionManager />      <MyForm />    </div>  );}
```

```js
import React from 'react';export function ConnectionState({ isConnected }) {  return <p>State: { '' + isConnected }</p>;}
```

```js
import React from 'react';export function Events({ events }) {  return (    <ul>    {      events.map((event, index) =>        <li key={ index }>{ event }</li>      )    }    </ul>  );}
```

```js
import React from 'react';import { socket } from '../socket';export function ConnectionManager() {  function connect() {    socket.connect();  }  function disconnect() {    socket.disconnect();  }  return (    <>      <button onClick={ connect }>Connect</button>      <button onClick={ disconnect }>Disconnect</button>    </>  );}
```

```js
import React, { useState } from 'react';import { socket } from '../socket';export function MyForm() {  const [value, setValue] = useState('');  const [isLoading, setIsLoading] = useState(false);  function onSubmit(event) {    event.preventDefault();    setIsLoading(true);    socket.timeout(5000).emit('create-something', value, () => {      setIsLoading(false);    });  }  return (    <form onSubmit={ onSubmit }>      <input onChange={ e => setValue(e.target.value) } />      <button type="submit" disabled={ isLoading }>Submit</button>    </form>  );}
```

```js
useEffect(() => {  function onFooEvent(value) {    // ...  }  socket.on('foo', onFooEvent);  return () => {    // BAD: missing event registration cleanup  };}, []);
```

```js
useEffect(() => {  socket.on('foo', (value) => {    // ...  });  return () => {    // BAD: this will remove all listeners for the 'foo' event, which may    // include the ones registered in another component    socket.off('foo');  };}, []);
```

```js
useEffect(() => {  function onFooEvent(value) {    setFooEvents(fooEvents.concat(value));  }  socket.on('foo', onFooEvent);  return () => {    socket.off('foo', onFooEvent);  };}, [fooEvents]);
```

```js
useEffect(() => {  // no-op if the socket is already connected  socket.connect();  return () => {    socket.disconnect();  };}, []);
```

```js
useEffect(() => {  socket.connect();  function onFooEvent(value) {    setFooEvents(fooEvents.concat(value));  }  socket.on('foo', onFooEvent);  return () => {    socket.off('foo', onFooEvent);    // BAD: the Socket.IO client will reconnect every time the fooEvents array    // is updated    socket.disconnect();  };}, [fooEvents]);
```

```js
import React, { useState, useEffect } from 'react';import { socket } from './socket';function App() {  const [fooEvents, setFooEvents] = useState([]);  useEffect(() => {    // no-op if the socket is already connected    socket.connect();    return () => {      socket.disconnect();    };  }, []);  useEffect(() => {    function onFooEvent(value) {      setFooEvents(fooEvents.concat(value));    }    socket.on('foo', onFooEvent);    return () => {      socket.off('foo', onFooEvent);    };  }, [fooEvents]);  // ...}
```

```js
import React from 'react';export default function MyComponent() {  const [fooEvents, setFooEvents] = useState([]);  useEffect(() => {    function onFooEvent(value) {      setFooEvents(previous => [...previous, value]);    }    // BAD: this ties the state of the UI with the time of reception of the    // 'foo' events    socket.on('foo', onFooEvent);    return () => {      socket.off('foo', onFooEvent);    };  }, []);  // ...}
```

```js
src├── App.js├── components│   ├── ConnectionManager.js│   ├── ConnectionState.js│   ├── Events.js│   └── MyForm.js└── socket.js
```

```js
src/socket.js
```

```js
src/socket.js
```

```js
import { io } from 'socket.io-client';// "undefined" means the URL will be computed from the `window.location` objectconst URL = process.env.NODE_ENV === 'production' ? undefined : 'http://localhost:4000';export const socket = io(URL);
```

```js
autoConnect
```

```js
export const socket = io(URL, {  autoConnect: false});
```

```js
socket.connect()
```

```js
const io = new Server({  cors: {    origin: "http://localhost:3000"  }});io.listen(4000);
```

```js
App
```

```js
src/App.js
```

```js
import React, { useState, useEffect } from 'react';import { socket } from './socket';import { ConnectionState } from './components/ConnectionState';import { ConnectionManager } from './components/ConnectionManager';import { Events } from "./components/Events";import { MyForm } from './components/MyForm';export default function App() {  const [isConnected, setIsConnected] = useState(socket.connected);  const [fooEvents, setFooEvents] = useState([]);  useEffect(() => {    function onConnect() {      setIsConnected(true);    }    function onDisconnect() {      setIsConnected(false);    }    function onFooEvent(value) {      setFooEvents(previous => [...previous, value]);    }    socket.on('connect', onConnect);    socket.on('disconnect', onDisconnect);    socket.on('foo', onFooEvent);    return () => {      socket.off('connect', onConnect);      socket.off('disconnect', onDisconnect);      socket.off('foo', onFooEvent);    };  }, []);  return (    <div className="App">      <ConnectionState isConnected={ isConnected } />      <Events events={ fooEvents } />      <ConnectionManager />      <MyForm />    </div>  );}
```

```js
useEffect
```

```js
socket
```

```js
src/components/ConnectionState.js
```

```js
import React from 'react';export function ConnectionState({ isConnected }) {  return <p>State: { '' + isConnected }</p>;}
```

```js
src/components/Events.js
```

```js
import React from 'react';export function Events({ events }) {  return (    <ul>    {      events.map((event, index) =>        <li key={ index }>{ event }</li>      )    }    </ul>  );}
```

```js
src/components/ConnectionManager.js
```

```js
import React from 'react';import { socket } from '../socket';export function ConnectionManager() {  function connect() {    socket.connect();  }  function disconnect() {    socket.disconnect();  }  return (    <>      <button onClick={ connect }>Connect</button>      <button onClick={ disconnect }>Disconnect</button>    </>  );}
```

```js
src/components/MyForm.js
```

```js
import React, { useState } from 'react';import { socket } from '../socket';export function MyForm() {  const [value, setValue] = useState('');  const [isLoading, setIsLoading] = useState(false);  function onSubmit(event) {    event.preventDefault();    setIsLoading(true);    socket.timeout(5000).emit('create-something', value, () => {      setIsLoading(false);    });  }  return (    <form onSubmit={ onSubmit }>      <input onChange={ e => setValue(e.target.value) } />      <button type="submit" disabled={ isLoading }>Submit</button>    </form>  );}
```

```js
useEffect
```

```js
useEffect(() => {  function onFooEvent(value) {    // ...  }  socket.on('foo', onFooEvent);  return () => {    // BAD: missing event registration cleanup  };}, []);
```

```js
socket.off()
```

```js
useEffect(() => {  socket.on('foo', (value) => {    // ...  });  return () => {    // BAD: this will remove all listeners for the 'foo' event, which may    // include the ones registered in another component    socket.off('foo');  };}, []);
```

```js
onFooEvent
```

```js
useEffect(() => {  function onFooEvent(value) {    setFooEvents(fooEvents.concat(value));  }  socket.on('foo', onFooEvent);  return () => {    socket.off('foo', onFooEvent);  };}, [fooEvents]);
```

```js
onFooEvent
```

```js
socket.connect()
```

```js
useEffect(() => {  // no-op if the socket is already connected  socket.connect();  return () => {    socket.disconnect();  };}, []);
```

```js
socket.connect()
```

```js
socket.disconnect()
```

```js
socket.connect()
```

```js
useEffect(() => {  socket.connect();  function onFooEvent(value) {    setFooEvents(fooEvents.concat(value));  }  socket.on('foo', onFooEvent);  return () => {    socket.off('foo', onFooEvent);    // BAD: the Socket.IO client will reconnect every time the fooEvents array    // is updated    socket.disconnect();  };}, [fooEvents]);
```

```js
import React, { useState, useEffect } from 'react';import { socket } from './socket';function App() {  const [fooEvents, setFooEvents] = useState([]);  useEffect(() => {    // no-op if the socket is already connected    socket.connect();    return () => {      socket.disconnect();    };  }, []);  useEffect(() => {    function onFooEvent(value) {      setFooEvents(fooEvents.concat(value));    }    socket.on('foo', onFooEvent);    return () => {      socket.off('foo', onFooEvent);    };  }, [fooEvents]);  // ...}
```

```js
src/socket.js
```

```js
src/components/MyComponent.js
```

```js
import React from 'react';export default function MyComponent() {  const [fooEvents, setFooEvents] = useState([]);  useEffect(() => {    function onFooEvent(value) {      setFooEvents(previous => [...previous, value]);    }    // BAD: this ties the state of the UI with the time of reception of the    // 'foo' events    socket.on('foo', onFooEvent);    return () => {      socket.off('foo', onFooEvent);    };  }, []);  // ...}
```

```js
useEffect
```

# https://socket.io/how-to/use-with-react-native

# How to use with React Native

## Connection URL​

## Common issues​

## Sample projects​

### Cleartext traffic blocked on Android​

### With a self-signed certificate​

Reference: https://reactnative.dev/

All tips from our React guide can be applied with React Native as well.

The URL to reach your Socket.IO server during development varies depending on your platform:

Example with a real device:

When developing an application in the browser, you will also need to enable CORS on the server side:

Reference: Handling CORS

You can add the following configuration to allow it during development:

Reference: https://developer.android.com/privacy-and-security/security-config

You can reach a Socket.IO server with a self-signed certificate with the following configuration:

The IP address must be included in the subjectAltName of the self-signed certificate:

Else the client won't be able to establish the connection.

You can check it with the following command:

Reference: https://developer.android.com/privacy-and-security/security-config

That's all folks, thanks for reading!

Back to the list of examples

- either with android:usesCleartextTraffic="true"
- or with a Network Security Configuration file:
- Expo Go: https://github.com/socketio/socket.io/tree/main/examples/expo-example
- React Native CLI: https://github.com/socketio/socket.io/tree/main/examples/ReactNativeExample
- Connection URL
- Common issuesCleartext traffic blocked on AndroidWith a self-signed certificate
- Cleartext traffic blocked on Android
- With a self-signed certificate
- Sample projects
```js
import { io } from "socket.io-client";export const socket = io("http://192.168.0.10:3000");
```

```js
const io = new Server({  cors: {    origin: ["http://localhost:8081"],  }});
```

```js
<?xml version="1.0" encoding="utf-8"?><manifest>    <application            android:usesCleartextTraffic="true"    /></manifest>
```

```js
<?xml version="1.0" encoding="utf-8"?><network-security-config>    <domain-config cleartextTrafficPermitted="true">        <domain>192.168.0.10</domain>    </domain-config></network-security-config>
```

```js
<?xml version="1.0" encoding="utf-8"?><manifest>    <application            android:networkSecurityConfig="@xml/network_security_config"    /></manifest>
```

```js
<?xml version="1.0" encoding="utf-8"?><manifest>    <application            android:networkSecurityConfig="@xml/network_security_config"    /></manifest>
```

```js
<?xml version="1.0" encoding="utf-8"?><network-security-config>    <!-- needed by the Metro dev server -->    <domain-config cleartextTrafficPermitted="true">        <domain>localhost</domain>    </domain-config>    <domain-config>        <domain>192.168.0.10</domain>        <trust-anchors>            <certificates src="@raw/mycert" />        </trust-anchors>    </domain-config></network-security-config>
```

```js
-----BEGIN CERTIFICATE-----[...]-----END CERTIFICATE-----
```

```js
$ openssl req -x509 -nodes \  -newkey rsa:2048 \  -out cert.pem \  -keyout key.pem \  -subj '/CN=localhost' \  -addext 'subjectAltName = IP:192.168.0.10'
```

```js
$ openssl x509 -in cert.pem -text -noout | grep X509v3 -A 1        X509v3 extensions:            X509v3 Subject Key Identifier:                C3:67:68:1A:F2:2C:F2:E8:B9:7A:7D:25:3F:5D:E0:AF:B5:B0:AF:16            X509v3 Authority Key Identifier:                C3:67:68:1A:F2:2C:F2:E8:B9:7A:7D:25:3F:5D:E0:AF:B5:B0:AF:16            X509v3 Basic Constraints: critical                CA:TRUE            X509v3 Subject Alternative Name:                IP Address:192.168.0.10
```

```js
localhost
```

```js
localhost
```

```js
10.0.2.2
```

```js
import { io } from "socket.io-client";export const socket = io("http://192.168.0.10:3000");
```

```js
const io = new Server({  cors: {    origin: ["http://localhost:8081"],  }});
```

```js
http://
```

```js
android:usesCleartextTraffic="true"
```

```js
<?xml version="1.0" encoding="utf-8"?><manifest>    <application            android:usesCleartextTraffic="true"    /></manifest>
```

```js
<?xml version="1.0" encoding="utf-8"?><network-security-config>    <domain-config cleartextTrafficPermitted="true">        <domain>192.168.0.10</domain>    </domain-config></network-security-config>
```

```js
<?xml version="1.0" encoding="utf-8"?><manifest>    <application            android:networkSecurityConfig="@xml/network_security_config"    /></manifest>
```

```js
<?xml version="1.0" encoding="utf-8"?><manifest>    <application            android:networkSecurityConfig="@xml/network_security_config"    /></manifest>
```

```js
<?xml version="1.0" encoding="utf-8"?><network-security-config>    <!-- needed by the Metro dev server -->    <domain-config cleartextTrafficPermitted="true">        <domain>localhost</domain>    </domain-config>    <domain-config>        <domain>192.168.0.10</domain>        <trust-anchors>            <certificates src="@raw/mycert" />        </trust-anchors>    </domain-config></network-security-config>
```

```js
-----BEGIN CERTIFICATE-----[...]-----END CERTIFICATE-----
```

```js
subjectAltName
```

```js
$ openssl req -x509 -nodes \  -newkey rsa:2048 \  -out cert.pem \  -keyout key.pem \  -subj '/CN=localhost' \  -addext 'subjectAltName = IP:192.168.0.10'
```

```js
$ openssl x509 -in cert.pem -text -noout | grep X509v3 -A 1        X509v3 extensions:            X509v3 Subject Key Identifier:                C3:67:68:1A:F2:2C:F2:E8:B9:7A:7D:25:3F:5D:E0:AF:B5:B0:AF:16            X509v3 Authority Key Identifier:                C3:67:68:1A:F2:2C:F2:E8:B9:7A:7D:25:3F:5D:E0:AF:B5:B0:AF:16            X509v3 Basic Constraints: critical                CA:TRUE            X509v3 Subject Alternative Name:                IP Address:192.168.0.10
```

# https://socket.io/how-to/use-with-vue

# How to use with Vue 3

## Example​

## Important notes​

## With Pinia​

## Sample projects​

### Hot module reloading​

### Listeners in a child component​

### Temporary disconnections​

This guide shows how to use Socket.IO within a Vue 3 application.

Structure:

The Socket.IO client is initialized in the src/socket.js file:

src/socket.js

During development, you will need to enable CORS on your server:

Reference: Handling CORS

The event listeners are registered in the src/socket.js file, as we strongly advise against registering listeners in your components. More on that below.

You can then use it in your components:

The socket object can also be initialized without connecting right away with the autoConnect option:

This can be useful for example when the user must provide some credentials before connecting.

Reference: https://vuejs.org/guide/scaling-up/state-management.html

These remarks are valid for any front-end framework.

The hot reloading of a file that contains the initialization of a Socket.IO client (i.e. the src/socket.js file in the example above) might leave the previous Socket.IO connection alive, which means that:

The only known workaround is to do a full-page reload when this specific file is updated (or disable hot reloading altogether, but that might be a bit extreme).

Reference: https://vue-loader.vuejs.org/guide/hot-reload.html

We strongly advise against registering event listeners in your child components, because it ties the state of the UI with the time of reception of the events: if the component is not mounted, then some messages might be missed.

src/components/MyComponent.vue

This is fine in your root component though (since it is always mounted).

While very powerful, WebSocket connections are not always up and running:

Which means you will need to properly handle the temporary disconnections, in order to provide a great experience to your users.

The good news is that Socket.IO includes some features that can help you. Please check:

Pinia is a store library for Vue, it allows you to share a state across components/pages.

More information can be found here.

Pinia's stores and Socket.IO connection can be synced with the following pattern:

And then in your root component:

Back to the list of examples

- src/components/ConnectionState.vue
- src/components/ConnectionManager.vue
- src/components/MyForm.vue
- you might have multiple connections on your Socket.IO server
- you might receive events from the previous connection
- anything between the user and the Socket.IO server may encounter a temporary failure or be restarted
- the server itself may be killed as part of an autoscaling policy
- the user may lose connection or switch from Wi-Fi to 4G, in case of a mobile browser
- Connection state recovery
- Delivery guarantees
- TODO application
- Example
- Important notesHot module reloadingListeners in a child componentTemporary disconnections
- Hot module reloading
- Listeners in a child component
- Temporary disconnections
- With Pinia
- Sample projects
```js
src├── App.vue├── components│   ├── ConnectionManager.vue│   ├── ConnectionState.vue│   └── MyForm.vue├── main.js└── socket.js
```

```js
import { reactive } from "vue";import { io } from "socket.io-client";export const state = reactive({  connected: false,  fooEvents: [],  barEvents: []});// "undefined" means the URL will be computed from the `window.location` objectconst URL = process.env.NODE_ENV === "production" ? undefined : "http://localhost:3000";export const socket = io(URL);socket.on("connect", () => {  state.connected = true;});socket.on("disconnect", () => {  state.connected = false;});socket.on("foo", (...args) => {  state.fooEvents.push(args);});socket.on("bar", (...args) => {  state.barEvents.push(args);});
```

```js
const io = new Server({  cors: {    origin: "http://localhost:8080"  }});
```

```js
<template>  <p>State: {{ connected }}</p></template><script>import { state } from "@/socket";export default {  name: "ConnectionState",  computed: {    connected() {      return state.connected;    }  }}</script>
```

```js
<template>  <button @click="connect()">Connect</button>  <button @click="disconnect()">Disconnect</button></template><script>import { socket } from "@/socket";export default {  name: "ConnectionManager",  methods: {    connect() {      socket.connect();    },    disconnect() {      socket.disconnect();    }  }}</script>
```

```js
export const socket = io(URL, {  autoConnect: false});
```

```js
<template>  <form @submit.prevent="onSubmit">    <input v-model="value" />    <button type="submit" :disabled="isLoading">Submit</button>  </form></template><script>import { socket } from "@/socket";export default {  name: "MyForm",  data() {    return {      isLoading: false,      value: ""    }  },  methods: {    onSubmit() {      this.isLoading = true;      socket.timeout(5000).emit("create-something", this.value, () => {        this.isLoading = false;      });    },  }}</script>
```

```js
<script>import { socket } from "@/socket";export default {  name: "MyComponent",  data() {    return {      fooEvents: []    }  },  mounted() {    // BAD    socket.on("foo", (...args) => {      this.fooEvents.push(args);    });  }}</script>
```

```js
import { defineStore } from "pinia";import { socket } from "@/socket";export const useItemStore = defineStore("item", {  state: () => ({    items: [],  }),  actions: {    bindEvents() {      // sync the list of items upon connection      socket.on("connect", () => {        socket.emit("item:list", (res) => {          this.items = res.data;        });      });      // update the store when an item was created      socket.on("item:created", (item) => {        this.items.push(item);      });    },    createItem(label) {      const item = {        id: Date.now(), // temporary ID for v-for key        label      };      this.items.push(item);      socket.emit("item:create", { label }, (res) => {        item.id = res.data;      });    },  },});
```

```js
import { defineStore } from "pinia";import { socket } from "@/socket";export const useConnectionStore = defineStore("connection", {  state: () => ({    isConnected: false,  }),  actions: {    bindEvents() {      socket.on("connect", () => {        this.isConnected = true;      });      socket.on("disconnect", () => {        this.isConnected = false;      });    },    connect() {      socket.connect();    }  },});
```

```js
<script setup>import { useItemStore } from "@/stores/item";import { useConnectionStore } from "@/stores/connection";import { socket } from "@/socket";const itemStore = useItemStore();const connectionStore = useConnectionStore();// remove any existing listeners (after a hot module replacement)socket.off();itemStore.bindEvents();connectionStore.bindEvents();</script>
```

```js
src├── App.vue├── components│   ├── ConnectionManager.vue│   ├── ConnectionState.vue│   └── MyForm.vue├── main.js└── socket.js
```

```js
src/socket.js
```

```js
src/socket.js
```

```js
import { reactive } from "vue";import { io } from "socket.io-client";export const state = reactive({  connected: false,  fooEvents: [],  barEvents: []});// "undefined" means the URL will be computed from the `window.location` objectconst URL = process.env.NODE_ENV === "production" ? undefined : "http://localhost:3000";export const socket = io(URL);socket.on("connect", () => {  state.connected = true;});socket.on("disconnect", () => {  state.connected = false;});socket.on("foo", (...args) => {  state.fooEvents.push(args);});socket.on("bar", (...args) => {  state.barEvents.push(args);});
```

```js
const io = new Server({  cors: {    origin: "http://localhost:8080"  }});
```

```js
src/socket.js
```

```js
src/components/ConnectionState.vue
```

```js
<template>  <p>State: {{ connected }}</p></template><script>import { state } from "@/socket";export default {  name: "ConnectionState",  computed: {    connected() {      return state.connected;    }  }}</script>
```

```js
src/components/ConnectionManager.vue
```

```js
<template>  <button @click="connect()">Connect</button>  <button @click="disconnect()">Disconnect</button></template><script>import { socket } from "@/socket";export default {  name: "ConnectionManager",  methods: {    connect() {      socket.connect();    },    disconnect() {      socket.disconnect();    }  }}</script>
```

```js
socket
```

```js
autoConnect
```

```js
export const socket = io(URL, {  autoConnect: false});
```

```js
src/components/MyForm.vue
```

```js
<template>  <form @submit.prevent="onSubmit">    <input v-model="value" />    <button type="submit" :disabled="isLoading">Submit</button>  </form></template><script>import { socket } from "@/socket";export default {  name: "MyForm",  data() {    return {      isLoading: false,      value: ""    }  },  methods: {    onSubmit() {      this.isLoading = true;      socket.timeout(5000).emit("create-something", this.value, () => {        this.isLoading = false;      });    },  }}</script>
```

```js
src/socket.js
```

```js
src/components/MyComponent.vue
```

```js
<script>import { socket } from "@/socket";export default {  name: "MyComponent",  data() {    return {      fooEvents: []    }  },  mounted() {    // BAD    socket.on("foo", (...args) => {      this.fooEvents.push(args);    });  }}</script>
```

```js
import { defineStore } from "pinia";import { socket } from "@/socket";export const useItemStore = defineStore("item", {  state: () => ({    items: [],  }),  actions: {    bindEvents() {      // sync the list of items upon connection      socket.on("connect", () => {        socket.emit("item:list", (res) => {          this.items = res.data;        });      });      // update the store when an item was created      socket.on("item:created", (item) => {        this.items.push(item);      });    },    createItem(label) {      const item = {        id: Date.now(), // temporary ID for v-for key        label      };      this.items.push(item);      socket.emit("item:create", { label }, (res) => {        item.id = res.data;      });    },  },});
```

```js
import { defineStore } from "pinia";import { socket } from "@/socket";export const useConnectionStore = defineStore("connection", {  state: () => ({    isConnected: false,  }),  actions: {    bindEvents() {      socket.on("connect", () => {        this.isConnected = true;      });      socket.on("disconnect", () => {        this.isConnected = false;      });    },    connect() {      socket.connect();    }  },});
```

```js
<script setup>import { useItemStore } from "@/stores/item";import { useConnectionStore } from "@/stores/connection";import { socket } from "@/socket";const itemStore = useItemStore();const connectionStore = useConnectionStore();// remove any existing listeners (after a hot module replacement)socket.off();itemStore.bindEvents();connectionStore.bindEvents();</script>
```

# https://socket.io/search

# Search the documentation

- Guide
- Tutorial
- Examples
- Emit cheatsheet
- Help
- Troubleshooting
- Stack Overflow
- GitHub Discussions
- Slack
- News
- Blog
- Twitter
- Tools
- CDN
- Admin UI
- FAQ
- Changelog
- Roadmap
- Become a sponsor
- 4.x
- 3.x
- 2.x
- Changelog
- English
- Français
- Português (Brasil)
- 中文（中国）
- Docs
- Ecosystem
- About
- Versions
- Languages
- Guide
- Tutorial
- Examples
- Troubleshooting
- Stack Overflow
- GitHub Discussions
- Slack
- Blog
- Twitter
- CDN
- Admin UI
- FAQ
- Changelog
- Roadmap
- Become a sponsor
# https://socket.io/socket-io-with-apache-cordova

Since Apache Cordova apps are written mostly in JS, it is actually really easy to use Socket.IO! Let’s walk through a small example.

First we prepare a simple server:

This server will simply listen to Socket.IO client connections, and will emit some text to them via a text event.

Now let’s get get down to the point. We want to start off by creating a new Cordova project to start modifying. Let’s start from scratch.

Running

will install the actual Cordova cli tool we use to create projects, install/remove dependencies, and launch our emulator among other things.

will make a new project template for us to start modifying. Feel free to poke around the newly created folder, called socket.io-example and take a look at some of the created files.

You should now be in the project folder. If you didn’t navigate there yet in command line, do it now with cd socket.io-example.

Since I’m developing this example on OS X, I’m going to build for iOS. You could do it similarly for Android. To add the build target, run the following:

Next we want to build all the native components. We can do this by running

Now let’s actually run the template application to see that everything is working. If you are on OS X, you can install the iOS emulator like so

You should see the emulator open up with something like this when running cordova emulate ios:

Now that you see everything working with the actual setup, let’s start write some code. Open up www/index.html in your project directory. It should look something like this:

To begin, we need to get the Socket.IO-client script. We can take it from the CDN like so:

Now to add actual logic, let’s write things below the app.initialize call. We might want to make sure that the device has loaded the application before running any of our code. We can do this like so:

This event will fire when the application has fully loaded. To add some actual logic, we just need to fill in that function. Let’s make something that receives the data emitted by our server on socket connection, and bring a notification box to show that text. Here’s what you could do:

Let’s run the emulator again with cordova emulate ios, and here’s what you should see:

That’s it! I hope this will help to get you started! Have fun hacking!

```js
var server = require('http').createServer();var io = require('socket.io')(server);io.sockets.on('connection', function (socket) {    console.log('socket connected');    socket.on('disconnect', function () {        console.log('socket disconnected');    });    socket.emit('text', 'wow. such event. very real time.');});server.listen(3000);
```

```js
npm install -g cordova
```

```js
cordova create socket.io-example socket.io.example socket.io-example
```

```js
cordova platform add ios
```

```js
cordova build ios
```

```js
brew install ios-sim
```

```js
<!DOCTYPE html><!--    Licensed to the Apache Software Foundation (ASF) under one    or more contributor license agreements.  See the NOTICE file    distributed with this work for additional information    regarding copyright ownership.  The ASF licenses this file    to you under the Apache License, Version 2.0 (the    "License"); you may not use this file except in compliance    with the License.  You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0    Unless required by applicable law or agreed to in writing,    software distributed under the License is distributed on an    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY     KIND, either express or implied.  See the License for the    specific language governing permissions and limitations    under the License.--><html>    <head>        <meta charset="utf-8" />        <meta name="format-detection" content="telephone=no" />        <!-- WARNING: for iOS 7, remove the width=device-width and height=device-height attributes. See https://issues.apache.org/jira/browse/CB-4323 -->        <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi" />        <link rel="stylesheet" type="text/css" href="css/index.css" />        <meta name="msapplication-tap-highlight" content="no" />        <title>Hello World</title>    </head>    <body>        <div class="app">            <h1>Apache Cordova</h1>            <div id="deviceready" class="blink">                <p class="event listening">Connecting to Device</p>                <p class="event received">Device is Ready</p>            </div>        </div>        <script type="text/javascript" src="cordova.js"></script>        <script type="text/javascript" src="js/index.js"></script>        <script type="text/javascript">            app.initialize();        </script>    </body></html>
```

```js
<script type="text/javascript" src="cordova.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js"></script><script type="text/javascript" src="js/index.js"></script>
```

```js
<script type="text/javascript">  app.initialize();  document.addEventListener('deviceready', function() {    // code goes here  });</script>
```

```js
<script type="text/javascript">  app.initialize();  document.addEventListener('deviceready', function() {    socket.on('connect', function() {      socket.on('text', function(text) {        alert(text);       });     });  });</script>
```

```js
var server = require('http').createServer();var io = require('socket.io')(server);io.sockets.on('connection', function (socket) {    console.log('socket connected');    socket.on('disconnect', function () {        console.log('socket disconnected');    });    socket.emit('text', 'wow. such event. very real time.');});server.listen(3000);
```

```js
text
```

```js
npm install -g cordova
```

```js
cordova create socket.io-example socket.io.example socket.io-example
```

```js
socket.io-example
```

```js
cd socket.io-example
```

```js
cordova platform add ios
```

```js
cordova build ios
```

```js
brew install ios-sim
```

```js
cordova emulate ios
```

```js
www/index.html
```

```js
<!DOCTYPE html><!--    Licensed to the Apache Software Foundation (ASF) under one    or more contributor license agreements.  See the NOTICE file    distributed with this work for additional information    regarding copyright ownership.  The ASF licenses this file    to you under the Apache License, Version 2.0 (the    "License"); you may not use this file except in compliance    with the License.  You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0    Unless required by applicable law or agreed to in writing,    software distributed under the License is distributed on an    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY     KIND, either express or implied.  See the License for the    specific language governing permissions and limitations    under the License.--><html>    <head>        <meta charset="utf-8" />        <meta name="format-detection" content="telephone=no" />        <!-- WARNING: for iOS 7, remove the width=device-width and height=device-height attributes. See https://issues.apache.org/jira/browse/CB-4323 -->        <meta name="viewport" content="user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width, height=device-height, target-densitydpi=device-dpi" />        <link rel="stylesheet" type="text/css" href="css/index.css" />        <meta name="msapplication-tap-highlight" content="no" />        <title>Hello World</title>    </head>    <body>        <div class="app">            <h1>Apache Cordova</h1>            <div id="deviceready" class="blink">                <p class="event listening">Connecting to Device</p>                <p class="event received">Device is Ready</p>            </div>        </div>        <script type="text/javascript" src="cordova.js"></script>        <script type="text/javascript" src="js/index.js"></script>        <script type="text/javascript">            app.initialize();        </script>    </body></html>
```

```js
<script type="text/javascript" src="cordova.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.2.0/socket.io.js"></script><script type="text/javascript" src="js/index.js"></script>
```

```js
app.initialize
```

```js
<script type="text/javascript">  app.initialize();  document.addEventListener('deviceready', function() {    // code goes here  });</script>
```

```js
<script type="text/javascript">  app.initialize();  document.addEventListener('deviceready', function() {    socket.on('connect', function() {      socket.on('text', function(text) {        alert(text);       });     });  });</script>
```

```js
cordova emulate ios
```

# https://socket.io/docs/v2

# Introduction

## What Socket.IO is​

## What Socket.IO is not​

## Minimal working example​

## Features​

### How does that work?​

### To send an event from the server to the client​

### To send a message from the client to the server​

### Reliability​

### Auto-reconnection support​

### Disconnection detection​

### Binary support​

### Multiplexing support​

Socket.IO is a library that enables real-time, bidirectional and event-based communication between the browser and the server. It consists of:

There are also several client implementation in other languages, which are maintained by the community:

The client will try to establish a WebSocket connection if possible, and will fall back on HTTP long polling if not.

WebSocket is a communication protocol which provides a full-duplex and low-latency channel between the server and the browser. More information can be found here.

So, in the best-case scenario, provided that:

You will have, on the client-side:

Socket.IO provides additional features over a plain WebSocket object, which are listed below.

But first, let's detail what the Socket.IO library is not.

Socket.IO is NOT a WebSocket implementation. Although Socket.IO indeed uses WebSocket as a transport when possible, it adds additional metadata to each packet. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either.

If you are looking for a plain WebSocket server, please take a look at ws or uWebSockets.js.

There are also talks to include a WebSocket server in the Node.js core.

On the client-side, you might be interested by the robust-websocket package.

If you are new to the Node.js ecosystem, please take a look at the Get Started guide, which is ideal for beginners.

Else, let's start right away! The server library can be installed from NPM:

More information about the installation can be found in the Server installation page.

Then, let's create an index.js file, with the following content:

Here, a classic Node.js HTTP server is started to serve the index.html file, and the Socket.IO server is attached to it. Please see the Server initialization page for the various ways to create a server.

Let's create the index.html file next to it:

Finally, let's start our server:

And voilà!

The socket object on both sides extends the EventEmitter class, so:

Let's update the index.js file (server-side):

And the index.html file (client-side):

Demo:

Let's update the index.js file (server-side):

And the index.html file (client-side):

Demo:

Now, let's detail the features provided by Socket.IO.

Its main features are:

Connections are established even in the presence of:

For this purpose, it relies on Engine.IO, which first establishes a long-polling connection, then tries to upgrade to better transports that are "tested" on the side, like WebSocket. Please see the Goals section for more information.

Unless instructed otherwise a disconnected client will try to reconnect forever, until the server is available again. Please see the available reconnection options here.

A heartbeat mechanism is implemented at the Engine.IO level, allowing both the server and the client to know when the other one is not responding anymore.

That functionality is achieved with timers set on both the server and the client, with timeout values (the pingInterval and pingTimeout parameters) shared during the connection handshake. Those timers require any subsequent client calls to be directed to the same server, hence the sticky-session requirement when using multiples nodes.

Any serializable data structures can be emitted, including:

In order to create separation of concerns within your application (for example per module, or based on permissions), Socket.IO allows you to create several Namespaces, which will act as separate communication channels but will share the same underlying connection.

- Documentation
- Introduction
- Java: https://github.com/socketio/socket.io-client-java
- C++: https://github.com/socketio/socket.io-client-cpp
- Swift: https://github.com/socketio/socket.io-client-swift
- Dart: https://github.com/rikulo/socket.io-client-dart
- Python: https://github.com/miguelgrinberg/python-socketio
- .Net: https://github.com/Quobject/SocketIoClientDotNet
- the browser supports WebSocket (97% of all browsers in 2020)
- there is no element (proxy, firewall, ...) preventing WebSocket connections between the client and the server
- sending an event is done with: socket.emit()
- receiving an event is done by registering a listener: socket.on(<event name>, <listener>)
- proxies and load balancers.
- personal firewall and antivirus software.
- ArrayBuffer and Blob in the browser
- ArrayBuffer and Buffer in Node.js
```js
const socket = new WebSocket('ws://localhost:3000');socket.onopen(() => {  socket.send('Hello!');});socket.onmessage(data => {  console.log(data);});
```

```js
const socket = io('ws://localhost:3000');socket.on('connect', () => {  // either with send()  socket.send('Hello!');  // or with emit() and custom event names  socket.emit('salutations', 'Hello!', { 'mr': 'john' }, Uint8Array.from([1, 2, 3, 4]));});// handle the event sent with socket.send()socket.on('message', data => {  console.log(data);});// handle the event sent with socket.emit()socket.on('greetings', (elem1, elem2, elem3) => {  console.log(elem1, elem2, elem3);});
```

```js
const io = require('socket.io')(3000);io.on('connection', socket => {  // either with send()  socket.send('Hello!');  // or with emit() and custom event names  socket.emit('greetings', 'Hey!', { 'ms': 'jane' }, Buffer.from([4, 3, 3, 1]));  // handle the event sent with socket.send()  socket.on('message', (data) => {    console.log(data);  });  // handle the event sent with socket.emit()  socket.on('salutations', (elem1, elem2, elem3) => {    console.log(elem1, elem2, elem3);  });});
```

```js
// WARNING: the client will NOT be able to connect!const socket = io('ws://echo.websocket.org');
```

```js
$ npm install socket.io
```

```js
const content = require('fs').readFileSync(__dirname + '/index.html', 'utf8');const httpServer = require('http').createServer((req, res) => {  // serve the index.html file  res.setHeader('Content-Type', 'text/html');  res.setHeader('Content-Length', Buffer.byteLength(content));  res.end(content);});const io = require('socket.io')(httpServer);io.on('connection', socket => {  console.log('connect');});httpServer.listen(3000, () => {  console.log('go to http://localhost:3000');});
```

```js
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>Minimal working example</title></head><body>    <ul id="events"></ul>    <script src="/socket.io/socket.io.js"></script>    <script>        const $events = document.getElementById('events');        const newItem = (content) => {          const item = document.createElement('li');          item.innerText = content;          return item;        };        const socket = io();        socket.on('connect', () => {          $events.appendChild(newItem('connect'));        });    </script></body></html>
```

```js
$ node index.js
```

```js
io.on('connection', socket => {  let counter = 0;  setInterval(() => {    socket.emit('hello', ++counter);  }, 1000);});
```

```js
const socket = io();socket.on('connect', () => {  $events.appendChild(newItem('connect'));});socket.on('hello', (counter) => {  $events.appendChild(newItem(`hello - ${counter}`));});
```

```js
io.on('connection', socket => {  socket.on('hey', data => {    console.log('hey', data);  });});
```

```js
const socket = io();socket.on('connect', () => {  $events.appendChild(newItem('connect'));});let counter = 0;setInterval(() => {  ++counter;  socket.emit('hey', { counter }); // the object will be serialized for you}, 1000);
```

```js
const socket = new WebSocket('ws://localhost:3000');socket.onopen(() => {  socket.send('Hello!');});socket.onmessage(data => {  console.log(data);});
```

```js
const socket = io('ws://localhost:3000');socket.on('connect', () => {  // either with send()  socket.send('Hello!');  // or with emit() and custom event names  socket.emit('salutations', 'Hello!', { 'mr': 'john' }, Uint8Array.from([1, 2, 3, 4]));});// handle the event sent with socket.send()socket.on('message', data => {  console.log(data);});// handle the event sent with socket.emit()socket.on('greetings', (elem1, elem2, elem3) => {  console.log(elem1, elem2, elem3);});
```

```js
socket
```

```js
const io = require('socket.io')(3000);io.on('connection', socket => {  // either with send()  socket.send('Hello!');  // or with emit() and custom event names  socket.emit('greetings', 'Hey!', { 'ms': 'jane' }, Buffer.from([4, 3, 3, 1]));  // handle the event sent with socket.send()  socket.on('message', (data) => {    console.log(data);  });  // handle the event sent with socket.emit()  socket.on('salutations', (elem1, elem2, elem3) => {    console.log(elem1, elem2, elem3);  });});
```

```js
// WARNING: the client will NOT be able to connect!const socket = io('ws://echo.websocket.org');
```

```js
$ npm install socket.io
```

```js
index.js
```

```js
const content = require('fs').readFileSync(__dirname + '/index.html', 'utf8');const httpServer = require('http').createServer((req, res) => {  // serve the index.html file  res.setHeader('Content-Type', 'text/html');  res.setHeader('Content-Length', Buffer.byteLength(content));  res.end(content);});const io = require('socket.io')(httpServer);io.on('connection', socket => {  console.log('connect');});httpServer.listen(3000, () => {  console.log('go to http://localhost:3000');});
```

```js
index.html
```

```js
index.html
```

```js
<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>Minimal working example</title></head><body>    <ul id="events"></ul>    <script src="/socket.io/socket.io.js"></script>    <script>        const $events = document.getElementById('events');        const newItem = (content) => {          const item = document.createElement('li');          item.innerText = content;          return item;        };        const socket = io();        socket.on('connect', () => {          $events.appendChild(newItem('connect'));        });    </script></body></html>
```

```js
$ node index.js
```

```js
socket
```

```js
socket.emit()
```

```js
socket.on(<event name>, <listener>)
```

```js
index.js
```

```js
io.on('connection', socket => {  let counter = 0;  setInterval(() => {    socket.emit('hello', ++counter);  }, 1000);});
```

```js
index.html
```

```js
const socket = io();socket.on('connect', () => {  $events.appendChild(newItem('connect'));});socket.on('hello', (counter) => {  $events.appendChild(newItem(`hello - ${counter}`));});
```

```js
index.js
```

```js
io.on('connection', socket => {  socket.on('hey', data => {    console.log('hey', data);  });});
```

```js
index.html
```

```js
const socket = io();socket.on('connect', () => {  $events.appendChild(newItem('connect'));});let counter = 0;setInterval(() => {  ++counter;  socket.emit('hey', { counter }); // the object will be serialized for you}, 1000);
```

# https://socket.io/docs/v2/client-api

## IO​

## Manager​

## Socket​

### io.protocol​

### io([url][, options])​

### Initialization examples​

### new Manager(url[, options])​

### manager.reconnection([value])​

### manager.reconnectionAttempts([value])​

### manager.reconnectionDelay([value])​

### manager.reconnectionDelayMax([value])​

### manager.timeout([value])​

### manager.open([callback])​

### manager.connect([callback])​

### manager.socket(nsp, options)​

### Event: 'connect_error'​

### Event: 'connect_timeout'​

### Event: 'reconnect'​

### Event: 'reconnect_attempt'​

### Event: 'reconnecting'​

### Event: 'reconnect_error'​

### Event: 'reconnect_failed'​

### Event: 'ping'​

### Event: 'pong'​

### socket.id​

### socket.connected​

### socket.disconnected​

### socket.open()​

### socket.connect()​

### socket.send([...args][, ack])​

### socket.emit(eventName[, ...args][, ack])​

### socket.on(eventName, callback)​

### socket.compress(value)​

### socket.binary(value)​

### socket.close()​

### socket.disconnect()​

### Events​

### Event: 'connect'​

### Event: 'disconnect'​

### Event: 'error'​

### Event: 'connect_error'​

### Event: 'connect_timeout'​

### Event: 'reconnect'​

### Event: 'reconnect_attempt'​

### Event: 'reconnecting'​

### Event: 'reconnect_error'​

### Event: 'reconnect_failed'​

### Event: 'ping'​

### Event: 'pong'​

Exposed as the io namespace in the standalone build, or the result of calling require('socket.io-client').

The protocol revision number (currently: 4).

The protocol defines the format of the packets exchanged between the client and the server. Both the client and the server must use the same revision in order to understand each other.

You can find more information here.

Creates a new Manager for the given URL, and attempts to reuse an existing Manager for subsequent calls, unless the multiplex option is passed with false. Passing this option is the equivalent of passing 'force new connection': true or forceNew: true.

A new Socket instance is returned for the namespace specified by the pathname in the URL, defaulting to /. For example, if the url is http://localhost/users, a transport connection will be established to http://localhost and a Socket.IO connection will be established to /users.

Query parameters can also be provided, either with the query option or directly in the url (example: http://localhost/users?token=abc).

is the short version of:

See new Manager(url[, options]) for the list of available options.

By default, a single connection is used when connecting to different namespaces (to minimize resources):

That behaviour can be disabled with the forceNew option:

Note: reusing the same namespace will also create two connections

The request URLs will look like: localhost/myownpath/?EIO=3&transport=polling&sid=<id>

Here, the socket connects to the admin namespace, with the custom path mypath.

The request URLs will look like: localhost/mypath/?EIO=3&transport=polling&sid=<id> (the namespace is sent as part of the payload).

The query content can also be updated on reconnection:

This only works if polling transport is enabled (which is the default). Custom headers will not be appended when using websocket as the transport. This happens because the WebSocket handshake does not honor custom headers. (For background see the WebSocket protocol RFC)

By default, a long-polling connection is established first, then upgraded to "better" transports (like WebSocket). If you like to live dangerously, this part can be skipped:

The default parser promotes compatibility (support for Blob, File, binary check) at the expense of performance. A custom parser can be provided to match the needs of your application. Please see the example here.

The Manager manages the Engine.IO client instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling).

The Manager handles the reconnection logic.

A single Manager can be used by several Sockets. You can find more information about this multiplexing feature here.

Please note that, in most cases, you won't use the Manager directly but use the Socket instance instead.

Available options:

Available options for the underlying Engine.IO client:

Node.js-only options for the underlying Engine.IO client:

Sets the reconnection option, or returns it if no parameters are passed.

Sets the reconnectionAttempts option, or returns it if no parameters are passed.

Sets the reconnectionDelay option, or returns it if no parameters are passed.

Sets the reconnectionDelayMax option, or returns it if no parameters are passed.

Sets the timeout option, or returns it if no parameters are passed.

If the manager was initiated with autoConnect to false, launch a new connection attempt.

The callback argument is optional and will be called once the attempt fails/succeeds.

Synonym of manager.open([callback]).

Creates a new Socket for the given namespace.

Fired upon a connection error.

Fired upon a connection timeout.

Fired upon a successful reconnection.

Fired upon an attempt to reconnect.

Fired upon an attempt to reconnect.

Fired upon a reconnection attempt error.

Fired when couldn't reconnect within reconnectionAttempts.

Fired when a ping packet is written out to the server.

Fired when a pong is received from the server.

A Socket is the fundamental class for interacting with the server. A Socket belongs to a certain Namespace (by default /) and uses an underlying Manager to communicate.

A Socket is basically an EventEmitter which sends events to — and receive events from — the server over the network.

A unique identifier for the socket session. Set after the connect event is triggered, and updated after the reconnect event.

Whether or not the socket is connected to the server.

Whether or not the socket is disconnected from the server.

Manually opens the socket.

It can also be used to manually reconnect:

Synonym of socket.open().

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including Buffer.

The ack argument is optional and will be called with the server answer.

Register a new handler for the given event.

The socket actually inherits every method of the Emitter class, like hasListeners, once or off (to remove an event listener).

Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method.

Specifies whether the emitted data contains binary. Increases performance when specified. Can be true or false.

Disconnects the socket manually.

Synonym of socket.close().

The Socket instance emits all events sent by its underlying Manager, which are related to the state of the connection to the server.

It also emits events related to the state of the connection to the Namespace:

Fired upon connection to the Namespace (including a successful reconnection).

Fired upon disconnection. The list of possible disconnection reasons:

In all cases but the first (disconnection by the server), the client will wait for a small random delay and then reconnect.

Fired when an error occurs.

Fired upon a connection error.

Fired upon a connection timeout.

Fired upon a successful reconnection.

Fired upon an attempt to reconnect.

Fired upon an attempt to reconnect.

Fired upon a reconnection attempt error.

Fired when the client couldn't reconnect within reconnectionAttempts.

Fired when a ping is sent to the server.

Fired when a pong is received from the server.

- (Number)
- url (String) (defaults to window.location.host)
- options (Object)forceNew (Boolean) whether to reuse an existing connection
- forceNew (Boolean) whether to reuse an existing connection
- Returns Socket
- url (String)
- options (Object)
- Returns Manager
- value (Boolean)
- Returns Manager|Boolean
- value (Number)
- Returns Manager|Number
- value (Number)
- Returns Manager|Number
- value (Number)
- Returns Manager|Number
- value (Number)
- Returns Manager|Number
- callback (Function)
- Returns Manager
- nsp (String)
- options (Object)
- Returns Socket
- error (Object) error object
- attempt (Number) reconnection attempt number
- attempt (Number) reconnection attempt number
- attempt (Number) reconnection attempt number
- error (Object) error object
- ms (Number) number of ms elapsed since ping packet (i.e.: latency).
- (String)
- (Boolean)
- (Boolean)
- Returns Socket
- args
- ack (Function)
- Returns Socket
- eventName (String)
- args
- ack (Function)
- Returns Socket
- eventName (String)
- callback (Function)
- Returns Socket
- value (Boolean)
- Returns Socket
- Returns Socket
- connect,
- disconnect
- error.
- reason (String)
- error (Object) error object
- error (Object) error object
- attempt (Number) reconnection attempt number
- attempt (Number) reconnection attempt number
- attempt (Number) reconnection attempt number
- error (Object) error object
- ms (Number) number of ms elapsed since ping packet (i.e.: latency).
```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io('http://localhost');</script>
```

```js
const io = require('socket.io-client');// or with import syntaximport io from 'socket.io-client';
```

```js
const io = require("socket.io-client");const socket = io("ws://example.com/my-namespace", {  reconnectionDelayMax: 10000,  query: {    auth: "123"  }});
```

```js
const { Manager } = require("socket.io-client");const manager = new Manager("ws://example.com", {  reconnectionDelayMax: 10000});const socket = manager.socket("/my-namespace", {  query: {    auth: "123"  }});
```

```js
const socket = io();const adminSocket = io('/admin');// a single connection will be established
```

```js
const socket = io();const adminSocket = io('/admin', { forceNew: true });// will create two distinct connections
```

```js
const socket = io();const socket2 = io();// will also create two distinct connections
```

```js
const socket = io('http://localhost', {  path: '/myownpath'});// server-sideconst io = require('socket.io')({  path: '/myownpath'});
```

```js
const socket = io('http://localhost/admin', {  path: '/mypath'});
```

```js
const socket = io('http://localhost?token=abc');// server-sideconst io = require('socket.io')();// middlewareio.use((socket, next) => {  let token = socket.handshake.query.token;  if (isValid(token)) {    return next();  }  return next(new Error('authentication error'));});// thenio.on('connection', (socket) => {  let token = socket.handshake.query.token;  // ...});
```

```js
const socket = io({  query: {    token: 'cde'  }});
```

```js
socket.on('reconnect_attempt', () => {  socket.io.opts.query = {    token: 'fgh'  }});
```

```js
const socket = io({  transportOptions: {    polling: {      extraHeaders: {        'x-clientid': 'abc'      }    }  }});// server-sideconst io = require('socket.io')();// middlewareio.use((socket, next) => {  let clientId = socket.handshake.headers['x-clientid'];  if (isValid(clientId)) {    return next();  }  return next(new Error('authentication error'));});
```

```js
const socket = io({  transports: ['websocket']});// on reconnection, reset the transports option, as the Websocket// connection may have failed (caused by proxy, firewall, browser, ...)socket.on('reconnect_attempt', () => {  socket.io.opts.transports = ['polling', 'websocket'];});
```

```js
const parser = require('socket.io-msgpack-parser'); // or require('socket.io-json-parser')const socket = io({  parser: parser});// the server-side must have the same parser, to be able to communicateconst io = require('socket.io')({  parser: parser});
```

```js
// server-sideconst fs = require('fs');const server = require('https').createServer({  key: fs.readFileSync('server-key.pem'),  cert: fs.readFileSync('server-cert.pem')});const io = require('socket.io')(server);server.listen(3000);// client-sideconst socket = io({  // option 1  ca: fs.readFileSync('server-cert.pem'),  // option 2. WARNING: it leaves you vulnerable to MITM attacks!  rejectUnauthorized: false});
```

```js
socket.emit('hello', { a: 'b', c: [] });socket.on('hey', (...args) => {  // ...});
```

```js
const socket = io('http://localhost');console.log(socket.id); // undefinedsocket.on('connect', () => {  console.log(socket.id); // 'G5p5...'});
```

```js
const socket = io('http://localhost');socket.on('connect', () => {  console.log(socket.connected); // true});
```

```js
const socket = io('http://localhost');socket.on('connect', () => {  console.log(socket.disconnected); // false});
```

```js
const socket = io({  autoConnect: false});// ...socket.open();
```

```js
socket.on('disconnect', () => {  socket.open();});
```

```js
socket.emit('hello', 'world');socket.emit('with-binary', 1, '2', { 3: '4', 5: Buffer.from([6, 7, 8]) });
```

```js
socket.emit('ferret', 'tobi', (data) => {  console.log(data); // data will be 'woot'});// server://  io.on('connection', (socket) => {//    socket.on('ferret', (name, fn) => {//      fn('woot');//    });//  });
```

```js
socket.on('news', (data) => {  console.log(data);});// with multiple argumentssocket.on('news', (arg1, arg2, arg3, arg4) => {  // ...});// with callbacksocket.on('news', (cb) => {  cb(0);});
```

```js
socket.compress(false).emit('an event', { some: 'data' });
```

```js
socket.binary(false).emit('an event', { some: 'data' });
```

```js
socket.on('connect', () => {  // ...});// note: you should register event handlers outside of connect,// so they are not registered again on reconnectionsocket.on('myevent', () => {  // ...});
```

```js
socket.on('disconnect', (reason) => {  if (reason === 'io server disconnect') {    // the disconnection was initiated by the server, you need to reconnect manually    socket.connect();  }  // else the socket will automatically try to reconnect});
```

```js
socket.on('error', (error) => {  // ...});
```

```js
socket.on('connect_error', (error) => {  // ...});
```

```js
socket.on('connect_timeout', (timeout) => {  // ...});
```

```js
socket.on('reconnect', (attemptNumber) => {  // ...});
```

```js
socket.on('reconnect_attempt', (attemptNumber) => {  // ...});
```

```js
socket.on('reconnecting', (attemptNumber) => {  // ...});
```

```js
socket.on('reconnect_error', (error) => {  // ...});
```

```js
socket.on('reconnect_failed', () => {  // ...});
```

```js
socket.on('ping', () => {  // ...});
```

```js
socket.on('pong', (latency) => {  // ...});
```

```js
require('socket.io-client')
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io('http://localhost');</script>
```

```js
const io = require('socket.io-client');// or with import syntaximport io from 'socket.io-client';
```

```js
url
```

```js
window.location.host
```

```js
options
```

```js
forceNew
```

```js
Socket
```

```js
Manager
```

```js
Manager
```

```js
multiplex
```

```js
false
```

```js
'force new connection': true
```

```js
forceNew: true
```

```js
Socket
```

```js
url
```

```js
http://localhost/users
```

```js
http://localhost
```

```js
/users
```

```js
query
```

```js
http://localhost/users?token=abc
```

```js
const io = require("socket.io-client");const socket = io("ws://example.com/my-namespace", {  reconnectionDelayMax: 10000,  query: {    auth: "123"  }});
```

```js
const { Manager } = require("socket.io-client");const manager = new Manager("ws://example.com", {  reconnectionDelayMax: 10000});const socket = manager.socket("/my-namespace", {  query: {    auth: "123"  }});
```

```js
options
```

```js
const socket = io();const adminSocket = io('/admin');// a single connection will be established
```

```js
forceNew
```

```js
const socket = io();const adminSocket = io('/admin', { forceNew: true });// will create two distinct connections
```

```js
const socket = io();const socket2 = io();// will also create two distinct connections
```

```js
path
```

```js
const socket = io('http://localhost', {  path: '/myownpath'});// server-sideconst io = require('socket.io')({  path: '/myownpath'});
```

```js
localhost/myownpath/?EIO=3&transport=polling&sid=<id>
```

```js
const socket = io('http://localhost/admin', {  path: '/mypath'});
```

```js
admin
```

```js
mypath
```

```js
localhost/mypath/?EIO=3&transport=polling&sid=<id>
```

```js
const socket = io('http://localhost?token=abc');// server-sideconst io = require('socket.io')();// middlewareio.use((socket, next) => {  let token = socket.handshake.query.token;  if (isValid(token)) {    return next();  }  return next(new Error('authentication error'));});// thenio.on('connection', (socket) => {  let token = socket.handshake.query.token;  // ...});
```

```js
const socket = io({  query: {    token: 'cde'  }});
```

```js
socket.on('reconnect_attempt', () => {  socket.io.opts.query = {    token: 'fgh'  }});
```

```js
extraHeaders
```

```js
polling
```

```js
websocket
```

```js
const socket = io({  transportOptions: {    polling: {      extraHeaders: {        'x-clientid': 'abc'      }    }  }});// server-sideconst io = require('socket.io')();// middlewareio.use((socket, next) => {  let clientId = socket.handshake.headers['x-clientid'];  if (isValid(clientId)) {    return next();  }  return next(new Error('authentication error'));});
```

```js
websocket
```

```js
const socket = io({  transports: ['websocket']});// on reconnection, reset the transports option, as the Websocket// connection may have failed (caused by proxy, firewall, browser, ...)socket.on('reconnect_attempt', () => {  socket.io.opts.transports = ['polling', 'websocket'];});
```

```js
Blob
```

```js
File
```

```js
const parser = require('socket.io-msgpack-parser'); // or require('socket.io-json-parser')const socket = io({  parser: parser});// the server-side must have the same parser, to be able to communicateconst io = require('socket.io')({  parser: parser});
```

```js
// server-sideconst fs = require('fs');const server = require('https').createServer({  key: fs.readFileSync('server-key.pem'),  cert: fs.readFileSync('server-cert.pem')});const io = require('socket.io')(server);server.listen(3000);// client-sideconst socket = io({  // option 1  ca: fs.readFileSync('server-cert.pem'),  // option 2. WARNING: it leaves you vulnerable to MITM attacks!  rejectUnauthorized: false});
```

```js
Manager
```

```js
Manager
```

```js
Manager
```

```js
url
```

```js
options
```

```js
Manager
```

```js
path
```

```js
/socket.io
```

```js
reconnection
```

```js
true
```

```js
reconnectionAttempts
```

```js
Infinity
```

```js
reconnectionDelay
```

```js
1000
```

```js
randomizationFactor
```

```js
reconnectionDelayMax
```

```js
5000
```

```js
randomizationFactor
```

```js
0.5
```

```js
timeout
```

```js
20000
```

```js
connect_error
```

```js
connect_timeout
```

```js
autoConnect
```

```js
true
```

```js
manager.open
```

```js
query
```

```js
socket.handshake.query
```

```js
parser
```

```js
Parser
```

```js
upgrade
```

```js
true
```

```js
forceJSONP
```

```js
false
```

```js
jsonp
```

```js
true
```

```js
forceBase64
```

```js
false
```

```js
enablesXDR
```

```js
false
```

```js
false
```

```js
timestampRequests
```

```js
false
```

```js
timestampParam
```

```js
policyPort
```

```js
843
```

```js
transports
```

```js
['polling', 'websocket']
```

```js
Engine
```

```js
transportOptions
```

```js
rememberUpgrade
```

```js
false
```

```js
onlyBinaryUpgrades
```

```js
false
```

```js
requestTimeout
```

```js
protocols
```

```js
agent
```

```js
false
```

```js
http.Agent
```

```js
pfx
```

```js
key
```

```js
passphrase
```

```js
cert
```

```js
ciphers
```

```js
rejectUnauthorized
```

```js
false
```

```js
perMessageDeflate
```

```js
true
```

```js
false
```

```js
extraHeaders
```

```js
forceNode
```

```js
false
```

```js
localAddress
```

```js
value
```

```js
Manager|Boolean
```

```js
reconnection
```

```js
value
```

```js
Manager|Number
```

```js
reconnectionAttempts
```

```js
value
```

```js
Manager|Number
```

```js
reconnectionDelay
```

```js
value
```

```js
Manager|Number
```

```js
reconnectionDelayMax
```

```js
value
```

```js
Manager|Number
```

```js
timeout
```

```js
callback
```

```js
Manager
```

```js
autoConnect
```

```js
false
```

```js
callback
```

```js
nsp
```

```js
options
```

```js
Socket
```

```js
Socket
```

```js
error
```

```js
attempt
```

```js
attempt
```

```js
attempt
```

```js
error
```

```js
reconnectionAttempts
```

```js
ping
```

```js
Socket
```

```js
Socket
```

```js
Socket
```

```js
socket.emit('hello', { a: 'b', c: [] });socket.on('hey', (...args) => {  // ...});
```

```js
connect
```

```js
reconnect
```

```js
const socket = io('http://localhost');console.log(socket.id); // undefinedsocket.on('connect', () => {  console.log(socket.id); // 'G5p5...'});
```

```js
const socket = io('http://localhost');socket.on('connect', () => {  console.log(socket.connected); // true});
```

```js
const socket = io('http://localhost');socket.on('connect', () => {  console.log(socket.disconnected); // false});
```

```js
Socket
```

```js
const socket = io({  autoConnect: false});// ...socket.open();
```

```js
socket.on('disconnect', () => {  socket.open();});
```

```js
args
```

```js
ack
```

```js
Socket
```

```js
message
```

```js
eventName
```

```js
args
```

```js
ack
```

```js
Socket
```

```js
Buffer
```

```js
socket.emit('hello', 'world');socket.emit('with-binary', 1, '2', { 3: '4', 5: Buffer.from([6, 7, 8]) });
```

```js
ack
```

```js
socket.emit('ferret', 'tobi', (data) => {  console.log(data); // data will be 'woot'});// server://  io.on('connection', (socket) => {//    socket.on('ferret', (name, fn) => {//      fn('woot');//    });//  });
```

```js
eventName
```

```js
callback
```

```js
Socket
```

```js
socket.on('news', (data) => {  console.log(data);});// with multiple argumentssocket.on('news', (arg1, arg2, arg3, arg4) => {  // ...});// with callbacksocket.on('news', (cb) => {  cb(0);});
```

```js
hasListeners
```

```js
once
```

```js
off
```

```js
value
```

```js
Socket
```

```js
true
```

```js
true
```

```js
socket.compress(false).emit('an event', { some: 'data' });
```

```js
true
```

```js
false
```

```js
socket.binary(false).emit('an event', { some: 'data' });
```

```js
Socket
```

```js
Socket
```

```js
connect
```

```js
disconnect
```

```js
error
```

```js
socket.on('connect', () => {  // ...});// note: you should register event handlers outside of connect,// so they are not registered again on reconnectionsocket.on('myevent', () => {  // ...});
```

```js
reason
```

```js
io server disconnect
```

```js
io client disconnect
```

```js
ping timeout
```

```js
pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
socket.on('disconnect', (reason) => {  if (reason === 'io server disconnect') {    // the disconnection was initiated by the server, you need to reconnect manually    socket.connect();  }  // else the socket will automatically try to reconnect});
```

```js
error
```

```js
socket.on('error', (error) => {  // ...});
```

```js
error
```

```js
socket.on('connect_error', (error) => {  // ...});
```

```js
socket.on('connect_timeout', (timeout) => {  // ...});
```

```js
attempt
```

```js
socket.on('reconnect', (attemptNumber) => {  // ...});
```

```js
attempt
```

```js
socket.on('reconnect_attempt', (attemptNumber) => {  // ...});
```

```js
attempt
```

```js
socket.on('reconnecting', (attemptNumber) => {  // ...});
```

```js
error
```

```js
socket.on('reconnect_error', (error) => {  // ...});
```

```js
reconnectionAttempts
```

```js
socket.on('reconnect_failed', () => {  // ...});
```

```js
socket.on('ping', () => {  // ...});
```

```js
ping
```

```js
socket.on('pong', (latency) => {  // ...});
```

# https://socket.io/docs/v2/client-initialization

# Client Initialization

## From the same domain​

## From a different domain​

## Custom namespace​

## Notable options​

### transports option​

Once you have installed the Socket.IO client library, you can now init the client. The complete list of options can be found here.

In the examples below, the io object comes either from:

If your front is served on the same domain as your server, you can simply use:

The server URL will be deduced from the window.location object.

Additional options can be passed:

In case your front is not served from the same domain as your server, you have to pass the URL of your server.

In the examples above, the client will connect to the default namespace. Using only the default namespace should be sufficient for most use cases, but you can specify the namespace with:

You can find more details about namespaces here.

By default, the client will try to establish a WebSocket connection, and fall back to XHR/JSONP polling.

If you are sure the WebSocket connection will succeed, you can disable the polling transport:

In that case, due to the nature of the WebSocket connection, you can have several server instances without sticky sessions. More information here.

- Client
- Initialization
- the <script> import
- NPM
```js
<script src="/socket.io/socket.io.js"></script>
```

```js
// ES6 importimport io from 'socket.io-client';// CommonJSconst io = require('socket.io-client');
```

```js
const socket = io();
```

```js
// default valuesconst socket = io({  path: '/socket.io',  reconnection: true,  reconnectionAttempts: Infinity,  reconnectionDelay: 1000,  reconnectionDelayMax: 5000,  randomizationFactor: 0.5,  timeout: 20000,  autoConnect: true,  query: {},  // options of the Engine.IO client  upgrade: true,  forceJSONP: false,  jsonp: true,  forceBase64: false,  enablesXDR: false,  timestampRequests: true,  timestampParam: 't',  policyPort: 843,  transports: ['polling', 'websocket'],  transportOptions: {},  rememberUpgrade: false,  onlyBinaryUpgrades: false,  requestTimeout: 0,  protocols: [],  // options for Node.js  agent: false,  pfx: null,  key: null,  passphrase: null,  cert: null,  ca: null,  ciphers: [],  rejectUnauthorized: true,  perMessageDeflate: true,  forceNode: false,  localAddress: null,  // options for Node.js / React Native  extraHeaders: {},});
```

```js
const socket = io('https://server-domain.com');
```

```js
// same origin versionconst socket = io('/admin');// cross origin versionconst socket = io('https://server-domain.com/admin');
```

```js
const socket = io({  transports: ['websocket']});
```

```js
<script>
```

```js
<script src="/socket.io/socket.io.js"></script>
```

```js
// ES6 importimport io from 'socket.io-client';// CommonJSconst io = require('socket.io-client');
```

```js
const socket = io();
```

```js
// default valuesconst socket = io({  path: '/socket.io',  reconnection: true,  reconnectionAttempts: Infinity,  reconnectionDelay: 1000,  reconnectionDelayMax: 5000,  randomizationFactor: 0.5,  timeout: 20000,  autoConnect: true,  query: {},  // options of the Engine.IO client  upgrade: true,  forceJSONP: false,  jsonp: true,  forceBase64: false,  enablesXDR: false,  timestampRequests: true,  timestampParam: 't',  policyPort: 843,  transports: ['polling', 'websocket'],  transportOptions: {},  rememberUpgrade: false,  onlyBinaryUpgrades: false,  requestTimeout: 0,  protocols: [],  // options for Node.js  agent: false,  pfx: null,  key: null,  passphrase: null,  cert: null,  ca: null,  ciphers: [],  rejectUnauthorized: true,  perMessageDeflate: true,  forceNode: false,  localAddress: null,  // options for Node.js / React Native  extraHeaders: {},});
```

```js
const socket = io('https://server-domain.com');
```

```js
// same origin versionconst socket = io('/admin');// cross origin versionconst socket = io('https://server-domain.com/admin');
```

```js
transports
```

```js
const socket = io({  transports: ['websocket']});
```

# https://socket.io/docs/v2/client-installation

# Client Installation

## Compatibility​

## Release notes​

## Installation​

### Standalone build​

### From a CDN​

### From NPM​

Socket.IO does support IE9 and above. IE 6/7/8 are not supported anymore.

Browser compatibility is tested thanks to the awesome Sauce Labs platform:

The release notes of each version can be found in GitHub.

By default, the Socket.IO server exposes a client bundle at /socket.io/socket.io.js.

io will be registered as a global variable:

If you don't need this (see other options below), you can disable the functionality on the server side:

You can also include the client bundle from a CDN:

Socket.IO is also available from other CDN like jsDelivr and unpkg.

There are several bundles available:

The debug package allows to print debug information to the console. You can find more information here.

During development, we recommend to use the socket.io.dev.js bundle. By setting localStorage.debug = 'socket.io-client:socket', any event received by the client will be printed to the console.

For production, please use the socket.io.slim.js bundle, which is an optimized build excluding the debug package.

The Socket.IO client is compatible with bundlers like webpack or browserify.

The client can also be run from Node.js.

Note: for the reasons cited above, you may want to exclude debug from your browser bundle. With webpack, you can use webpack-remove-debug.

- Client
- Installation
```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
const io = require('socket.io')({  serveClient: false});
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>
```

```js
$ npm install socket.io-client
```

```js
/socket.io/socket.io.js
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
const io = require('socket.io')({  serveClient: false});
```

```js
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>
```

```js
socket.io.dev.js
```

```js
localStorage.debug = 'socket.io-client:socket'
```

```js
socket.io.slim.js
```

```js
$ npm install socket.io-client
```

# https://socket.io/docs/v2/emit-cheatsheet

# Emit cheatsheet

Note: The following events are reserved and should not be used as event names by your application:

- Documentation
- Emit cheatsheet
- connect
- connection
- connect_error
- connect_timeout
- error
- disconnect
- disconnecting
- newListener
- reconnect_attempt
- reconnecting
- reconnect_error
- reconnect_failed
- removeListener
- ping
- pong
```js
io.on('connection', onConnect);function onConnect(socket){  // sending to the client  socket.emit('hello', 'can you hear me?', 1, 2, 'abc');  // sending to all clients except sender  socket.broadcast.emit('broadcast', 'hello friends!');  // sending to all clients in 'game' room except sender  socket.to('game').emit('nice game', "let's play a game");  // sending to all clients in 'game1' and/or in 'game2' room, except sender  socket.to('game1').to('game2').emit('nice game', "let's play a game (too)");  // sending to all clients in 'game' room, including sender  io.in('game').emit('big-announcement', 'the game will start soon');  // sending to all clients in namespace 'myNamespace', including sender  io.of('myNamespace').emit('bigger-announcement', 'the tournament will start soon');  // sending to a specific room in a specific namespace, including sender  io.of('myNamespace').to('room').emit('event', 'message');  // sending to individual socketid (private message)  io.to(socketId).emit('hey', 'I just met you');  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.  // sending with acknowledgement  socket.emit('question', 'do you think so?', function (answer) {});  // sending without compression  socket.compress(false).emit('uncompressed', "that's rough");  // sending a message that might be dropped if the client is not ready to receive messages  socket.volatile.emit('maybe', 'do you really need it?');  // specifying whether the data to send has binary data  socket.binary(false).emit('what', 'I have no binaries!');  // sending to all clients on this node (when using multiple nodes)  io.local.emit('hi', 'my lovely babies');  // sending to all connected clients  io.emit('an event sent to all connected clients');};
```

```js
io.on('connection', onConnect);function onConnect(socket){  // sending to the client  socket.emit('hello', 'can you hear me?', 1, 2, 'abc');  // sending to all clients except sender  socket.broadcast.emit('broadcast', 'hello friends!');  // sending to all clients in 'game' room except sender  socket.to('game').emit('nice game', "let's play a game");  // sending to all clients in 'game1' and/or in 'game2' room, except sender  socket.to('game1').to('game2').emit('nice game', "let's play a game (too)");  // sending to all clients in 'game' room, including sender  io.in('game').emit('big-announcement', 'the game will start soon');  // sending to all clients in namespace 'myNamespace', including sender  io.of('myNamespace').emit('bigger-announcement', 'the tournament will start soon');  // sending to a specific room in a specific namespace, including sender  io.of('myNamespace').to('room').emit('event', 'message');  // sending to individual socketid (private message)  io.to(socketId).emit('hey', 'I just met you');  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.  // sending with acknowledgement  socket.emit('question', 'do you think so?', function (answer) {});  // sending without compression  socket.compress(false).emit('uncompressed', "that's rough");  // sending a message that might be dropped if the client is not ready to receive messages  socket.volatile.emit('maybe', 'do you really need it?');  // specifying whether the data to send has binary data  socket.binary(false).emit('what', 'I have no binaries!');  // sending to all clients on this node (when using multiple nodes)  io.local.emit('hi', 'my lovely babies');  // sending to all connected clients  io.emit('an event sent to all connected clients');};
```

```js
connect
```

```js
connection
```

```js
connect_error
```

```js
connect_timeout
```

```js
error
```

```js
disconnect
```

```js
disconnecting
```

```js
newListener
```

```js
reconnect_attempt
```

```js
reconnecting
```

```js
reconnect_error
```

```js
reconnect_failed
```

```js
removeListener
```

```js
ping
```

```js
pong
```

# https://socket.io/docs/v2/faq

# FAQ

## Can I use wildcards in events?​

## Prevent flooding from single connection?​

## Socket.IO with Apache Cordova?​

## Socket.IO on iOS?​

## Socket.IO on Android?​

## Usage with express-session​

Not in Socket.IO directly, but check out this plugin by Hao-kang Den. It provides a Socket.IO middleware to deal with wildcards.

Limit number of events by IP, uniqueUserId or/and socket.id with rate-limiter-flexible package.

Take a look at this tutorial.

Take a look at socket.io-client-swift.

Take a look at socket.io-client.java.

- Miscellaneous
- FAQ
```js
const express = require('express');const session = require('express-session');const app = express();const server = require('http').createServer(app);const io = require('socket.io')(server);const sessionMiddleware = session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }});// register middleware in Expressapp.use(sessionMiddleware);// register middleware in Socket.IOio.use((socket, next) => {  sessionMiddleware(socket.request, {}, next);  // sessionMiddleware(socket.request, socket.request.res, next); will not work with websocket-only  // connections, as 'socket.request.res' will be undefined in that case});io.on('connection', (socket) => {  const session = socket.request.session;  session.connections++;  session.save();});const port = process.env.PORT || 3000;server.listen(port, () => console.log('server listening on port ' + port));
```

```js
uniqueUserId
```

```js
socket.id
```

```js
const express = require('express');const session = require('express-session');const app = express();const server = require('http').createServer(app);const io = require('socket.io')(server);const sessionMiddleware = session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }});// register middleware in Expressapp.use(sessionMiddleware);// register middleware in Socket.IOio.use((socket, next) => {  sessionMiddleware(socket.request, {}, next);  // sessionMiddleware(socket.request, socket.request.res, next); will not work with websocket-only  // connections, as 'socket.request.res' will be undefined in that case});io.on('connection', (socket) => {  const session = socket.request.session;  session.connections++;  session.save();});const port = process.env.PORT || 3000;server.listen(port, () => console.log('server listening on port ' + port));
```

# https://socket.io/docs/v2/handling-cors

# Handling CORS

## Configuration​

## Troubleshooting​

As of Socket.IO v2, the server will automatically add the necessary headers in order to support Cross-Origin Resource Sharing (CORS)

The origins option should be used to provide a list of authorized domains:

Please note that by default, ALL domains are authorized. You should explicitly allow/disallow cross-origin requests in order to keep your application secure:

The handlePreflightRequest option can be used to customize the Access-Control-Allow-xxx headers sent in response to the preflight request.

Example with cookies (withCredentials) and additional headers:

If you have properly configured your server (see above), this could mean that your browser wasn't able to reach the Socket.IO server.

The following command:

should return something like:

If that's not the case, please check that your server is listening and is actually reachable on the given port.

- Server
- Handling CORS
- without CORS (server and client are served from the same domain):
- with CORS (server and client are served from distinct domains):
```js
const io = require("socket.io")(httpServer, {  origins: ["https://example.com"]});
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    callback(null, req.headers.origin === undefined); // cross-origin requests will not be allowed  }});
```

```js
io.origins(["http://localhost:3000"]); // for local developmentio.origins(["https://example.com"]);
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  origins: ["https://example.com"],  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": "https://example.com",      "Access-Control-Allow-Methods": "GET,POST",      "Access-Control-Allow-Headers": "my-custom-header",      "Access-Control-Allow-Credentials": true    });    res.end();  }});// client-sideconst io = require("socket.io-client");const socket = io("https://api.example.com", {  withCredentials: true,  transportOptions: {    polling: {      extraHeaders: {        "my-custom-header": "abcd"      }    }  }});
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=3&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
curl "https://api.example.com/socket.io/?EIO=3&transport=polling"
```

```js
96:0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}
```

```js
origins
```

```js
const io = require("socket.io")(httpServer, {  origins: ["https://example.com"]});
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    callback(null, req.headers.origin === undefined); // cross-origin requests will not be allowed  }});
```

```js
io.origins(["http://localhost:3000"]); // for local developmentio.origins(["https://example.com"]);
```

```js
handlePreflightRequest
```

```js
Access-Control-Allow-xxx
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  origins: ["https://example.com"],  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": "https://example.com",      "Access-Control-Allow-Methods": "GET,POST",      "Access-Control-Allow-Headers": "my-custom-header",      "Access-Control-Allow-Credentials": true    });    res.end();  }});// client-sideconst io = require("socket.io-client");const socket = io("https://api.example.com", {  withCredentials: true,  transportOptions: {    polling: {      extraHeaders: {        "my-custom-header": "abcd"      }    }  }});
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=3&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
curl "https://api.example.com/socket.io/?EIO=3&transport=polling"
```

```js
96:0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}
```

# https://socket.io/docs/v2/internals

# Internals overview

## Dependency graph​

## Under the hood​

### engine.io-parser​

### engine.io​

### engine.io-client​

### socket.io-adapter​

### socket.io-redis​

### socket.io-parser​

### socket.io​

### socket.io-client​

### Connection​

### Upgrade​

The Socket.IO codebase is split across several repositories:

The following diagram displays the relationships between each project:

Each project brings its own set of features:

This is the JavaScript parser for the engine.io protocol encoding, shared by both engine.io-client and engine.io.

The specification for the protocol can be found here: https://github.com/socketio/engine.io-protocol

Engine.IO is the implementation of transport-based cross-browser/cross-device bi-directional communication layer for Socket.IO.

Its main feature is the ability to swap transports on the fly. A connection (initiated by an engine.io-client counterpart) starts with XHR polling, but can then switch to WebSocket if possible.

It uses the engine.io-parser to encode/decode packets.

This is the client for Engine.IO, the implementation of transport-based cross-browser/cross-device bi-directional communication layer for Socket.IO.

It runs in both the browser (including HTML5 WebWorker) and Node.js.

It uses the engine.io-parser to encode/decode packets.

This is the default Socket.IO in-memory adapter class.

This module is not intended for end-user usage, but can be used as an interface to inherit from other adapters you might want to build, like socket.io-redis.

This is the adapter using the Redis Pub/Sub mechanism to broadcast messages between multiple nodes.

A socket.io encoder and decoder written in JavaScript complying with version 3 of socket.io-protocol. Used by socket.io and socket.io-client.

By default, it exposes a browser build of the client at /socket.io/socket.io.js.

It uses the socket.io-parser to encode/decode packets.

This is the client for Socket.IO. It relies on engine.io-client, which manages the transport swapping and the disconnection detection.

It handles reconnection automatically, in case the underlying connection is severed.

It uses the socket.io-parser to encode/decode packets.

The following steps take place:

on the client-side, a new engine.io-client instance is created

the engine.io-client instance tries to establish a polling transport

the content is then decoded by the engine.io-parser on the client-side

an open event is emitted at the engine.io-client level

a connect event is emitted at the socket.io-client level

Once all the buffers of the existing transport (XHR polling) are flushed, an upgrade gets tested on the side by sending a probe.

a "ping" packet is sent by the client in a WebSocket frame, encoded as 2probe by the engine.io-parser, with 2 being the "ping" message type.

the server responds with a "pong" packet, encoded as 3probe, with 3 being the "pong" message type.

upon receiving the "pong" packet, the upgrade is considered complete and all following messages go through the new transport.

- Advanced
- Internals overview
- https://github.com/socketio/socket.io
- https://github.com/socketio/socket.io-client
- https://github.com/socketio/socket.io-parser
- https://github.com/socketio/socket.io-adapter
- https://github.com/socketio/socket.io-redis
- https://github.com/socketio/engine.io
- https://github.com/socketio/engine.io-client
- https://github.com/socketio/engine.io-parser
- on the client-side, a new engine.io-client instance is created
- the engine.io-client instance tries to establish a polling transport
- the engine.io server responds with:
- the content is encoded by the engine.io-parser as:
- the content is then decoded by the engine.io-parser on the client-side
- an open event is emitted at the engine.io-client level
- a connect event is emitted at the socket.io-client level
- a "ping" packet is sent by the client in a WebSocket frame, encoded as 2probe by the engine.io-parser, with 2 being the "ping" message type.
- the server responds with a "pong" packet, encoded as 3probe, with 3 being the "pong" message type.
- upon receiving the "pong" packet, the upgrade is considered complete and all following messages go through the new transport.
```js
const client = io('https://myhost.com');
```

```js
GET https://myhost.com/socket.io/?EIO=3&transport=polling&t=ML4jUwU&b64=1with:  "EIO=3"               # the current version of the Engine.IO protocol  "transport=polling"   # the transport being established  "t=ML4jUwU&b64=1"     # a hashed timestamp for cache-busting
```

```js
{  "type": "open",  "data": {    "sid": "36Yib8-rSutGQYLfAAAD",  // the unique session id    "upgrades": ["websocket"],      // the list of possible transport upgrades    "pingInterval": 25000,          // the 1st parameter for the heartbeat mechanism    "pingTimeout": 5000             // the 2nd parameter for the heartbeat mechanism  }}
```

```js
'96:0{"sid":"hLOEJXN07AE0GQCNAAAB","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}2:40'with:  "96"  # the length of the first message  ":"   # a separator between length and content  "0"   # the "open" message type  '{"sid":"hLOEJXN07AE0GQCNAAAB","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}' # the JSON-encoded handshake data  "2"   # the length of the second message  ":"   # a separator between length and content  "4"   # the "message" message type  "0"   # the "open" message type in Socket.IO protocol
```

```js
GET wss://myhost.com/socket.io/?EIO=3&transport=websocket&sid=36Yib8-rSutGQYLfAAADwith:  "EIO=3"                     # again, the current version of the Engine.IO protocol  "transport=websocket"       # the new transport being probed  "sid=36Yib8-rSutGQYLfAAAD"  # the unique session id
```

```js
Rooms
```

```js
Namespaces
```

```js
/socket.io/socket.io.js
```

```js
const client = io('https://myhost.com');
```

```js
engine.io-client
```

```js
engine.io-client
```

```js
polling
```

```js
GET https://myhost.com/socket.io/?EIO=3&transport=polling&t=ML4jUwU&b64=1with:  "EIO=3"               # the current version of the Engine.IO protocol  "transport=polling"   # the transport being established  "t=ML4jUwU&b64=1"     # a hashed timestamp for cache-busting
```

```js
engine.io
```

```js
{  "type": "open",  "data": {    "sid": "36Yib8-rSutGQYLfAAAD",  // the unique session id    "upgrades": ["websocket"],      // the list of possible transport upgrades    "pingInterval": 25000,          // the 1st parameter for the heartbeat mechanism    "pingTimeout": 5000             // the 2nd parameter for the heartbeat mechanism  }}
```

```js
engine.io-parser
```

```js
'96:0{"sid":"hLOEJXN07AE0GQCNAAAB","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}2:40'with:  "96"  # the length of the first message  ":"   # a separator between length and content  "0"   # the "open" message type  '{"sid":"hLOEJXN07AE0GQCNAAAB","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}' # the JSON-encoded handshake data  "2"   # the length of the second message  ":"   # a separator between length and content  "4"   # the "message" message type  "0"   # the "open" message type in Socket.IO protocol
```

```js
engine.io-parser
```

```js
open
```

```js
engine.io-client
```

```js
connect
```

```js
socket.io-client
```

```js
GET wss://myhost.com/socket.io/?EIO=3&transport=websocket&sid=36Yib8-rSutGQYLfAAADwith:  "EIO=3"                     # again, the current version of the Engine.IO protocol  "transport=websocket"       # the new transport being probed  "sid=36Yib8-rSutGQYLfAAAD"  # the unique session id
```

```js
2probe
```

```js
engine.io-parser
```

```js
3probe
```

# https://socket.io/docs/v2/logging-and-debugging

# Logging and debugging

## Available debugging scopes​

## Removing debug from your browser bundle​

Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called debug by TJ Holowaychuk.

Before 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.

The basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the DEBUG env variable (Node.JS) or the localStorage.debug property (Browsers).

You can see it in action for example on our homepage:

The best way to see what information is available is to use the *:

or in the browser:

And then filter by the scopes you’re interested in. You can prefix the * with scopes, separated by comma if there is more than one. For example, to only see debug statements from the socket.io client on Node.js try this:

To see all debug messages from the engine and socket.io:

While useful during development, the debug package adds an extra weight to the final bundle (about 4KB minified and gzipped), that's why it is excluded from the slim bundle (more details about the various browser bundles can be found here).

If you are using webpack, you can remove it with webpack-remove-debug:

- Documentation
- Logging and debugging
```js
DEBUG=* node yourfile.js
```

```js
localStorage.debug = '*';
```

```js
DEBUG=socket.io:client* node yourfile.js
```

```js
DEBUG=engine,socket.io* node yourfile.js
```

```js
{  module: {    rules: [      {        test: /\.js$/,        loader: 'webpack-remove-debug'      }    ]  }}
```

```js
DEBUG
```

```js
localStorage.debug
```

```js
DEBUG=* node yourfile.js
```

```js
localStorage.debug = '*';
```

```js
DEBUG=socket.io:client* node yourfile.js
```

```js
DEBUG=engine,socket.io* node yourfile.js
```

```js
{  module: {    rules: [      {        test: /\.js$/,        loader: 'webpack-remove-debug'      }    ]  }}
```

# https://socket.io/docs/v2/migrating-from-0-9

# Migrating from 0.9

## Authentication differences​

## Log differences​

## Shortcuts​

## Configuration differences​

## Parser / Protocol differences​

### Socket.io uses middleware now​

### … so its cleaner to do auth via middleware now​

### Namespace authorization?​

### Logging is now based on debug​

### Broadcasting to all clients in default namespace​

### Starting the server​

### io.set is gone​

### Setting resource path​

### Difference 1 – packet encoding​

### Difference 2 – packet decoding​

You can give a Socket.io server arbitrary functions via io.use() that are run when a socket is created. Check out this example:

The old io.set() and io.get() methods are deprecated and only supported for backwards compatibility. Here is a translation of an old authorization example into middleware-style.

vs.

To print all debug logging, set the environment variable DEBUG to . ie: `DEBUG= node index.js`

To print only socket.io related logging: DEBUG=socket.io:* node index.js.

To print logging only from the socket object: DEBUG=socket.io:socket node index.js.

This pattern should hopefully be making sense at this point. The names of the files in socket.io/lib are equivalent to their debug names.

Debug also works in the browser; logs are persisted to localstorage.

To use: open the developer console and type localStorage.debug = 'socket.io:*' (or any debug level) and then refresh the page. Everything is logged until you run localStorage.debug = ''

See more at the debug documentation here.

In general there are some new shortcuts for common things. The old versions should still work, but shortcuts are nice.

Previously:

Now:

Neat. Note that in both cases, these messages reach all clients connected to the default ‘/’ namespace, but not clients in other namespaces.

Previously:

Now:

Instead do configuration in server initialization like this:

Options like log-level are gone. io.set('transports'), io.set('heartbeat interval'), io.set('heartbeat timeout', and io.set('resource') are still supported for backwards compatibility.

The previous resource option is equivalent to the new path option, but needs a / in the beginning. For example, the following configuration:

becomes:

This is only relevant for updating things like socket.io implementations in other languages, custom socket.io clients, etc.

Parsing is now class based and asynchronous. Instead of returning a single encoded string, encode calls callback with an array of encodings as the only argument. Each encoding should be written to the transport in order. This is more flexible and makes binary data transport work. Here’s an example:

vs.

Decoding takes things a step further and is event-based. This is done because some objects (binary-containing) are both encoded and decoded in multiple parts. This example should help:

vs.

- Migrations
- Migrating from 0.9
```js
var srv = require('http').createServer();var io = require('socket.io')(srv);var run = 0;io.use(function(socket, next){  run++; // 0 -> 1  next();});io.use(function(socket, next) {  run++; // 1 -> 2  next();});var socket = require('socket.io-client')();socket.on('connect', function(){  // run == 2 at this time});
```

```js
io.set('authorization', function (handshakeData, callback) {  // make sure the handshake data looks good  callback(null, true); // error first, 'authorized' boolean second });
```

```js
io.use(function(socket, next) {  var handshakeData = socket.request;  // make sure the handshake data looks good as before  // if error do this:    // next(new Error('not authorized'));  // else just call next  next();});
```

```js
io.of('/namespace').use(function(socket, next) {  var handshakeData = socket.request;  next();});
```

```js
io.sockets.emit('eventname', 'eventdata');
```

```js
io.emit('eventname', 'eventdata');
```

```js
var io = require('socket.io');var socket = io.listen(80, { /* options */ });
```

```js
var io = require('socket.io');var socket = io({ /* options */ });
```

```js
var socket = require('socket.io')({  // options go here});
```

```js
var socket = io.connect('localhost:3000', {  'resource': 'path/to/socket.io';});
```

```js
var socket = io.connect('localhost:3000', {  'path': '/path/to/socket.io';});
```

```js
var encoding = parser.encode(packet);console.log(encoding); // fully encoded packet`
```

```js
var encoder = new parser.Encoder();encoder.encode(packet, function(encodings) {  for (var i = 0; i &lt; encodings.length; i++) {    console.log(encodings[i]); // encoded parts of the packet  }});
```

```js
var packet = parser.decode(decoding);console.log(packet); // formed socket.io packet to handle
```

```js
var decoder = new parser.Decoder();decoder.on('decoded', function(packet) {  console.log(packet); // formed socket.io packet to handle});decoder.add(encodings[0]); // say encodings is array of two encodings received from transportdecoder.add(encodings[1]); // after adding the last element, 'decoded' is emitted from decoder
```

```js
io.use()
```

```js
var srv = require('http').createServer();var io = require('socket.io')(srv);var run = 0;io.use(function(socket, next){  run++; // 0 -> 1  next();});io.use(function(socket, next) {  run++; // 1 -> 2  next();});var socket = require('socket.io-client')();socket.on('connect', function(){  // run == 2 at this time});
```

```js
io.set()
```

```js
io.get()
```

```js
io.set('authorization', function (handshakeData, callback) {  // make sure the handshake data looks good  callback(null, true); // error first, 'authorized' boolean second });
```

```js
io.use(function(socket, next) {  var handshakeData = socket.request;  // make sure the handshake data looks good as before  // if error do this:    // next(new Error('not authorized'));  // else just call next  next();});
```

```js
io.of('/namespace').use(function(socket, next) {  var handshakeData = socket.request;  next();});
```

```js
DEBUG=socket.io:* node index.js
```

```js
DEBUG=socket.io:socket node index.js
```

```js
localStorage.debug = 'socket.io:*'
```

```js
localStorage.debug = ''
```

```js
io.sockets.emit('eventname', 'eventdata');
```

```js
io.emit('eventname', 'eventdata');
```

```js
var io = require('socket.io');var socket = io.listen(80, { /* options */ });
```

```js
var io = require('socket.io');var socket = io({ /* options */ });
```

```js
var socket = require('socket.io')({  // options go here});
```

```js
io.set('transports')
```

```js
io.set('heartbeat interval')
```

```js
io.set('heartbeat timeout'
```

```js
io.set('resource')
```

```js
resource
```

```js
path
```

```js
var socket = io.connect('localhost:3000', {  'resource': 'path/to/socket.io';});
```

```js
var socket = io.connect('localhost:3000', {  'path': '/path/to/socket.io';});
```

```js
var encoding = parser.encode(packet);console.log(encoding); // fully encoded packet`
```

```js
var encoder = new parser.Encoder();encoder.encode(packet, function(encodings) {  for (var i = 0; i &lt; encodings.length; i++) {    console.log(encodings[i]); // encoded parts of the packet  }});
```

```js
var packet = parser.decode(decoding);console.log(packet); // formed socket.io packet to handle
```

```js
var decoder = new parser.Decoder();decoder.on('decoded', function(packet) {  console.log(packet); // formed socket.io packet to handle});decoder.add(encodings[0]); // say encodings is array of two encodings received from transportdecoder.add(encodings[1]); // after adding the last element, 'decoded' is emitted from decoder
```

# https://socket.io/docs/v2/namespaces

# Namespaces

## Default namespace​

## Custom namespaces​

## Namespace middleware​

## Handling middleware error​

## Compatibility with Express middleware​

A Namespace is a communication channel that allows you to split the logic of your application over a single shared connection.

Possible use cases:

We call the default namespace / and it’s the one Socket.IO clients connect to by default, and the one the server listens to by default.

This namespace is identified by io.sockets or simply io:

Each namespace emits a connection event that receives each Socket instance as a parameter

To set up a custom namespace, you can call the of function on the server-side:

On the client side, you tell Socket.IO client to connect to that namespace:

Important note: The namespace is an implementation detail of the Socket.IO protocol, and is not related to the actual URL of the underlying transport, which defaults to /socket.io/….

A middleware is a function that gets executed for every incoming Socket, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware. A Socket.IO middleware is very similar to what you can find in Express.

You can register several middleware functions for the same namespace. They will be executed sequentially:

If the next method is called with an Error object, the client will receive an error event.

Most existing Express middleware modules should be compatible with Socket.IO, you just need a little wrapper function to make the method signatures match:

The middleware functions that end the request-response cycle and do not call next() will not work though.

Example with express-session:

Example with Passport:

A complete example with Passport can be found here.

- Server
- Namespaces
- you want to create an admin namespace that only authorized users have access to, so the logic related to those users is separated from the rest of the application
- your application has multiple tenants so you want to dynamically create one namespace per tenant
```js
const adminNamespace = io.of('/admin');adminNamespace.use((socket, next) => {  // ensure the user has sufficient rights  next();});adminNamespace.on('connection', socket => {  socket.on('delete user', () => {    // ...  });});
```

```js
const workspaces = io.of(/^\/\w+$/);workspaces.on('connection', socket => {  const workspace = socket.nsp;  workspace.emit('hello');});// this middleware will be assigned to each namespaceworkspaces.use((socket, next) => {  // ensure the user has access to the workspace  next();});
```

```js
// the following two will emit to all the sockets connected to `/`io.sockets.emit('hi', 'everyone');io.emit('hi', 'everyone'); // short form
```

```js
io.on('connection', socket => {  socket.on('disconnect', () => {});});
```

```js
const nsp = io.of('/my-namespace');nsp.on('connection', socket => {  console.log('someone connected');});nsp.emit('hi', 'everyone!');
```

```js
const socket = io('/my-namespace');
```

```js
// registers a middleware for the default namespaceio.use((socket, next) => {  if (isValid(socket.request)) {    next();  } else {    next(new Error('invalid'));  }});// registers a middleware for a custom namespaceio.of('/admin').use(async (socket, next) => {  const user = await fetchUser(socket.handshake.query);  if (user.isAdmin) {    socket.user = user;    next();  } else {    next(new Error('forbidden'));  }});
```

```js
io.use((socket, next) => {  next();});io.use((socket, next) => {  next(new Error('thou shall not pass'));});io.use((socket, next) => {  // not executed, since the previous middleware has returned an error  next();});
```

```js
import io from 'socket.io-client';const socket = io();socket.on('error', (reason) => {  console.log(reason); // prints the message associated with the error, e.g. "thou shall not pass" in the example above});
```

```js
const wrap = middleware => (socket, next) => middleware(socket.request, {}, next);
```

```js
const session = require('express-session');io.use(wrap(session({ secret: 'cats' })));io.on('connection', (socket) => {  const session = socket.request.session;});
```

```js
const session = require('express-session');const passport = require('passport');io.use(wrap(session({ secret: 'cats' })));io.use(wrap(passport.initialize()));io.use(wrap(passport.session()));io.use((socket, next) => {  if (socket.request.user) {    next();  } else {    next(new Error('unauthorized'))  }});
```

```js
const adminNamespace = io.of('/admin');adminNamespace.use((socket, next) => {  // ensure the user has sufficient rights  next();});adminNamespace.on('connection', socket => {  socket.on('delete user', () => {    // ...  });});
```

```js
const workspaces = io.of(/^\/\w+$/);workspaces.on('connection', socket => {  const workspace = socket.nsp;  workspace.emit('hello');});// this middleware will be assigned to each namespaceworkspaces.use((socket, next) => {  // ensure the user has access to the workspace  next();});
```

```js
io.sockets
```

```js
// the following two will emit to all the sockets connected to `/`io.sockets.emit('hi', 'everyone');io.emit('hi', 'everyone'); // short form
```

```js
connection
```

```js
Socket
```

```js
io.on('connection', socket => {  socket.on('disconnect', () => {});});
```

```js
const nsp = io.of('/my-namespace');nsp.on('connection', socket => {  console.log('someone connected');});nsp.emit('hi', 'everyone!');
```

```js
const socket = io('/my-namespace');
```

```js
/socket.io/…
```

```js
// registers a middleware for the default namespaceio.use((socket, next) => {  if (isValid(socket.request)) {    next();  } else {    next(new Error('invalid'));  }});// registers a middleware for a custom namespaceio.of('/admin').use(async (socket, next) => {  const user = await fetchUser(socket.handshake.query);  if (user.isAdmin) {    socket.user = user;    next();  } else {    next(new Error('forbidden'));  }});
```

```js
io.use((socket, next) => {  next();});io.use((socket, next) => {  next(new Error('thou shall not pass'));});io.use((socket, next) => {  // not executed, since the previous middleware has returned an error  next();});
```

```js
next
```

```js
error
```

```js
import io from 'socket.io-client';const socket = io();socket.on('error', (reason) => {  console.log(reason); // prints the message associated with the error, e.g. "thou shall not pass" in the example above});
```

```js
const wrap = middleware => (socket, next) => middleware(socket.request, {}, next);
```

```js
next()
```

```js
const session = require('express-session');io.use(wrap(session({ secret: 'cats' })));io.on('connection', (socket) => {  const session = socket.request.session;});
```

```js
const session = require('express-session');const passport = require('passport');io.use(wrap(session({ secret: 'cats' })));io.use(wrap(passport.initialize()));io.use(wrap(passport.session()));io.use((socket, next) => {  if (socket.request.user) {    next();  } else {    next(new Error('unauthorized'))  }});
```

# https://socket.io/docs/v2/rooms

# Rooms

## Joining and leaving​

## Default room​

## Sample use cases​

## Disconnection​

## Sending messages from the outside-world​

Within each Namespace, you can define arbitrary channels called "Rooms" that sockets can join and leave.

This is useful to broadcast data to a subset of sockets:

You can call join to subscribe the socket to a given channel:

And then simply use to or in (they are the same) when broadcasting or emitting:

You can emit to several rooms at the same time:

In that case, an union is performed: every socket that is at least in one of the rooms will get the event once (even if the socket is in two or more rooms).

You can also broadcast to a room from a given socket:

In that case, every socket in the room excluding the sender will get the event.

To leave a channel you call leave in the same fashion as join. Both methods are asynchronous and accept a callback argument.

Each Socket in Socket.IO is identified by a random, unguessable, unique identifier Socket#id. For your convenience, each socket automatically joins a room identified by its own id.

This makes it easy to broadcast messages to other sockets:

Upon disconnection, sockets leave all the channels they were part of automatically, and no special teardown is needed on your part.

You can fetch the rooms the Socket was in by listening to the disconnecting event:

In some cases, you might want to emit events to sockets in Socket.IO namespaces / rooms from outside the context of your Socket.IO processes.

There are several ways to tackle this problem, like implementing your own channel to send messages into the process.

To facilitate this use case, we created two modules:

By implementing the Redis Adapter:

you can then emit messages from any other process to any channel

- Server
- Rooms
- broadcast data to each device / tab of a given user
- send notifications about a given entity
- socket.io-redis
- socket.io-emitter
```js
io.on('connection', socket => {  socket.join('some room');});
```

```js
io.to('some room').emit('some event');
```

```js
io.to('room1').to('room2').to('room3').emit('some event');
```

```js
io.on('connection', function(socket){  socket.to('some room').emit('some event');});
```

```js
io.on('connection', socket => {  socket.on('say to someone', (id, msg) => {    socket.to(id).emit('my message', msg);  });});
```

```js
io.on('connection', async (socket) => {  const userId = await computeUserIdFromHeaders(socket);  socket.join(userId);  // and then later  io.to(userId).emit('hi');});
```

```js
io.on('connection', async (socket) => {  const projects = await fetchProjects(socket);  projects.forEach(project => socket.join('project:' + project.id));  socket.on('update project', async (payload) => {    const project = await updateProject(payload);    io.to('project:' + project.id).emit('project updated', project);  });});
```

```js
io.on('connection', socket => {  socket.on('disconnecting', () => {    const rooms = Object.keys(socket.rooms);    // the rooms array contains at least the socket ID  });  socket.on('disconnect', () => {    // socket.rooms === {}  });});
```

```js
const io = require('socket.io')(3000);const redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
const io = require('socket.io-emitter')({ host: '127.0.0.1', port: 6379 });setInterval(function(){  io.emit('time', new Date);}, 5000);
```

```js
join
```

```js
leave
```

```js
join
```

```js
io.on('connection', socket => {  socket.join('some room');});
```

```js
io.to('some room').emit('some event');
```

```js
io.to('room1').to('room2').to('room3').emit('some event');
```

```js
io.on('connection', function(socket){  socket.to('some room').emit('some event');});
```

```js
leave
```

```js
join
```

```js
callback
```

```js
Socket
```

```js
Socket#id
```

```js
io.on('connection', socket => {  socket.on('say to someone', (id, msg) => {    socket.to(id).emit('my message', msg);  });});
```

```js
io.on('connection', async (socket) => {  const userId = await computeUserIdFromHeaders(socket);  socket.join(userId);  // and then later  io.to(userId).emit('hi');});
```

```js
io.on('connection', async (socket) => {  const projects = await fetchProjects(socket);  projects.forEach(project => socket.join('project:' + project.id));  socket.on('update project', async (payload) => {    const project = await updateProject(payload);    io.to('project:' + project.id).emit('project updated', project);  });});
```

```js
leave
```

```js
disconnecting
```

```js
io.on('connection', socket => {  socket.on('disconnecting', () => {    const rooms = Object.keys(socket.rooms);    // the rooms array contains at least the socket ID  });  socket.on('disconnect', () => {    // socket.rooms === {}  });});
```

```js
Adapter
```

```js
const io = require('socket.io')(3000);const redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
emit
```

```js
const io = require('socket.io-emitter')({ host: '127.0.0.1', port: 6379 });setInterval(function(){  io.emit('time', new Date);}, 5000);
```

# https://socket.io/docs/v2/server-api

## Server​

## Namespace​

## Socket​

## Client​

### new Server(httpServer[, options])​

### new Server(port[, options])​

### new Server(options)​

### server.sockets​

### server.serveClient([value])​

### server.path([value])​

### server.adapter([value])​

### server.origins([value])​

### server.origins(fn)​

### server.attach(httpServer[, options])​

### server.attach(port[, options])​

### server.listen(httpServer[, options])​

### server.listen(port[, options])​

### server.bind(engine)​

### server.onconnection(socket)​

### server.of(nsp)​

### server.close([callback])​

### server.engine.generateId​

### namespace.name​

### namespace.connected​

### namespace.adapter​

### namespace.to(room)​

### namespace.in(room)​

### namespace.emit(eventName[, ...args])​

### namespace.clients(callback)​

### namespace.use(fn)​

### Event: 'connect'​

### Event: 'connection'​

### Flag: 'volatile'​

### Flag: 'binary'​

### Flag: 'local'​

### socket.id​

### socket.rooms​

### socket.client​

### socket.conn​

### socket.request​

### socket.handshake​

### socket.use(fn)​

### socket.send([...args][, ack])​

### socket.emit(eventName[, ...args][, ack])​

### socket.on(eventName, callback)​

### socket.once(eventName, listener)​

### socket.removeListener(eventName, listener)​

### socket.removeAllListeners([eventName])​

### socket.eventNames()​

### socket.join(room[, callback])​

### socket.join(rooms[, callback])​

### socket.leave(room[, callback])​

### socket.to(room)​

### socket.in(room)​

### socket.compress(value)​

### socket.disconnect(close)​

### Flag: 'broadcast'​

### Flag: 'volatile'​

### Flag: 'binary'​

### Event: 'disconnect'​

### Event: 'error'​

### Event: 'disconnecting'​

### client.conn​

### client.request​

Exposed by require('socket.io').

Works with and without new:

Available options:

Available options for the underlying Engine.IO server:

Among those options:

The pingTimeout and pingInterval parameters will impact the delay before a client knows the server is not available anymore. For example, if the underlying TCP connection is not closed properly due to a network issue, a client may have to wait up to pingTimeout + pingInterval ms before getting a disconnect event.

The order of the transports array is important. By default, a long-polling connection is established first, and then upgraded to WebSocket if possible. Using ['websocket'] means there will be no fallback if a WebSocket connection cannot be opened.

See above for the list of available options.

See above for the list of available options.

An alias for the default (/) namespace.

If value is true the attached server (see Server#attach) will serve the client files. Defaults to true. This method has no effect after attach is called. If no arguments are supplied this method returns the current value.

Sets the path value under which engine.io and the static files will be served. Defaults to /socket.io. If no arguments are supplied this method returns the current value.

Sets the adapter value. Defaults to an instance of the Adapter that ships with socket.io which is memory based. See socket.io-adapter. If no arguments are supplied this method returns the current value.

Sets the allowed origins value. Defaults to any origins being allowed. If no arguments are supplied this method returns the current value.

Provides a function taking two arguments origin:String and callback(error, success), where success is a boolean value indicating whether origin is allowed or not.  If success is set to false, error must be provided as a string value that will be appended to the server response, e.g. "Origin not allowed".

Potential drawbacks:

Attaches the Server to an engine.io instance on httpServer with the supplied options (optionally).

Attaches the Server to an engine.io instance on a new http.Server with the supplied options (optionally).

Synonym of server.attach(httpServer[, options]).

Synonym of server.attach(port[, options]).

Initializes and retrieves the given Namespace by its pathname identifier nsp. If the namespace was already initialized it returns it immediately.

A regex or a function can also be provided, in order to create namespace in a dynamic way:

With a function:

Closes the socket.io server. The callback argument is optional and will be called when all connections are closed.

Overwrites the default method to generate your custom socket id.

The function is called with a node request object (http.IncomingMessage) as first parameter.

Represents a pool of sockets connected under a given scope identified by a pathname (eg: /chat).

A client always connects to / (the main namespace), then potentially connect to other namespaces (while using the same underlying connection).

For the how and why, please take a look at: Rooms and Namespaces.

The namespace identifier property.

The hash of Socket objects that are connected to this namespace, indexed by id.

The Adapter used for the namespace. Useful when using the Adapter based on Redis, as it exposes methods to manage sockets and rooms across your cluster.

Note: the adapter of the main namespace can be accessed with io.of('/').adapter.

Sets a modifier for a subsequent event emission that the event will only be broadcasted to clients that have joined the given room.

To emit to multiple rooms, you can call to several times.

Synonym of namespace.to(room).

Emits an event to all connected clients. The following two are equivalent:

Note: acknowledgements are not supported when emitting from namespace.

Gets a list of client IDs connected to this namespace (across all nodes if applicable).

An example to get all clients in namespace's room:

As with broadcasting, the default is all clients from the default namespace ('/'):

Registers a middleware, which is a function that gets executed for every incoming Socket, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.

Errors passed to middleware callbacks are sent as special error packets to clients.

Fired upon a connection from client.

Synonym of Event: 'connect'.

Sets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

Specifies whether there is binary data in the emitted data. Increases performance when specified. Can be true or false.

Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node (when the Redis adapter is used).

A Socket is the fundamental class for interacting with browser clients. A Socket belongs to a certain Namespace (by default /) and uses an underlying Client to communicate.

It should be noted the Socket doesn't relate directly to the actual underlying TCP/IP socket and it is only the name of the class.

Within each Namespace, you can also define arbitrary channels (called room) that the Socket can join and leave. That provides a convenient way to broadcast to a group of Sockets (see Socket#to below).

The Socket class inherits from EventEmitter. The Socket class overrides the emit method, and does not modify any other EventEmitter method. All methods documented here which also appear as EventEmitter methods (apart from emit) are implemented by EventEmitter, and documentation for EventEmitter applies.

A unique identifier for the session, that comes from the underlying Client.

A hash of strings identifying the rooms this client is in, indexed by room name.

A reference to the underlying Client object.

A reference to the underlying Client transport connection (engine.io Socket object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.

A getter proxy that returns the reference to the request that originated the underlying engine.io Client. Useful for accessing request headers such as Cookie or User-Agent.

The handshake details:

Usage:

Registers a middleware, which is a function that gets executed for every incoming Packet and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.

Errors passed to middleware callbacks are sent as special error packets to clients.

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

(overrides EventEmitter.emit)

Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including Buffer.

The ack argument is optional and will be called with the client's answer.

(inherited from EventEmitter)

Register a new handler for the given event.

Inherited from EventEmitter (along with other methods not mentioned here). See the Node.js documentation for the events module.

Adds the client to the room, and fires optionally a callback with err signature (if any).

The mechanics of joining rooms are handled by the Adapter that has been configured (see Server#adapter above), defaulting to socket.io-adapter.

For your convenience, each socket automatically joins a room identified by its id (see Socket#id). This makes it easy to broadcast messages to other sockets:

Adds the client to the list of room, and fires optionally a callback with err signature (if any).

Removes the client from room, and fires optionally a callback with err signature (if any).

Rooms are left automatically upon disconnection.

Sets a modifier for a subsequent event emission that the event will only be broadcasted to clients that have joined the given room (the socket itself being excluded).

To emit to multiple rooms, you can call to several times.

Note: acknowledgements are not supported when broadcasting.

Synonym of socket.to(room).

Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method.

Disconnects this client. If value of close is true, closes the underlying connection. Otherwise, it just disconnects the namespace.

Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the sender.

Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

Specifies whether there is binary data in the emitted data. Increases performance when specified. Can be true or false.

Fired upon disconnection.

Possible reasons:

Fired when an error occurs.

Fired when the client is going to be disconnected (but hasn't left its rooms yet).

These are reserved events (along with connect, newListener and removeListener) which cannot be used as event names.

The Client class represents an incoming transport (engine.io) connection. A Client can be associated with many multiplexed Sockets that belong to different Namespaces.

A reference to the underlying engine.io Socket connection.

A getter proxy that returns the reference to the request that originated the engine.io connection. Useful for accessing request headers such as Cookie or User-Agent.

- httpServer (http.Server) the server to bind to.
- options (Object)
- The pingTimeout and pingInterval parameters will impact the delay before a client knows the server is not available anymore. For example, if the underlying TCP connection is not closed properly due to a network issue, a client may have to wait up to pingTimeout + pingInterval ms before getting a disconnect event.
- The order of the transports array is important. By default, a long-polling connection is established first, and then upgraded to WebSocket if possible. Using ['websocket'] means there will be no fallback if a WebSocket connection cannot be opened.
- port (Number) a port to listen to (a new http.Server will be created)
- options (Object)
- options (Object)
- (Namespace)
- value (Boolean)
- Returns Server|Boolean
- value (String)
- Returns Server|String
- value (Adapter)
- Returns Server|Adapter
- value (String|String[])
- Returns Server|String
- fn (Function)
- Returns Server
- in some situations, when it is not possible to determine origin it may have value of *
- As this function will be executed for every request, it is advised to make this function work as fast as possible
- If socket.io is used together with Express, the CORS headers will be affected only for socket.io requests. For Express you can use cors.
- httpServer (http.Server) the server to attach to
- options (Object)
- port (Number) the port to listen on
- options (Object)
- engine (engine.Server)
- Returns Server
- socket (engine.Socket)
- Returns Server
- nsp (String|RegExp|Function)
- Returns Namespace
- callback (Function)
- (String)
- _(Object<Socket>)_
- (Adapter)
- room (String)
- Returns Namespace for chaining
- eventName (String)
- args
- callback (Function)
- fn (Function)
- socket (Socket) socket connection with client
- (String)
- (Object)
- (Client)
- (engine.Socket)
- (Request)
- (Object)
- fn (Function)
- args
- ack (Function)
- Returns Socket
- eventName (String)
- args
- ack (Function)
- Returns Socket
- eventName (String)
- callback (Function)
- Returns Socket
- room (String)
- callback (Function)
- Returns Socket for chaining
- rooms (Array)
- callback (Function)
- Returns Socket for chaining
- room (String)
- callback (Function)
- Returns Socket for chaining
- room (String)
- Returns Socket for chaining
- value (Boolean) whether to following packet will be compressed
- Returns Socket for chaining
- close (Boolean) whether to close the underlying connection
- Returns Socket
- reason (String) the reason of the disconnection (either client or server-side)
- error (Object) error object
- reason (String) the reason of the disconnection (either client or server-side)
- (engine.Socket)
- (Request)
```js
const io = require('socket.io')();// orconst Server = require('socket.io');const io = new Server();
```

```js
const server = require('http').createServer();const io = require('socket.io')(server, {  path: '/test',  serveClient: false,  // below are engine.IO options  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});server.listen(3000);
```

```js
const io = require('socket.io')(3000, {  path: '/test',  serveClient: false,  // below are engine.IO options  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
const io = require('socket.io')({  path: '/test',  serveClient: false,});// eitherconst server = require('http').createServer();io.attach(server, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});server.listen(3000);// orio.attach(3000, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
io.sockets.emit('hi', 'everyone');// is equivalent toio.of('/').emit('hi', 'everyone');
```

```js
// pass a server and the `serveClient` optionconst io = require('socket.io')(http, { serveClient: false });// or pass no server and then you can call the methodconst io = require('socket.io')();io.serveClient(false);io.attach(http);
```

```js
const io = require('socket.io')();io.path('/myownpath');// client-sideconst socket = io({  path: '/myownpath'});
```

```js
const io = require('socket.io')(3000);const redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
io.origins(['https://foo.example.com:443']);
```

```js
io.origins((origin, callback) => {  if (origin !== 'https://foo.example.com') {    return callback('origin not allowed', false);  }  callback(null, true);});
```

```js
const adminNamespace = io.of('/admin');
```

```js
const dynamicNsp = io.of(/^\/dynamic-\d+$/).on('connection', (socket) => {  const newNamespace = socket.nsp; // newNamespace.name === '/dynamic-101'  // broadcast to all clients in the given sub-namespace  newNamespace.emit('hello');});// client-sideconst socket = io('/dynamic-101');// broadcast to all clients in each sub-namespacedynamicNsp.emit('hello');// use a middleware for each sub-namespacedynamicNsp.use((socket, next) => { /* ... */ });
```

```js
io.of((name, query, next) => {  // the checkToken method must return a boolean, indicating whether the client is able to connect or not.  next(null, checkToken(query.token));}).on('connection', (socket) => { /* ... */ });
```

```js
const Server = require('socket.io');const PORT   = 3030;const server = require('http').Server();const io = Server(PORT);io.close(); // Close current serverserver.listen(PORT); // PORT is free to useio = Server(server);
```

```js
io.engine.generateId = (req) => {  return "custom:id:" + custom_id++; // custom id must be unique}
```

```js
const io = require('socket.io')();const adminNamespace = io.of('/admin');adminNamespace.to('level1').emit('an event', { some: 'data' });
```

```js
const io = require('socket.io')();io.emit('an event sent to all connected clients'); // main namespaceconst chat = io.of('/chat');chat.emit('an event sent to all connected clients in chat namespace');
```

```js
const io = require('socket.io')();io.of('/chat').clients((error, clients) => {  if (error) throw error;  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]});
```

```js
io.of('/chat').in('general').clients((error, clients) => {  if (error) throw error;  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]});
```

```js
io.clients((error, clients) => {  if (error) throw error;  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]});
```

```js
io.use((socket, next) => {  if (socket.request.headers.cookie) return next();  next(new Error('Authentication error'));});
```

```js
io.on('connection', (socket) => {  // ...});io.of('/admin').on('connection', (socket) => {  // ...});
```

```js
io.volatile.emit('an event', { some: 'data' }); // the clients may or may not receive it
```

```js
io.binary(false).emit('an event', { some: 'data' });
```

```js
io.local.emit('an event', { some: 'data' });
```

```js
io.on('connection', (socket) => {  socket.join('room 237', () => {    let rooms = Object.keys(socket.rooms);    console.log(rooms); // [ <socket.id>, 'room 237' ]  });});
```

```js
const cookie = require('cookie');io.on('connection', (socket) => {  const cookies = cookie.parse(socket.request.headers.cookie || '');});
```

```js
{  headers: /* the headers sent as part of the handshake */,  time: /* the date of creation (as string) */,  address: /* the ip of the client */,  xdomain: /* whether the connection is cross-domain */,  secure: /* whether the connection is secure */,  issued: /* the date of creation (as unix timestamp) */,  url: /* the request URL string */,  query: /* the query object */}
```

```js
io.use((socket, next) => {  let handshake = socket.handshake;  // ...});io.on('connection', (socket) => {  let handshake = socket.handshake;  // ...});
```

```js
io.on('connection', (socket) => {  socket.use((packet, next) => {    if (packet.doge === true) return next();    next(new Error('Not a doge error'));  });});
```

```js
socket.emit('hello', 'world');socket.emit('with-binary', 1, '2', { 3: '4', 5: Buffer.from([6]) });
```

```js
io.on('connection', (socket) => {  socket.emit('an event', { some: 'data' });  socket.emit('ferret', 'tobi', (data) => {    console.log(data); // data will be 'woot'  });  // the client code  // client.on('ferret', (name, fn) => {  //   fn('woot');  // });});
```

```js
socket.on('news', (data) => {  console.log(data);});// with several argumentssocket.on('news', (arg1, arg2, arg3) => {  // ...});// or with acknowledgementsocket.on('news', (data, callback) => {  callback(0);});
```

```js
io.on('connection', (socket) => {  socket.join('room 237', () => {    let rooms = Object.keys(socket.rooms);    console.log(rooms); // [ <socket.id>, 'room 237' ]    io.to('room 237').emit('a new user has joined the room'); // broadcast to everyone in the room  });});
```

```js
io.on('connection', (socket) => {  socket.on('say to someone', (id, msg) => {    // send a private message to the socket with the given id    socket.to(id).emit('my message', msg);  });});
```

```js
io.on('connection', (socket) => {  socket.join(['room 237', 'room 238'], () => {    const rooms = Object.keys(socket.rooms);    console.log(rooms); // [ <socket.id>, 'room 237', 'room 238' ]    io.to('room 237').to('room 238').emit('a new user has joined the room'); // broadcast to everyone in both rooms  });});
```

```js
io.on('connection', (socket) => {  socket.leave('room 237', () => {    io.to('room 237').emit(`user ${socket.id} has left the room`);  });});
```

```js
io.on('connection', (socket) => {  // to one room  socket.to('others').emit('an event', { some: 'data' });  // to multiple rooms  socket.to('room1').to('room2').emit('hello');  // a private message to another socket  socket.to(/* another socket id */).emit('hey');  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.});
```

```js
io.on('connection', (socket) => {  socket.compress(false).emit('uncompressed', "that's rough");});
```

```js
io.on('connection', (socket) => {  setTimeout(() => socket.disconnect(true), 5000);});
```

```js
io.on('connection', (socket) => {  socket.broadcast.emit('an event', { some: 'data' }); // everyone gets it but the sender});
```

```js
io.on('connection', (socket) => {  socket.volatile.emit('an event', { some: 'data' }); // the client may or may not receive it});
```

```js
const io = require('socket.io')();io.on('connection', (socket) => {  socket.binary(false).emit('an event', { some: 'data' }); // The data to send has no binary data});
```

```js
io.on('connection', (socket) => {  socket.on('disconnect', (reason) => {    // ...  });});
```

```js
io.on('connection', (socket) => {  socket.on('error', (error) => {    // ...  });});
```

```js
io.on('connection', (socket) => {  socket.on('disconnecting', (reason) => {    let rooms = Object.keys(socket.rooms);    // ...  });});
```

```js
require('socket.io')
```

```js
httpServer
```

```js
options
```

```js
new
```

```js
const io = require('socket.io')();// orconst Server = require('socket.io');const io = new Server();
```

```js
path
```

```js
/socket.io
```

```js
serveClient
```

```js
true
```

```js
adapter
```

```js
Adapter
```

```js
origins
```

```js
parser
```

```js
Parser
```

```js
pingTimeout
```

```js
5000
```

```js
pingInterval
```

```js
25000
```

```js
upgradeTimeout
```

```js
10000
```

```js
maxHttpBufferSize
```

```js
10e7
```

```js
allowRequest
```

```js
fn(err, success)
```

```js
success
```

```js
transports
```

```js
['polling', 'websocket']
```

```js
allowUpgrades
```

```js
true
```

```js
perMessageDeflate
```

```js
false
```

```js
false
```

```js
2.4.0
```

```js
httpCompression
```

```js
true
```

```js
false
```

```js
cookie
```

```js
false
```

```js
cookiePath
```

```js
cookie
```

```js
/engine.io
```

```js
cookieHttpOnly
```

```js
true
```

```js
true
```

```js
cookie
```

```js
cookiePath
```

```js
false
```

```js
wsEngine
```

```js
pingTimeout
```

```js
pingInterval
```

```js
pingTimeout + pingInterval
```

```js
disconnect
```

```js
transports
```

```js
['websocket']
```

```js
const server = require('http').createServer();const io = require('socket.io')(server, {  path: '/test',  serveClient: false,  // below are engine.IO options  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});server.listen(3000);
```

```js
port
```

```js
http.Server
```

```js
options
```

```js
options
```

```js
const io = require('socket.io')(3000, {  path: '/test',  serveClient: false,  // below are engine.IO options  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
options
```

```js
options
```

```js
const io = require('socket.io')({  path: '/test',  serveClient: false,});// eitherconst server = require('http').createServer();io.attach(server, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});server.listen(3000);// orio.attach(3000, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
io.sockets.emit('hi', 'everyone');// is equivalent toio.of('/').emit('hi', 'everyone');
```

```js
value
```

```js
Server|Boolean
```

```js
value
```

```js
true
```

```js
Server#attach
```

```js
true
```

```js
attach
```

```js
// pass a server and the `serveClient` optionconst io = require('socket.io')(http, { serveClient: false });// or pass no server and then you can call the methodconst io = require('socket.io')();io.serveClient(false);io.attach(http);
```

```js
value
```

```js
Server|String
```

```js
value
```

```js
engine.io
```

```js
/socket.io
```

```js
const io = require('socket.io')();io.path('/myownpath');// client-sideconst socket = io({  path: '/myownpath'});
```

```js
value
```

```js
Server|Adapter
```

```js
value
```

```js
Adapter
```

```js
const io = require('socket.io')(3000);const redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
value
```

```js
Server|String
```

```js
value
```

```js
io.origins(['https://foo.example.com:443']);
```

```js
Server
```

```js
origin:String
```

```js
callback(error, success)
```

```js
success
```

```js
success
```

```js
false
```

```js
error
```

```js
origin
```

```js
socket.io
```

```js
Express
```

```js
socket.io
```

```js
io.origins((origin, callback) => {  if (origin !== 'https://foo.example.com') {    return callback('origin not allowed', false);  }  callback(null, true);});
```

```js
httpServer
```

```js
options
```

```js
Server
```

```js
httpServer
```

```js
options
```

```js
port
```

```js
options
```

```js
Server
```

```js
options
```

```js
engine
```

```js
Server
```

```js
Server
```

```js
socket
```

```js
Server
```

```js
socket.io
```

```js
Socket
```

```js
nsp
```

```js
Namespace
```

```js
Namespace
```

```js
nsp
```

```js
const adminNamespace = io.of('/admin');
```

```js
const dynamicNsp = io.of(/^\/dynamic-\d+$/).on('connection', (socket) => {  const newNamespace = socket.nsp; // newNamespace.name === '/dynamic-101'  // broadcast to all clients in the given sub-namespace  newNamespace.emit('hello');});// client-sideconst socket = io('/dynamic-101');// broadcast to all clients in each sub-namespacedynamicNsp.emit('hello');// use a middleware for each sub-namespacedynamicNsp.use((socket, next) => { /* ... */ });
```

```js
io.of((name, query, next) => {  // the checkToken method must return a boolean, indicating whether the client is able to connect or not.  next(null, checkToken(query.token));}).on('connection', (socket) => { /* ... */ });
```

```js
callback
```

```js
callback
```

```js
const Server = require('socket.io');const PORT   = 3030;const server = require('http').Server();const io = Server(PORT);io.close(); // Close current serverserver.listen(PORT); // PORT is free to useio = Server(server);
```

```js
http.IncomingMessage
```

```js
io.engine.generateId = (req) => {  return "custom:id:" + custom_id++; // custom id must be unique}
```

```js
/chat
```

```js
_(Object<Socket>)_
```

```js
Socket
```

```js
Adapter
```

```js
Adapter
```

```js
io.of('/').adapter
```

```js
room
```

```js
Namespace
```

```js
room
```

```js
const io = require('socket.io')();const adminNamespace = io.of('/admin');adminNamespace.to('level1').emit('an event', { some: 'data' });
```

```js
eventName
```

```js
args
```

```js
const io = require('socket.io')();io.emit('an event sent to all connected clients'); // main namespaceconst chat = io.of('/chat');chat.emit('an event sent to all connected clients in chat namespace');
```

```js
callback
```

```js
const io = require('socket.io')();io.of('/chat').clients((error, clients) => {  if (error) throw error;  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]});
```

```js
io.of('/chat').in('general').clients((error, clients) => {  if (error) throw error;  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]});
```

```js
io.clients((error, clients) => {  if (error) throw error;  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]});
```

```js
Socket
```

```js
error
```

```js
io.use((socket, next) => {  if (socket.request.headers.cookie) return next();  next(new Error('Authentication error'));});
```

```js
socket
```

```js
io.on('connection', (socket) => {  // ...});io.of('/admin').on('connection', (socket) => {  // ...});
```

```js
io.volatile.emit('an event', { some: 'data' }); // the clients may or may not receive it
```

```js
true
```

```js
false
```

```js
io.binary(false).emit('an event', { some: 'data' });
```

```js
io.local.emit('an event', { some: 'data' });
```

```js
Socket
```

```js
Socket
```

```js
Namespace
```

```js
Client
```

```js
Socket
```

```js
socket
```

```js
Namespace
```

```js
room
```

```js
Socket
```

```js
Socket
```

```js
Socket#to
```

```js
Socket
```

```js
Socket
```

```js
emit
```

```js
EventEmitter
```

```js
EventEmitter
```

```js
emit
```

```js
EventEmitter
```

```js
EventEmitter
```

```js
Client
```

```js
io.on('connection', (socket) => {  socket.join('room 237', () => {    let rooms = Object.keys(socket.rooms);    console.log(rooms); // [ <socket.id>, 'room 237' ]  });});
```

```js
Client
```

```js
Client
```

```js
Socket
```

```js
request
```

```js
Client
```

```js
Cookie
```

```js
User-Agent
```

```js
const cookie = require('cookie');io.on('connection', (socket) => {  const cookies = cookie.parse(socket.request.headers.cookie || '');});
```

```js
{  headers: /* the headers sent as part of the handshake */,  time: /* the date of creation (as string) */,  address: /* the ip of the client */,  xdomain: /* whether the connection is cross-domain */,  secure: /* whether the connection is secure */,  issued: /* the date of creation (as unix timestamp) */,  url: /* the request URL string */,  query: /* the query object */}
```

```js
io.use((socket, next) => {  let handshake = socket.handshake;  // ...});io.on('connection', (socket) => {  let handshake = socket.handshake;  // ...});
```

```js
Packet
```

```js
error
```

```js
io.on('connection', (socket) => {  socket.use((packet, next) => {    if (packet.doge === true) return next();    next(new Error('Not a doge error'));  });});
```

```js
args
```

```js
ack
```

```js
Socket
```

```js
message
```

```js
EventEmitter.emit
```

```js
eventName
```

```js
args
```

```js
ack
```

```js
Socket
```

```js
Buffer
```

```js
socket.emit('hello', 'world');socket.emit('with-binary', 1, '2', { 3: '4', 5: Buffer.from([6]) });
```

```js
ack
```

```js
io.on('connection', (socket) => {  socket.emit('an event', { some: 'data' });  socket.emit('ferret', 'tobi', (data) => {    console.log(data); // data will be 'woot'  });  // the client code  // client.on('ferret', (name, fn) => {  //   fn('woot');  // });});
```

```js
EventEmitter
```

```js
eventName
```

```js
callback
```

```js
Socket
```

```js
socket.on('news', (data) => {  console.log(data);});// with several argumentssocket.on('news', (arg1, arg2, arg3) => {  // ...});// or with acknowledgementsocket.on('news', (data, callback) => {  callback(0);});
```

```js
EventEmitter
```

```js
room
```

```js
callback
```

```js
Socket
```

```js
room
```

```js
err
```

```js
io.on('connection', (socket) => {  socket.join('room 237', () => {    let rooms = Object.keys(socket.rooms);    console.log(rooms); // [ <socket.id>, 'room 237' ]    io.to('room 237').emit('a new user has joined the room'); // broadcast to everyone in the room  });});
```

```js
Adapter
```

```js
Server#adapter
```

```js
Socket#id
```

```js
io.on('connection', (socket) => {  socket.on('say to someone', (id, msg) => {    // send a private message to the socket with the given id    socket.to(id).emit('my message', msg);  });});
```

```js
rooms
```

```js
callback
```

```js
Socket
```

```js
err
```

```js
io.on('connection', (socket) => {  socket.join(['room 237', 'room 238'], () => {    const rooms = Object.keys(socket.rooms);    console.log(rooms); // [ <socket.id>, 'room 237', 'room 238' ]    io.to('room 237').to('room 238').emit('a new user has joined the room'); // broadcast to everyone in both rooms  });});
```

```js
room
```

```js
callback
```

```js
Socket
```

```js
room
```

```js
err
```

```js
io.on('connection', (socket) => {  socket.leave('room 237', () => {    io.to('room 237').emit(`user ${socket.id} has left the room`);  });});
```

```js
room
```

```js
Socket
```

```js
room
```

```js
io.on('connection', (socket) => {  // to one room  socket.to('others').emit('an event', { some: 'data' });  // to multiple rooms  socket.to('room1').to('room2').emit('hello');  // a private message to another socket  socket.to(/* another socket id */).emit('hey');  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.});
```

```js
value
```

```js
Socket
```

```js
true
```

```js
true
```

```js
io.on('connection', (socket) => {  socket.compress(false).emit('uncompressed', "that's rough");});
```

```js
close
```

```js
Socket
```

```js
true
```

```js
io.on('connection', (socket) => {  setTimeout(() => socket.disconnect(true), 5000);});
```

```js
io.on('connection', (socket) => {  socket.broadcast.emit('an event', { some: 'data' }); // everyone gets it but the sender});
```

```js
io.on('connection', (socket) => {  socket.volatile.emit('an event', { some: 'data' }); // the client may or may not receive it});
```

```js
true
```

```js
false
```

```js
const io = require('socket.io')();io.on('connection', (socket) => {  socket.binary(false).emit('an event', { some: 'data' }); // The data to send has no binary data});
```

```js
reason
```

```js
io.on('connection', (socket) => {  socket.on('disconnect', (reason) => {    // ...  });});
```

```js
transport error
```

```js
server namespace disconnect
```

```js
socket.disconnect()
```

```js
client namespace disconnect
```

```js
ping timeout
```

```js
pingTimeout
```

```js
transport close
```

```js
error
```

```js
io.on('connection', (socket) => {  socket.on('error', (error) => {    // ...  });});
```

```js
reason
```

```js
rooms
```

```js
io.on('connection', (socket) => {  socket.on('disconnecting', (reason) => {    let rooms = Object.keys(socket.rooms);    // ...  });});
```

```js
connect
```

```js
newListener
```

```js
removeListener
```

```js
Client
```

```js
Client
```

```js
Socket
```

```js
Namespace
```

```js
engine.io
```

```js
Socket
```

```js
request
```

```js
Cookie
```

```js
User-Agent
```

# https://socket.io/docs/v2/server-initialization

# Server Initialization

## Syntax​

## Initialization​

## Notable options​

### CommonJS​

### ES modules​

### TypeScript​

### Standalone​

### Attached to an existing HTTP server​

### With Express​

### With Koa​

### perMessageDeflate option​

### maxHttpBufferSize option​

Once you have installed the Socket.IO server library, you can now init the server. The complete list of options can be found here.

Please see here for enabling ECMAScript modules in your Node.js project.

First, you need to install the types: npm i --save-dev @types/socket.io

You can also pass the port as the first argument:

This implicitly starts a Node.js HTTP server, which can be accessed through io.httpServer.

With HTTPS:

More information here.

More information here.

The complete list of options can be found here. Here are those which you will most likely use:

Default value: false

The WebSocket server provided by the ws package supports the permessage-deflate extension, which enables the client and server to negotiate a compression algorithm and its parameters, and then selectively apply it to the data payloads of each WebSocket message.

Starting from Socket.IO v2.4.0 (and in v3), this extension is now disabled by default, because it adds a significant overhead in terms of performance and memory consumption (and the ws maintainers suggest to only enable it if it is really needed).

For previous versions, you can disable it with:

Default value: 1e6

This defines how many bytes a single message can be, before closing the socket. It defaults to 1e6 (1MB). You may increase or decrease this value depending on your needs.

It matches the maxPayload option of the ws package.

- Server
- Initialization
```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import Server from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import Server = require("socket.io");import { Socket } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket: Socket) => {  // ...});httpServer.listen(3000);
```

```js
const options = { /* ... */ };const io = require('socket.io')(options);io.on('connection', socket => { /* ... */ });io.listen(3000);
```

```js
const options = { /* ... */ };const io = require('socket.io')(3000, options);io.on('connection', socket => { /* ... */ });
```

```js
const server = require('http').createServer();const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
const fs = require('fs');const server = require('https').createServer({  key: fs.readFileSync('/tmp/key.pem'),  cert: fs.readFileSync('/tmp/cert.pem')});const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
const app = require('express')();const server = require('http').createServer(app);const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
const app = require('koa')();const server = require('http').createServer(app.callback());const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
const io = require('socket.io')({  perMessageDeflate: false});
```

```js
const io = require('socket.io')({  maxHttpBufferSize: 1e8});
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import Server from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
npm i --save-dev @types/socket.io
```

```js
import { createServer } from "http";import Server = require("socket.io");import { Socket } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket: Socket) => {  // ...});httpServer.listen(3000);
```

```js
const options = { /* ... */ };const io = require('socket.io')(options);io.on('connection', socket => { /* ... */ });io.listen(3000);
```

```js
const options = { /* ... */ };const io = require('socket.io')(3000, options);io.on('connection', socket => { /* ... */ });
```

```js
io.httpServer
```

```js
const server = require('http').createServer();const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
const fs = require('fs');const server = require('https').createServer({  key: fs.readFileSync('/tmp/key.pem'),  cert: fs.readFileSync('/tmp/cert.pem')});const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
const app = require('express')();const server = require('http').createServer(app);const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
const app = require('koa')();const server = require('http').createServer(app.callback());const options = { /* ... */ };const io = require('socket.io')(server, options);io.on('connection', socket => { /* ... */ });server.listen(3000);
```

```js
perMessageDeflate
```

```js
false
```

```js
const io = require('socket.io')({  perMessageDeflate: false});
```

```js
maxHttpBufferSize
```

```js
1e6
```

```js
1e6
```

```js
const io = require('socket.io')({  maxHttpBufferSize: 1e8});
```

# https://socket.io/docs/v2/server-installation

# Server Installation

## Prerequisites​

## Installation​

## Additional packages​

## Other WebSocket server implementations​

Please make sure that Node.js is installed on your system. The current Long Term Support (LTS) release is an ideal starting point.

At least Node.js 8 is needed, older versions are not supported anymore.

The latest Socket.IO release is:

To install the latest release:

To install a specific version:

By default, Socket.IO use the WebSocket server provided by the ws package.

There are 2 optional packages that can be installed alongside this package. These packages are binary add-ons which improve certain operations. Prebuilt binaries are available for the most popular platforms so you don't necessarily need to have a C++ compiler installed on your machine.

To install those packages:

Please note that these packages are optional, the WebSocket server will fallback to the Javascript implementation if they are not available. More information can be found here.

For example, you can use the eiows package, which is a fork of the (now deprecated) uws package:

And then use the wsEngine option:

This implementation "allows, but doesn't guarantee" significant performance and memory-usage improvements over the default implementation. As usual, please benchmark it against your own usage.

- Server
- Installation
- bufferutil: Allows to efficiently perform operations such as masking and unmasking the data payload of the WebSocket frames.
- utf-8-validate: Allows to efficiently check if a message contains valid UTF-8 as required by the spec.
```js
$ npm install socket.io
```

```js
$ npm install socket.io@<version>
```

```js
$ npm install --save-optional bufferutil utf-8-validate
```

```js
$ npm install eiows
```

```js
const io = require('socket.io')(3000, {  wsEngine: 'eiows'});
```

```js
$ npm install socket.io
```

```js
$ npm install socket.io@<version>
```

```js
$ npm install --save-optional bufferutil utf-8-validate
```

```js
$ npm install eiows
```

```js
wsEngine
```

```js
const io = require('socket.io')(3000, {  wsEngine: 'eiows'});
```

# https://socket.io/docs/v2/using-multiple-nodes

# Using multiple nodes

## Sticky load balancing​

## NginX configuration​

## Apache HTTPD configuration​

## HAProxy configuration​

## Using Node.JS Cluster​

## Passing events between nodes​

If you plan to distribute the load of connections among different processes or machines, you have to make sure that requests associated with a particular session id connect to the process that originated them.

This is due to certain transports like XHR Polling or JSONP Polling relying on firing several requests during the lifetime of the “socket”. Failing to enable sticky balancing will result in the dreaded:

Which means that the upgrade request was sent to a node which did not know the given socket id, hence the HTTP 400 response.

To illustrate why this is needed, consider the example of emitting an event to all connected clients:

Chances are that some of those clients might have an active bi-directional communication channel like WebSocket that we can write to immediately, but some of them might be using long-polling.

If they’re using long polling, they might or might not have sent a request that we can write to. They could be “in between” those requests. In those situations, it means we have to buffer messages in the process. In order for the client to successfully claim those messages when he sends his request, the easiest way is for him to connect to be routed to that same process.

As noted above, WebSocket transport do not have this limitation, since the underlying TCP connection is kept open between the client and the given server. That's why you might find some suggestions to only use the WebSocket transport:

Both means that there is NO FALLBACK to long-polling when the websocket connection cannot be established, which is in fact one of the key feature of Socket.IO. In that case, you should maybe consider using raw WebSocket, or a thin wrapper like robust-websocket.

To achieve sticky-session, there are two main solutions:

routing clients based on their originating address

routing clients based on a cookie

Within the http { } section of your nginx.conf file, you can declare a upstream section with a list of Socket.IO process you want to balance load between:

Notice the ip_hash instruction that indicates the connections will be sticky.

Make sure you also configure worker_processes in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the worker_connections setting within the events { } block.

Example

Example

Example

Just like NginX, Node.JS comes with built-in clustering support through the cluster module.

Fedor Indutny has created a module called sticky session that ensures file descriptors (ie: connections) are routed based on the originating remoteAddress (ie: IP). Please note that this might lead to unbalanced routing, depending on the hashing method.

You could also assign a different port to each worker of the cluster, based on the cluster worker ID, and balance the load with the configuration that you can find above.

Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to everyone (or even everyone in a certain room) you’ll need some way of passing messages between processes or computers.

The interface in charge of routing messages is what we call the Adapter. You can implement your own on top of the socket.io-adapter (by inheriting from it) or you can use the one we provide on top of Redis: socket.io-redis:

Then the following call:

will be broadcast to every node through the Pub/Sub mechanism of Redis.

Note: sticky-session is still needed when using the Redis adapter.

If you want to pass messages to it from non-socket.io processes, you should look into “Sending messages from the outside-world”.

- Server
- Using multiple nodes
- routing clients based on their originating address
- routing clients based on a cookie
```js
Error during WebSocket handshake: Unexpected response code: 400
```

```js
io.emit('hi', 'all sockets');
```

```js
const socket = io('https://io.yourhost.com', {  // WARNING: in that case, there is no fallback to long-polling  transports: [ 'websocket' ] // or [ 'websocket', 'polling' ], which is the same thing})
```

```js
http {  server {    listen 3000;    server_name io.yourhost.com;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://nodes;      # enable WebSockets      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }  upstream nodes {    # enable sticky session based on IP    ip_hash;    server app01:3000;    server app02:3000;    server app03:3000;  }}
```

```js
Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED<Proxy "balancer://nodes_polling">    BalancerMember "http://app01:3000" route=app01    BalancerMember "http://app02:3000" route=app02    BalancerMember "http://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy><Proxy "balancer://nodes_ws">    BalancerMember "ws://app01:3000" route=app01    BalancerMember "ws://app02:3000" route=app02    BalancerMember "ws://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy>RewriteEngine OnRewriteCond %{HTTP:Upgrade} =websocket [NC]RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]RewriteCond %{HTTP:Upgrade} !=websocket [NC]RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]ProxyTimeout 3
```

```js
# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03
```

```js
const io = require('socket.io')(3000);const redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
io.emit('hi', 'all sockets');
```

```js
Error during WebSocket handshake: Unexpected response code: 400
```

```js
io.emit('hi', 'all sockets');
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
const socket = io('https://io.yourhost.com', {  // WARNING: in that case, there is no fallback to long-polling  transports: [ 'websocket' ] // or [ 'websocket', 'polling' ], which is the same thing})
```

```js
http { }
```

```js
nginx.conf
```

```js
upstream
```

```js
http {  server {    listen 3000;    server_name io.yourhost.com;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://nodes;      # enable WebSockets      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }  upstream nodes {    # enable sticky session based on IP    ip_hash;    server app01:3000;    server app02:3000;    server app03:3000;  }}
```

```js
ip_hash
```

```js
worker_processes
```

```js
worker_connections
```

```js
events { }
```

```js
Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED<Proxy "balancer://nodes_polling">    BalancerMember "http://app01:3000" route=app01    BalancerMember "http://app02:3000" route=app02    BalancerMember "http://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy><Proxy "balancer://nodes_ws">    BalancerMember "ws://app01:3000" route=app01    BalancerMember "ws://app02:3000" route=app02    BalancerMember "ws://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy>RewriteEngine OnRewriteCond %{HTTP:Upgrade} =websocket [NC]RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]RewriteCond %{HTTP:Upgrade} !=websocket [NC]RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]ProxyTimeout 3
```

```js
# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03
```

```js
cluster
```

```js
remoteAddress
```

```js
Adapter
```

```js
const io = require('socket.io')(3000);const redis = require('socket.io-redis');io.adapter(redis({ host: 'localhost', port: 6379 }));
```

```js
io.emit('hi', 'all sockets');
```

# https://socket.io/docs/v3

# Introduction

## What Socket.IO is​

## What Socket.IO is not​

## Features​

### How does that work?​

Socket.IO is a library that enables real-time, bidirectional and event-based communication between the browser and the server. It consists of:

There are also several client implementation in other languages, which are maintained by the community:

Other server implementations:

The client will try to establish a WebSocket connection if possible, and will fall back on HTTP long polling if not.

WebSocket is a communication protocol which provides a full-duplex and low-latency channel between the server and the browser. More information can be found here.

So, in the best-case scenario, provided that:

You will have, on the client-side:

Socket.IO provides additional features over a plain WebSocket object, which are listed below.

But first, let's detail what the Socket.IO library is not.

Socket.IO is NOT a WebSocket implementation.

Although Socket.IO indeed uses WebSocket as a transport when possible, it adds additional metadata to each packet. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either.

If you are looking for a plain WebSocket server, please take a look at ws or uWebSockets.js.

There are also talks to include a WebSocket server in the Node.js core.

On the client-side, you might be interested by the robust-websocket package.

Socket.IO is not meant to be used in a background service, for mobile applications.

The Socket.IO library keeps an open TCP connection to the server, which may result in a high battery drain for your users. Please use a dedicated messaging platform like FCM for this use case.

Here are the features provided by Socket.IO over plain WebSockets:

Please find more details about how it works here.

- Documentation
- Introduction
- Java: https://github.com/socketio/socket.io-client-java
- C++: https://github.com/socketio/socket.io-client-cpp
- Swift: https://github.com/socketio/socket.io-client-swift
- Dart: https://github.com/rikulo/socket.io-client-dart
- Python: https://github.com/miguelgrinberg/python-socketio
- .Net: https://github.com/doghappy/socket.io-client-csharp
- Rust: https://github.com/1c3t3a/rust-socketio
- Golang: https://github.com/googollee/go-socket.io
- Golang: https://github.com/ambelovsky/gosf
- Java: https://github.com/mrniko/netty-socketio
- Java: https://github.com/trinopoty/socket.io-server-java
- Python: https://github.com/miguelgrinberg/python-socketio
- Rust: https://github.com/Totodore/socketioxide
- the browser supports WebSocket (97% of all browsers in 2020)
- there is no element (proxy, firewall, ...) preventing WebSocket connections between the client and the server
- reliability (fallback to HTTP long-polling in case the WebSocket connection cannot be established)
- automatic reconnection
- packet buffering
- acknowledgments
- broadcasting to all clients or to a subset of clients (what we call "Room")
- multiplexing (what we call "Namespace")
```js
const socket = new WebSocket("ws://localhost:3000");socket.onopen = () => {  socket.send("Hello!");};socket.onmessage = (data) => {  console.log(data);};
```

```js
const socket = io("ws://localhost:3000");socket.on("connect", () => {  // either with send()  socket.send("Hello!");  // or with emit() and custom event names  socket.emit("salutations", "Hello!", { "mr": "john" }, Uint8Array.from([1, 2, 3, 4]));});// handle the event sent with socket.send()socket.on("message", data => {  console.log(data);});// handle the event sent with socket.emit()socket.on("greetings", (elem1, elem2, elem3) => {  console.log(elem1, elem2, elem3);});
```

```js
const io = require("socket.io")(3000);io.on("connection", socket => {  // either with send()  socket.send("Hello!");  // or with emit() and custom event names  socket.emit("greetings", "Hey!", { "ms": "jane" }, Buffer.from([4, 3, 3, 1]));  // handle the event sent with socket.send()  socket.on("message", (data) => {    console.log(data);  });  // handle the event sent with socket.emit()  socket.on("salutations", (elem1, elem2, elem3) => {    console.log(elem1, elem2, elem3);  });});
```

```js
// WARNING: the client will NOT be able to connect!const socket = io("ws://echo.websocket.org");
```

```js
const socket = new WebSocket("ws://localhost:3000");socket.onopen = () => {  socket.send("Hello!");};socket.onmessage = (data) => {  console.log(data);};
```

```js
const socket = io("ws://localhost:3000");socket.on("connect", () => {  // either with send()  socket.send("Hello!");  // or with emit() and custom event names  socket.emit("salutations", "Hello!", { "mr": "john" }, Uint8Array.from([1, 2, 3, 4]));});// handle the event sent with socket.send()socket.on("message", data => {  console.log(data);});// handle the event sent with socket.emit()socket.on("greetings", (elem1, elem2, elem3) => {  console.log(elem1, elem2, elem3);});
```

```js
socket
```

```js
const io = require("socket.io")(3000);io.on("connection", socket => {  // either with send()  socket.send("Hello!");  // or with emit() and custom event names  socket.emit("greetings", "Hey!", { "ms": "jane" }, Buffer.from([4, 3, 3, 1]));  // handle the event sent with socket.send()  socket.on("message", (data) => {    console.log(data);  });  // handle the event sent with socket.emit()  socket.on("salutations", (elem1, elem2, elem3) => {    console.log(elem1, elem2, elem3);  });});
```

```js
// WARNING: the client will NOT be able to connect!const socket = io("ws://echo.websocket.org");
```

# https://socket.io/docs/v3/broadcasting-events

# Broadcasting events

## To all connected clients​

## To all connected clients except the sender​

## With multiple Socket.IO servers​

Socket.IO makes it easy to send events to all the connected clients.

Please note that broadcasting is a server-only feature.

Clients that are currently disconnected (or in the process of reconnecting) won't receive the event. Storing this event somewhere (in a database, for example) is up to you, depending on your use case.

In the example above, using socket.emit("hello", "world") (without broadcast flag) would send the event to "client A". You can find the list of all the ways to send an event in the cheatsheet.

Broadcasting also works with multiple Socket.IO servers.

You just need to replace the default Adapter by the Redis Adapter. More information about it here.

In certain cases, you may want to only broadcast to clients that are connected to the current server. You can achieve this with the local flag:

In order to target specific clients when broadcasting, please see the documentation about Rooms.

- Events
- Broadcasting events
```js
io.emit("hello", "world");
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("hello", "world");});
```

```js
io.local.emit("hello", "world");
```

```js
io.emit("hello", "world");
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("hello", "world");});
```

```js
socket.emit("hello", "world")
```

```js
broadcast
```

```js
local
```

```js
io.local.emit("hello", "world");
```

# https://socket.io/docs/v3/client-api

## IO​

## Manager​

## Socket​

### io.protocol​

### io([url][, options])​

### new Manager(url[, options])​

### manager.reconnection([value])​

### manager.reconnectionAttempts([value])​

### manager.reconnectionDelay([value])​

### manager.reconnectionDelayMax([value])​

### manager.timeout([value])​

### manager.open([callback])​

### manager.connect([callback])​

### manager.socket(nsp, options)​

### Event: 'error'​

### Event: 'reconnect'​

### Event: 'reconnect_attempt'​

### Event: 'reconnect_error'​

### Event: 'reconnect_failed'​

### Event: 'ping'​

### socket.id​

### socket.connected​

### socket.disconnected​

### socket.connect()​

### socket.open()​

### socket.send([...args][, ack])​

### socket.emit(eventName[, ...args][, ack])​

### socket.on(eventName, callback)​

### socket.onAny(callback)​

### socket.prependAny(callback)​

### socket.offAny([listener])​

### socket.listenersAny()​

### socket.compress(value)​

### socket.disconnect()​

### socket.close()​

### Flag: 'volatile'​

### Event: 'connect'​

### Event: 'disconnect'​

### Event: 'connect_error'​

Exposed as the io namespace in the standalone build, or the result of calling require("socket.io-client").

The protocol revision number (currently: 5).

The protocol defines the format of the packets exchanged between the client and the server. Both the client and the server must use the same revision in order to understand each other.

You can find more information here.

Creates a new Manager for the given URL, and attempts to reuse an existing Manager for subsequent calls, unless the multiplex option is passed with false. Passing this option is the equivalent of passing "force new connection": true or forceNew: true.

A new Socket instance is returned for the namespace specified by the pathname in the URL, defaulting to /. For example, if the url is http://localhost/users, a transport connection will be established to http://localhost and a Socket.IO connection will be established to /users.

Query parameters can also be provided, either with the query option or directly in the url (example: http://localhost/users?token=abc).

is the short version of:

See new Manager(url[, options]) for the list of available options.

Please note: manager.socket("/my-namespace", options ) will only read the auth key in the options object.
query: {…} and other optional values are only used when passed via a new Manager(uri, options) instance.

See Migrating from 2.x to 3.0 for more on the difference between the auth and query options.

The Manager manages the Engine.IO client instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling).

The Manager handles the reconnection logic.

A single Manager can be used by several Sockets. You can find more information about this multiplexing feature here.

Please note that, in most cases, you won't use the Manager directly but use the Socket instance instead.

Available options:

Available options for the underlying Engine.IO client:

Node.js-only options for the underlying Engine.IO client:

Sets the reconnection option, or returns it if no parameters are passed.

Sets the reconnectionAttempts option, or returns it if no parameters are passed.

Sets the reconnectionDelay option, or returns it if no parameters are passed.

Sets the reconnectionDelayMax option, or returns it if no parameters are passed.

Sets the timeout option, or returns it if no parameters are passed.

If the manager was initiated with autoConnect to false, launch a new connection attempt.

The callback argument is optional and will be called once the attempt fails/succeeds.

Synonym of manager.open([callback]).

Creates a new Socket for the given namespace. Only auth ({ auth: {key: "value"} }) is read from the options object. Other keys will be ignored and should be passed when instancing a new Manager(nsp, options).

Fired upon a connection error.

Fired upon a successful reconnection.

Fired upon an attempt to reconnect.

Fired upon a reconnection attempt error.

Fired when couldn't reconnect within reconnectionAttempts.

Fired when a ping packet is received from the server.

A Socket is the fundamental class for interacting with the server. A Socket belongs to a certain Namespace (by default /) and uses an underlying Manager to communicate.

A Socket is basically an EventEmitter which sends events to — and receive events from — the server over the network.

More information can be found here.

A unique identifier for the socket session. Set after the connect event is triggered, and updated after the reconnect event.

Whether or not the socket is connected to the server.

Whether or not the socket is disconnected from the server.

Manually connects the socket.

It can also be used to manually reconnect:

Synonym of socket.connect().

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including Buffer.

The ack argument is optional and will be called with the server answer.

Register a new handler for the given event.

The socket actually inherits every method of the Emitter class, like hasListeners, once or off (to remove an event listener).

Register a new catch-all listener.

Register a new catch-all listener. The listener is added to the beginning of the listeners array.

Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed.

Returns the list of registered catch-all listeners.

Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method.

Manually disconnects the socket. In that case, the socket will not try to reconnect.

Associated disconnection reason:

If this is the last active Socket instance of the Manager, the low-level connection will be closed.

Synonym of socket.disconnect().

Sets a modifier for the subsequent event emission indicating that the packet may be dropped if:

Fired upon connection to the Namespace (including a successful reconnection).

Fired upon disconnection. The list of possible disconnection reasons:

In the first two cases (explicit disconnection), the client will not try to reconnect and you need to manually call socket.connect().

In all other cases, the client will wait for a small random delay and then try to reconnect:

Fired when an namespace middleware error occurs.

- (Number)
- url (String) (defaults to window.location.host)
- options (Object)forceNew (Boolean) whether to reuse an existing connection
- forceNew (Boolean) whether to reuse an existing connection
- Returns Socket
- url (String)
- options (Object)
- Returns Manager
- value (Boolean)
- Returns Manager|Boolean
- value (Number)
- Returns Manager|Number
- value (Number)
- Returns Manager|Number
- value (Number)
- Returns Manager|Number
- value (Number)
- Returns Manager|Number
- callback (Function)
- Returns Manager
- nsp (String)
- options (Object)
- Returns Socket
- error (Object) error object
- attempt (Number) reconnection attempt number
- attempt (Number) reconnection attempt number
- error (Object) error object
- (String)
- (Boolean)
- (Boolean)
- Returns Socket
- args
- ack (Function)
- Returns Socket
- eventName (String)
- args
- ack (Function)
- Returns true
- eventName (String)
- callback (Function)
- Returns Socket
- callback (Function)
- callback (Function)
- listener (Function)
- Returns Function[]
- value (Boolean)
- Returns Socket
- Returns Socket
- client-side: "io client disconnect"
- server-side: "client namespace disconnect"
- the socket is not connected
- the low-level transport is not writable (for example, when a POST request is already running in HTTP long-polling mode)
- reason (String)
- connect_error (Object) error object
```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io("http://localhost");</script>
```

```js
const io = require("socket.io-client");// or with import syntaximport { io } from "socket.io-client";
```

```js
const io = require("socket.io-client");const socket = io("ws://example.com/my-namespace", {  reconnectionDelayMax: 10000,  auth: {    token: "123"  },  query: {    "my-key": "my-value"  }});
```

```js
const { Manager } = require("socket.io-client");const manager = new Manager("ws://example.com", {  reconnectionDelayMax: 10000,  query: {    "my-key": "my-value"  }});const socket = manager.socket("/my-namespace", {  auth: {    token: "123"  }});
```

```js
socket.io.on("error", (error) => {  // ...});
```

```js
socket.io.on("reconnect", (attempt) => {  // ...});
```

```js
socket.io.on("reconnect_attempt", (attempt) => {  // ...});
```

```js
socket.io.on("reconnect_error", (error) => {  // ...});
```

```js
socket.io.on("reconnect_failed", () => {  // ...});
```

```js
socket.io.on("ping", () => {  // ...});
```

```js
socket.emit("hello", { a: "b", c: [] });socket.on("hey", (...args) => {  // ...});
```

```js
const socket = io("http://localhost");console.log(socket.id); // undefinedsocket.on("connect", () => {  console.log(socket.id); // "G5p5..."});
```

```js
const socket = io("http://localhost");socket.on("connect", () => {  console.log(socket.connected); // true});
```

```js
const socket = io("http://localhost");socket.on("connect", () => {  console.log(socket.disconnected); // false});
```

```js
const socket = io({  autoConnect: false});// ...socket.connect();
```

```js
socket.on("disconnect", () => {  socket.connect();});
```

```js
socket.emit("hello", "world");socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6, 7, 8]) });
```

```js
socket.emit("ferret", "tobi", (data) => {  console.log(data); // data will be "woot"});// server://  io.on("connection", (socket) => {//    socket.on("ferret", (name, fn) => {//      fn("woot");//    });//  });
```

```js
socket.on("news", (data) => {  console.log(data);});// with multiple argumentssocket.on("news", (arg1, arg2, arg3, arg4) => {  // ...});// with callbacksocket.on("news", (cb) => {  cb(0);});
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
const listeners = socket.listenersAny();
```

```js
socket.compress(false).emit("an event", { some: "data" });
```

```js
socket.volatile.emit(/* ... */); // the server may or may not receive it
```

```js
socket.on("connect", () => {  // ...});// note: you should register event handlers outside of connect,// so they are not registered again on reconnectionsocket.on("myevent", () => {  // ...});
```

```js
socket.on("disconnect", (reason) => {  if (reason === "io server disconnect") {    // the disconnection was initiated by the server, you need to reconnect manually    socket.connect();  }  // else the socket will automatically try to reconnect});
```

```js
socket.on("connect_error", (error) => {  // ...});
```

```js
require("socket.io-client")
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io("http://localhost");</script>
```

```js
const io = require("socket.io-client");// or with import syntaximport { io } from "socket.io-client";
```

```js
url
```

```js
window.location.host
```

```js
options
```

```js
forceNew
```

```js
Socket
```

```js
Manager
```

```js
Manager
```

```js
multiplex
```

```js
false
```

```js
"force new connection": true
```

```js
forceNew: true
```

```js
Socket
```

```js
url
```

```js
http://localhost/users
```

```js
http://localhost
```

```js
/users
```

```js
query
```

```js
http://localhost/users?token=abc
```

```js
const io = require("socket.io-client");const socket = io("ws://example.com/my-namespace", {  reconnectionDelayMax: 10000,  auth: {    token: "123"  },  query: {    "my-key": "my-value"  }});
```

```js
const { Manager } = require("socket.io-client");const manager = new Manager("ws://example.com", {  reconnectionDelayMax: 10000,  query: {    "my-key": "my-value"  }});const socket = manager.socket("/my-namespace", {  auth: {    token: "123"  }});
```

```js
options
```

```js
manager.socket("/my-namespace", options )
```

```js
auth
```

```js
options
```

```js
query: {…}
```

```js
new Manager(uri, options)
```

```js
auth
```

```js
query
```

```js
Manager
```

```js
Manager
```

```js
Manager
```

```js
url
```

```js
options
```

```js
Manager
```

```js
path
```

```js
/socket.io
```

```js
reconnection
```

```js
true
```

```js
reconnectionAttempts
```

```js
Infinity
```

```js
reconnectionDelay
```

```js
1000
```

```js
randomizationFactor
```

```js
reconnectionDelayMax
```

```js
5000
```

```js
randomizationFactor
```

```js
0.5
```

```js
timeout
```

```js
20000
```

```js
error
```

```js
autoConnect
```

```js
true
```

```js
manager.open
```

```js
query
```

```js
socket.handshake.query
```

```js
parser
```

```js
Parser
```

```js
upgrade
```

```js
true
```

```js
forceJSONP
```

```js
false
```

```js
jsonp
```

```js
true
```

```js
forceBase64
```

```js
false
```

```js
enablesXDR
```

```js
false
```

```js
false
```

```js
timestampRequests
```

```js
false
```

```js
timestampParam
```

```js
transports
```

```js
["polling", "websocket"]
```

```js
Engine
```

```js
transportOptions
```

```js
rememberUpgrade
```

```js
false
```

```js
onlyBinaryUpgrades
```

```js
false
```

```js
requestTimeout
```

```js
protocols
```

```js
agent
```

```js
false
```

```js
http.Agent
```

```js
pfx
```

```js
key
```

```js
passphrase
```

```js
cert
```

```js
ciphers
```

```js
rejectUnauthorized
```

```js
true
```

```js
perMessageDeflate
```

```js
true
```

```js
false
```

```js
extraHeaders
```

```js
forceNode
```

```js
false
```

```js
localAddress
```

```js
value
```

```js
Manager|Boolean
```

```js
reconnection
```

```js
value
```

```js
Manager|Number
```

```js
reconnectionAttempts
```

```js
value
```

```js
Manager|Number
```

```js
reconnectionDelay
```

```js
value
```

```js
Manager|Number
```

```js
reconnectionDelayMax
```

```js
value
```

```js
Manager|Number
```

```js
timeout
```

```js
callback
```

```js
Manager
```

```js
autoConnect
```

```js
false
```

```js
callback
```

```js
nsp
```

```js
options
```

```js
Socket
```

```js
Socket
```

```js
auth
```

```js
{ auth: {key: "value"} }
```

```js
options
```

```js
new Manager(nsp, options)
```

```js
error
```

```js
socket.io.on("error", (error) => {  // ...});
```

```js
attempt
```

```js
socket.io.on("reconnect", (attempt) => {  // ...});
```

```js
attempt
```

```js
socket.io.on("reconnect_attempt", (attempt) => {  // ...});
```

```js
error
```

```js
socket.io.on("reconnect_error", (error) => {  // ...});
```

```js
reconnectionAttempts
```

```js
socket.io.on("reconnect_failed", () => {  // ...});
```

```js
socket.io.on("ping", () => {  // ...});
```

```js
Socket
```

```js
Socket
```

```js
Socket
```

```js
socket.emit("hello", { a: "b", c: [] });socket.on("hey", (...args) => {  // ...});
```

```js
connect
```

```js
reconnect
```

```js
const socket = io("http://localhost");console.log(socket.id); // undefinedsocket.on("connect", () => {  console.log(socket.id); // "G5p5..."});
```

```js
const socket = io("http://localhost");socket.on("connect", () => {  console.log(socket.connected); // true});
```

```js
const socket = io("http://localhost");socket.on("connect", () => {  console.log(socket.disconnected); // false});
```

```js
Socket
```

```js
const socket = io({  autoConnect: false});// ...socket.connect();
```

```js
socket.on("disconnect", () => {  socket.connect();});
```

```js
args
```

```js
ack
```

```js
Socket
```

```js
message
```

```js
eventName
```

```js
args
```

```js
ack
```

```js
true
```

```js
Buffer
```

```js
socket.emit("hello", "world");socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6, 7, 8]) });
```

```js
ack
```

```js
socket.emit("ferret", "tobi", (data) => {  console.log(data); // data will be "woot"});// server://  io.on("connection", (socket) => {//    socket.on("ferret", (name, fn) => {//      fn("woot");//    });//  });
```

```js
eventName
```

```js
callback
```

```js
Socket
```

```js
socket.on("news", (data) => {  console.log(data);});// with multiple argumentssocket.on("news", (arg1, arg2, arg3, arg4) => {  // ...});// with callbacksocket.on("news", (cb) => {  cb(0);});
```

```js
hasListeners
```

```js
once
```

```js
off
```

```js
callback
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
callback
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
listener
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
Function[]
```

```js
const listeners = socket.listenersAny();
```

```js
value
```

```js
Socket
```

```js
true
```

```js
true
```

```js
socket.compress(false).emit("an event", { some: "data" });
```

```js
Socket
```

```js
"io client disconnect"
```

```js
"client namespace disconnect"
```

```js
POST
```

```js
socket.volatile.emit(/* ... */); // the server may or may not receive it
```

```js
socket.on("connect", () => {  // ...});// note: you should register event handlers outside of connect,// so they are not registered again on reconnectionsocket.on("myevent", () => {  // ...});
```

```js
reason
```

```js
io server disconnect
```

```js
io client disconnect
```

```js
ping timeout
```

```js
pingInterval + pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
socket.connect()
```

```js
socket.on("disconnect", (reason) => {  if (reason === "io server disconnect") {    // the disconnection was initiated by the server, you need to reconnect manually    socket.connect();  }  // else the socket will automatically try to reconnect});
```

```js
connect_error
```

```js
socket.on("connect_error", (error) => {  // ...});
```

# https://socket.io/docs/v3/client-initialization

# Client Initialization

## From the same domain​

## From a different domain​

## Custom namespace​

## Options​

### IO factory options​

### Low-level engine options​

### Manager options​

### Socket options​

Once you have installed the Socket.IO client library, you can now init the client. The complete list of options can be found below.

In the examples below, the io object comes either from:

If your front is served on the same domain as your server, you can simply use:

The server URL will be deduced from the window.location object.

In case your front is not served from the same domain as your server, you have to pass the URL of your server.

In that case, please make sure to enable Cross-Origin Resource Sharing (CORS) on the server.

Note: You can use either https or wss (respectively, http or ws).

In the examples above, the client will connect to the main namespace. Using only the main namespace should be sufficient for most use cases, but you can specify the namespace with:

You can find more details about namespaces here.

Default value: false

Whether to create a new Manager instance.

A Manager instance is in charge of the low-level connection to the server (established with HTTP long-polling or WebSocket). It handles the reconnection logic.

A Socket instance is the interface which is used to sends events to — and receive events from — the server. It belongs to a given namespace.

A single Manager can be attached to several Socket instances.

The following example will reuse the same Manager instance for the 3 Socket instances (one single WebSocket connection):

The following example will create 3 different Manager instances (and thus 3 distinct WebSocket connections):

Reusing an existing namespace will also create a new Manager each time:

Default value: true

The opposite of forceNew: whether to reuse an existing Manager instance.

Note: These settings will be shared by all Socket instances attached to the same Manager.

Default value: ["polling", "websocket"]

The low-level connection to the Socket.IO server can either be established with:

The following example disables the HTTP long-polling transport:

Note: in that case, sticky sessions are not required on the server side (more information here).

By default, the HTTP long-polling connection is established first, and then an upgrade to WebSocket is attempted (explanation here). You can use WebSocket first with:

One possible downside is that the validity of your CORS configuration will only be checked if the WebSocket connection fails to be established.

Default value: true

Whether the client should try to upgrade the transport from HTTP long-polling to something better.

Default value: false

If true and if the previous WebSocket connection to the server succeeded, the connection attempt will bypass the normal upgrade process and will initially try WebSocket. A connection attempt following a transport error will use the normal upgrade process. It is recommended you turn this on only when using SSL/TLS connections, or if you know that your network does not block websockets.

Default value: /socket.io/

It is the name of the path that is captured on the server side.

The server and the client values must match (unless you are using a path-rewriting proxy in between):

Client

Server

Please note that this is different from the path in the URI, which represents the Namespace.

Example:

Default value: -

Additional query parameters (then found in socket.handshake.query object on the server-side).

Example:

Client

Server

The query parameters cannot be updated for the duration of the session, so changing the query on the client-side will only be effective when the current session gets closed and a new one is created:

Note: the following query parameters are reserved and can't be used in your application:

Default value: -

Additional headers (then found in socket.handshake.headers object on the server-side).

Example:

Client

Server

A few notes:

This will work in Node.js or in React-Native though.

Default value: false

Whether or not cross-site requests should made using credentials such as cookies, authorization headers or TLS client certificates. Setting withCredentials has no effect on same-site requests.

Documentation:

Default value: false

Whether to force base64 encoding for binary content sent over WebSocket (always enabled for HTTP long-polling).

Default value: true

Whether to add the timestamp query param to each request (for cache busting).

Default value: "t"

The name of the query parameter to use as our timestamp key.

The following options are supported:

Please refer to the Node.js documentation:

Example with a self-signed certificate:

Example with client-certificate authentication:

Import note: rejectUnauthorized is a Node.js-only option, it will not bypass the security check in the browser:

Note: These settings will be shared by all Socket instances attached to the same Manager.

Default value: true

Whether reconnection is enabled or not. If set to false, you need to manually reconnect:

Default value: Infinity

The number of reconnection attempts before giving up.

Default value: 1000

The initial delay before reconnection in milliseconds (affected by the randomizationFactor value).

Default value: 5000

The maximum delay between two reconnection attempts. Each attempt increases the reconnection delay by 2x.

Default value: 0.5

The randomization factor used when reconnecting (so that the clients do not reconnect at the exact same time after a server crash, for example).

Example with the default values:

Default value: 20000

The timeout in milliseconds for each connection attempt.

Default value: true

Whether to automatically connect upon creation. If set to false, you need to manually connect:

Added in v2.2.0

Default value: require("socket.io-parser")

The parser used to marshall/unmarshall packets. Please see here for more information.

Note: These settings are specific to the given Socket instance.

Added in v3.0.0

Default value: -

Credentials that are sent when accessing a namespace (see also here).

Example:

Client

Server

You can update the auth map when the access to the Namespace is denied:

Or manually force the Socket instance to reconnect:

- Client
- Initialization
- the <script> import
- NPM
- IO factory optionsforceNewmultiplex
- forceNew
- multiplex
- Low-level engine optionstransportsupgraderememberUpgradepathqueryextraHeaderswithCredentialsforceBase64timestampRequeststimestampParamNode.js-specific options (like agent, cert or rejectUnauthorized)
- transports
- upgrade
- rememberUpgrade
- path
- query
- extraHeaders
- withCredentials
- forceBase64
- timestampRequests
- timestampParam
- Node.js-specific options (like agent, cert or rejectUnauthorized)
- Manager optionsreconnectionreconnectionAttemptsreconnectionDelayreconnectionDelayMaxrandomizationFactortimeoutautoConnectparser
- reconnection
- reconnectionAttempts
- reconnectionDelay
- reconnectionDelayMax
- randomizationFactor
- timeout
- autoConnect
- parser
- Socket optionsauth
- auth
- HTTP long-polling: successive HTTP requests (POST for writing, GET for reading)
- WebSocket
- the Socket instance is attached to the "order" Namespace
- the HTTP requests will look like: GET https://example.com/my-custom-path/?EIO=4&transport=polling&t=ML4jUwU
- EIO: the version of the protocol (currently, "4")
- transport: the transport name ("polling" or "websocket")
- sid: the session ID
- j: if the transport is polling but a JSONP response is required
- t: a hashed-timestamp used for cache-busting
- this will not work when using only WebSocket in a browser
- you can update the headers during a session, but it will not be reflected on the server-side (as the socket.handshake.headers object contains the headers that were sent during the Socket.IO handshake).
- XMLHttpRequest.withCredentials
- Handling CORS
- agent
- pfx
- key
- passphrase
- cert
- ciphers
- rejectUnauthorized
- tls.connect(options[, callback])
- tls.createSecureContext([options])
- Client
- Server
- Client
- Server
- 1st reconnection attempt happens between 500 and 1500 ms (1000 * 2^0 * (<something between -0.5 and 1.5>))
- 2nd reconnection attempt happens between 1000 and 3000 ms (1000 * 2^1 * (<something between -0.5 and 1.5>))
- 3rd reconnection attempt happens between 2000 and 5000 ms (1000 * 2^2 * (<something between -0.5 and 1.5>))
- next reconnection attempts happen after 5000 ms
```js
<script src="/socket.io/socket.io.js"></script>
```

```js
// ES6 import or TypeScriptimport { io } from "socket.io-client";// CommonJSconst io = require("socket.io-client");
```

```js
const socket = io();
```

```js
const socket = io("https://server-domain.com");
```

```js
// the following forms are similarconst socket = io("https://server-domain.com");const socket = io("wss://server-domain.com");const socket = io("server-domain.com"); // only in the browser when the page is served over https (will not work in Node.js)
```

```js
// same origin versionconst socket = io("/admin");// cross origin versionconst socket = io("https://server-domain.com/admin");
```

```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product"); // the "product" namespaceconst orderSocket = io("https://example.com/order"); // the "order" namespace
```

```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product", { forceNew: true }); // the "product" namespaceconst orderSocket = io("https://example.com/order", { forceNew: true }); // the "order" namespace
```

```js
const socket1 = io(); // 1st managerconst socket2 = io(); // 2nd managerconst socket3 = io("/admin"); // reuse the 1st managerconst socket4 = io("/admin"); // 3rd manager
```

```js
const socket = io("https://example.com", { transports: ["websocket"] });
```

```js
const socket = io("https://example.com", {  transports: ["websocket", "polling"] // use WebSocket first, if available});socket.on("connect_error", () => {  // revert to classic upgrade  socket.io.opts.transports = ["polling", "websocket"];});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com/order", {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io({  query: {    x: 42  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.query); // prints { x: "42", EIO: "4", transport: "polling" }});
```

```js
socket.io.on("reconnect_attempt", () => {  socket.io.opts.query.x++;});
```

```js
import { io } from "socket.io-client";const socket = io({  extraHeaders: {    "my-custom-header": "1234"  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.headers); // an object containing "my-custom-header": "1234"});
```

```js
import { io } from "socket.io-client";const socket = io({  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234" // WARN: this will be ignored in a browser  }});
```

```js
const socket = io({  extraHeaders: {    count: 0  }});setInterval(() => {  socket.io.opts.extraHeaders.count++;}, 1000);
```

```js
import { io } from "socket.io-client";const socket = io({  withCredentials: true});
```

```js
const fs = require("fs");const socket = require("socket.io-client")("https://example.com", {  ca: fs.readFileSync("./cert.pem")});
```

```js
const fs = require("fs");const server = require("https").createServer({  cert: fs.readFileSync("./cert.pem"),  key: fs.readFileSync("./key.pem")});const io = require("socket.io")(server);
```

```js
const fs = require("fs");const socket = require("socket.io-client")("https://example.com", {  ca: fs.readFileSync("./server-cert.pem"),  cert: fs.readFileSync("./client-cert.pem"),  key: fs.readFileSync("./client-key.pem"),});
```

```js
const fs = require("fs");const server = require("https").createServer({  cert: fs.readFileSync("./server-cert.pem"),  key: fs.readFileSync("./server-key.pem"),  requestCert: true,  ca: [    fs.readFileSync('client-cert.pem')  ]});const io = require("socket.io")(server);
```

```js
import { io } from "socket.io-client";const socket = io({  reconnection: false});const tryReconnect = () => {  setTimeout(() => {    socket.io.open((err) => {      if (err) {        tryReconnect();      }    });  }, 2000);}socket.io.on("close", tryReconnect);
```

```js
import { io } from "socket.io-client";const socket = io({  autoConnect: false});socket.connect();// orsocket.io.open();
```

```js
import { io } from "socket.io-client";const socket = io({  auth: {    token: "abcd"  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.auth); // prints { token: "abcd" }});
```

```js
socket.on("connect_error", (err) => {  if (err.message === "invalid credentials") {    socket.auth.token = "efgh";    socket.connect();  }});
```

```js
socket.auth.token = "efgh";socket.disconnect().connect();
```

```js
<script>
```

```js
<script src="/socket.io/socket.io.js"></script>
```

```js
// ES6 import or TypeScriptimport { io } from "socket.io-client";// CommonJSconst io = require("socket.io-client");
```

```js
const socket = io();
```

```js
const socket = io("https://server-domain.com");
```

```js
https
```

```js
wss
```

```js
http
```

```js
// the following forms are similarconst socket = io("https://server-domain.com");const socket = io("wss://server-domain.com");const socket = io("server-domain.com"); // only in the browser when the page is served over https (will not work in Node.js)
```

```js
// same origin versionconst socket = io("/admin");// cross origin versionconst socket = io("https://server-domain.com/admin");
```

```js
agent
```

```js
cert
```

```js
rejectUnauthorized
```

```js
forceNew
```

```js
false
```

```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product"); // the "product" namespaceconst orderSocket = io("https://example.com/order"); // the "order" namespace
```

```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product", { forceNew: true }); // the "product" namespaceconst orderSocket = io("https://example.com/order", { forceNew: true }); // the "order" namespace
```

```js
const socket1 = io(); // 1st managerconst socket2 = io(); // 2nd managerconst socket3 = io("/admin"); // reuse the 1st managerconst socket4 = io("/admin"); // 3rd manager
```

```js
multiplex
```

```js
true
```

```js
forceNew
```

```js
transports
```

```js
["polling", "websocket"]
```

```js
POST
```

```js
GET
```

```js
const socket = io("https://example.com", { transports: ["websocket"] });
```

```js
const socket = io("https://example.com", {  transports: ["websocket", "polling"] // use WebSocket first, if available});socket.on("connect_error", () => {  // revert to classic upgrade  socket.io.opts.transports = ["polling", "websocket"];});
```

```js
upgrade
```

```js
true
```

```js
rememberUpgrade
```

```js
false
```

```js
path
```

```js
/socket.io/
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com/order", {  path: "/my-custom-path/"});
```

```js
GET https://example.com/my-custom-path/?EIO=4&transport=polling&t=ML4jUwU
```

```js
query
```

```js
socket.handshake.query
```

```js
import { io } from "socket.io-client";const socket = io({  query: {    x: 42  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.query); // prints { x: "42", EIO: "4", transport: "polling" }});
```

```js
query
```

```js
socket.io.on("reconnect_attempt", () => {  socket.io.opts.query.x++;});
```

```js
EIO
```

```js
transport
```

```js
sid
```

```js
extraHeaders
```

```js
socket.handshake.headers
```

```js
import { io } from "socket.io-client";const socket = io({  extraHeaders: {    "my-custom-header": "1234"  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.headers); // an object containing "my-custom-header": "1234"});
```

```js
import { io } from "socket.io-client";const socket = io({  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234" // WARN: this will be ignored in a browser  }});
```

```js
socket.handshake.headers
```

```js
const socket = io({  extraHeaders: {    count: 0  }});setInterval(() => {  socket.io.opts.extraHeaders.count++;}, 1000);
```

```js
withCredentials
```

```js
false
```

```js
withCredentials
```

```js
import { io } from "socket.io-client";const socket = io({  withCredentials: true});
```

```js
forceBase64
```

```js
false
```

```js
timestampRequests
```

```js
true
```

```js
timestampParam
```

```js
"t"
```

```js
agent
```

```js
pfx
```

```js
key
```

```js
passphrase
```

```js
cert
```

```js
ciphers
```

```js
rejectUnauthorized
```

```js
const fs = require("fs");const socket = require("socket.io-client")("https://example.com", {  ca: fs.readFileSync("./cert.pem")});
```

```js
const fs = require("fs");const server = require("https").createServer({  cert: fs.readFileSync("./cert.pem"),  key: fs.readFileSync("./key.pem")});const io = require("socket.io")(server);
```

```js
const fs = require("fs");const socket = require("socket.io-client")("https://example.com", {  ca: fs.readFileSync("./server-cert.pem"),  cert: fs.readFileSync("./client-cert.pem"),  key: fs.readFileSync("./client-key.pem"),});
```

```js
const fs = require("fs");const server = require("https").createServer({  cert: fs.readFileSync("./server-cert.pem"),  key: fs.readFileSync("./server-key.pem"),  requestCert: true,  ca: [    fs.readFileSync('client-cert.pem')  ]});const io = require("socket.io")(server);
```

```js
rejectUnauthorized
```

```js
true
```

```js
false
```

```js
import { io } from "socket.io-client";const socket = io({  reconnection: false});const tryReconnect = () => {  setTimeout(() => {    socket.io.open((err) => {      if (err) {        tryReconnect();      }    });  }, 2000);}socket.io.on("close", tryReconnect);
```

```js
Infinity
```

```js
1000
```

```js
5000
```

```js
0.5
```

```js
1000 * 2^0 * (<something between -0.5 and 1.5>)
```

```js
1000 * 2^1 * (<something between -0.5 and 1.5>)
```

```js
1000 * 2^2 * (<something between -0.5 and 1.5>)
```

```js
20000
```

```js
true
```

```js
false
```

```js
import { io } from "socket.io-client";const socket = io({  autoConnect: false});socket.connect();// orsocket.io.open();
```

```js
parser
```

```js
require("socket.io-parser")
```

```js
auth
```

```js
import { io } from "socket.io-client";const socket = io({  auth: {    token: "abcd"  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.auth); // prints { token: "abcd" }});
```

```js
auth
```

```js
socket.on("connect_error", (err) => {  if (err.message === "invalid credentials") {    socket.auth.token = "efgh";    socket.connect();  }});
```

```js
socket.auth.token = "efgh";socket.disconnect().connect();
```

# https://socket.io/docs/v3/client-installation

# Client Installation

## Version compatibility​

## Browser support​

## Release notes​

## Installation​

### Standalone build​

### From a CDN​

### From NPM​

Here is the compatibility table between the server and the JS client:

[1] Yes, with allowEIO3: true

Please check the associated migration guides:

Socket.IO does support IE9 and above. IE 6/7/8 are not supported anymore.

Browser compatibility is tested thanks to the awesome Sauce Labs platform:

The release notes of each version can be found in GitHub.

By default, the Socket.IO server exposes a client bundle at /socket.io/socket.io.js.

io will be registered as a global variable:

If you don't need this (see other options below), you can disable the functionality on the server side:

You can also include the client bundle from a CDN:

Socket.IO is also available from other CDN:

There are several bundles available:

The debug package allows to print debug information to the console. You can find more information here.

During development, we recommend using the socket.io.js bundle. By setting localStorage.debug = 'socket.io-client:socket', any event received by the client will be printed to the console.

For production, please use the socket.io.min.js bundle, which is an optimized build excluding the debug package.

The Socket.IO client is compatible with bundlers like webpack or browserify.

The client can also be run from Node.js.

Note: for the reasons cited above, you may want to exclude debug from your browser bundle. With webpack, you can use webpack-remove-debug.

Note for TypeScript users: the types are now included in the socket.io-client package and thus the types from @types/socket.io-client are not needed anymore and may in fact cause errors:

- Client
- Installation
- v2 to v3
- v3 to v4
- cdnjs: https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.1.3/socket.io.min.js
- jsDelivr: https://cdn.jsdelivr.net/npm/socket.io-client@3.1.3/dist/socket.io.min.js
- unpkg: https://unpkg.com/socket.io-client@3.1.3/dist/socket.io.min.js
```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
const io = require("socket.io")({  serveClient: false});
```

```js
<script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>
```

```js
$ npm install socket.io-client
```

```js
Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
```

```js
allowEIO3: true
```

```js
/socket.io/socket.io.js
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
const io = require("socket.io")({  serveClient: false});
```

```js
<script src="https://cdn.socket.io/3.1.3/socket.io.min.js" integrity="sha384-cPwlPLvBTa3sKAgddT6krw0cJat7egBga3DJepJyrLl4Q9/5WLra3rrnMcyTyOnh" crossorigin="anonymous"></script>
```

```js
socket.io.js
```

```js
localStorage.debug = 'socket.io-client:socket'
```

```js
socket.io.min.js
```

```js
$ npm install socket.io-client
```

```js
socket.io-client
```

```js
@types/socket.io-client
```

```js
Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
```

# https://socket.io/docs/v3/client-offline-behavior

# Offline behavior

## Buffered events​

By default, any event emitted while the Socket is not connected will be buffered until reconnection.

While useful in most cases (when the reconnection delay is short), it could result in a huge spike of events when the connection is restored.

There are several solutions to prevent this behavior, depending on your use case:

- Client
- Offline behavior
- use the connected attribute of the Socket instance
- use volatile events
- empty the internal buffer upon reconnection
```js
if (socket.connected) {  socket.emit( /* ... */ );} else {  // ...}
```

```js
socket.volatile.emit( /* ... */ );
```

```js
socket.on("connect", () => {  socket.sendBuffer = [];});
```

```js
if (socket.connected) {  socket.emit( /* ... */ );} else {  // ...}
```

```js
socket.volatile.emit( /* ... */ );
```

```js
socket.on("connect", () => {  socket.sendBuffer = [];});
```

# https://socket.io/docs/v3/client-socket-instance

# The Socket instance (client-side)

## Socket#id​

## Socket#connected​

## Lifecycle​

## Events​

### connect​

### connect_error​

### disconnect​

Besides emitting and listening to events, the Socket instance has a few attributes that may be of use in your application:

Each new connection is assigned a random 20-characters identifier.

This identifier is synced with the value on the server-side.

This attribute describes whether the socket is currently connected to the server.

The Socket instance emits three special events:

Please note that since Socket.IO v3, the Socket instance does not emit any event related to the reconnection logic anymore. You can listen to the events on the Manager instance directly:

More information can be found in the migration guide.

This event is fired by the Socket instance upon connection and reconnection.

Please note that you shouldn't register event handlers in the connect handler itself, as a new handler will be registered every time the Socket reconnects:

This event is fired when:

In the first case, the Socket will automatically try to reconnect, after a given delay.

In the latter case, you need to manually reconnect. You might need to update the credentials:

This event is fired upon disconnection.

Here is the list of possible reasons:

In the first two cases (explicit disconnection), the client will not try to reconnect and you need to manually call socket.connect().

In all other cases, the client will wait for a small random delay and then try to reconnect:

Note: those events, along with disconnecting, newListener and removeListener, are special events that shouldn't be used in your application:

- Client
- The Socket instance
- connect
- connect_error
- disconnect
- the low-level connection cannot be established
- the connection is denied by the server in a middleware function
```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});// client-sidesocket.on("connect", () => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});socket.on("disconnect", () => {  console.log(socket.id); // undefined});
```

```js
socket.on("connect", () => {  console.log(socket.connected); // true});socket.on("disconnect", () => {  console.log(socket.connected); // false});
```

```js
socket.io.on("reconnection_attempt", () => {  // ...});socket.io.on("reconnect", () => {  // ...});
```

```js
socket.on("connect", () => {  // ...});
```

```js
// BADsocket.on("connect", () => {  socket.on("data", () => { /* ... */ });});// GOODsocket.on("connect", () => {  // ...});socket.on("data", () => { /* ... */ });
```

```js
// either by directly modifying the `auth` attributesocket.on("connect_error", () => {  socket.auth.token = "abcd";  socket.connect();});// or if the `auth` attribute is a functionconst socket = io({  auth: (cb) => {    cb(localStorage.getItem("token"));  }});socket.on("connect_error", () => {  setTimeout(() => {    socket.connect();  }, 1000);});
```

```js
socket.on("disconnect", (reason) => {  // ...});
```

```js
socket.on("disconnect", (reason) => {  if (reason === "io server disconnect") {    // the disconnection was initiated by the server, you need to reconnect manually    socket.connect();  }  // else the socket will automatically try to reconnect});
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});// client-sidesocket.on("connect", () => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});socket.on("disconnect", () => {  console.log(socket.id); // undefined});
```

```js
socket.on("connect", () => {  console.log(socket.connected); // true});socket.on("disconnect", () => {  console.log(socket.connected); // false});
```

```js
connect
```

```js
connect_error
```

```js
disconnect
```

```js
socket.io.on("reconnection_attempt", () => {  // ...});socket.io.on("reconnect", () => {  // ...});
```

```js
connect
```

```js
socket.on("connect", () => {  // ...});
```

```js
connect
```

```js
// BADsocket.on("connect", () => {  socket.on("data", () => { /* ... */ });});// GOODsocket.on("connect", () => {  // ...});socket.on("data", () => { /* ... */ });
```

```js
connect_error
```

```js
// either by directly modifying the `auth` attributesocket.on("connect_error", () => {  socket.auth.token = "abcd";  socket.connect();});// or if the `auth` attribute is a functionconst socket = io({  auth: (cb) => {    cb(localStorage.getItem("token"));  }});socket.on("connect_error", () => {  setTimeout(() => {    socket.connect();  }, 1000);});
```

```js
disconnect
```

```js
socket.on("disconnect", (reason) => {  // ...});
```

```js
io server disconnect
```

```js
io client disconnect
```

```js
ping timeout
```

```js
pingInterval + pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
socket.connect()
```

```js
socket.on("disconnect", (reason) => {  if (reason === "io server disconnect") {    // the disconnection was initiated by the server, you need to reconnect manually    socket.connect();  }  // else the socket will automatically try to reconnect});
```

```js
disconnecting
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

# https://socket.io/docs/v3/custom-parser

# Custom parser

## Implementing your own parser​

## The default parser​

## The msgpack parser​

Since Socket.IO v2.0.0, it is now possible to provide your own parser, in order to control the marshalling / unmarshalling of packets.

Server

Client

Here is a basic example with a parser that uses the JSON.stringify() and JSON.parse() methods:

The source code of the default parser (the socket.io-parser package) can be found here: https://github.com/socketio/socket.io-parser

Example of output:

will be encoded as:

will be encoded as:

Pros:

Cons:

This parser uses the MessagePack serialization format.

The source code of this parser can be found here: https://github.com/socketio/socket.io-msgpack-parser

Sample usage:

Server

Client (Node.js)

In the browser, there is now an official bundle which includes this parser:

In that case, you don't need to specify the parser option.

Pros:

Cons:

Please note that socket.io-msgpack-parser relies on the notepack.io MessagePack implementation. This implementation mainly focuses on performance and minimal bundle size, and thus does not support features like extension types. For a parser based on the official JavaScript implementation, please check this package.

- Advanced
- Custom parser
- basic emit
- emit with binary, acknowledgement and custom namespace
- the binary attachments is then base64-encoded, so this parser is compatible with browsers that do not support Arraybuffers, like IE9
- packets with binary content are sent as two distinct WebSocket frames (if the WebSocket connection is established)
- https://cdn.socket.io/3.1.3/socket.io.msgpack.min.js
- cdnjs: https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.1.3/socket.io.msgpack.min.js
- jsDelivr: https://cdn.jsdelivr.net/npm/socket.io-client@3.1.3/dist/socket.io.msgpack.min.js
- unpkg: https://unpkg.com/socket.io-client@3.1.3/dist/socket.io.msgpack.min.js
- packets with binary content are sent as one single WebSocket frame (if the WebSocket connection is established)
- may results in smaller payloads (especially when using a lot of numbers)
- incompatible with browsers that do not support Arraybuffers, like IE9
- harder to debug in the Network tab of the browser
```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  parser: myParser});
```

```js
const socket = io({  parser: myParser});
```

```js
const Emitter = require("component-emitter"); // polyfill of Node.js EventEmitter in the browser class Encoder {  /**   * Encode a packet into a list of strings/buffers   */  encode(packet) {    return [JSON.stringify(packet)];  }}class Decoder extends Emitter {  /**   * Receive a chunk (string or buffer) and optionally emit a "decoded" event with the reconstructed packet   */  add(chunk) {    const packet = JSON.parse(chunk);    if (this.isPacketValid(packet)) {      this.emit("decoded", packet);    } else {      throw new Error("invalid format");    }  }  isPacketValid({ type, data, nsp, id }) {    const isNamespaceValid = typeof nsp === "string";    const isAckIdValid = id === undefined || Number.isInteger(id);    if (!isNamespaceValid || !isAckIdValid) {      return false;    }    switch (type) {      case 0: // CONNECT        return data === undefined || typeof data === "object";      case 1: // DISCONNECT        return data === undefined;      case 2: // EVENT        return Array.isArray(data) && data.length > 0;      case 3: // ACK        return Array.isArray(data);      case 4: // CONNECT_ERROR        return typeof data === "object";      default:        return false;    }  }  /**   * Clean up internal buffers   */  destroy() {}}module.exports = { Encoder, Decoder };
```

```js
socket.emit("test", 42);
```

```js
2["test",42]|||└─ JSON-encoded payload└─ packet type (2 => EVENT)
```

```js
socket.emit("test", Uint8Array.from([42]), () => {  console.log("ack received");});
```

```js
51-/admin,13["test",{"_placeholder":true,"num":0}]||||     || └─ JSON-encoded payload with placeholders for binary attachments||||     |└─ acknowledgement id||||     └─ separator|||└─ namespace (not included when it's the main namespace)||└─ separator|└─ number of binary attachments└─ packet type (5 => BINARY EVENT)and an additional attachment (the extracted Uint8Array)
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  parser: require("socket.io-msgpack-parser")});
```

```js
const socket = require("socket.io-client")("https://example.com", {  parser: require("socket.io-msgpack-parser")});
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  parser: myParser});
```

```js
const socket = io({  parser: myParser});
```

```js
JSON.stringify()
```

```js
JSON.parse()
```

```js
const Emitter = require("component-emitter"); // polyfill of Node.js EventEmitter in the browser class Encoder {  /**   * Encode a packet into a list of strings/buffers   */  encode(packet) {    return [JSON.stringify(packet)];  }}class Decoder extends Emitter {  /**   * Receive a chunk (string or buffer) and optionally emit a "decoded" event with the reconstructed packet   */  add(chunk) {    const packet = JSON.parse(chunk);    if (this.isPacketValid(packet)) {      this.emit("decoded", packet);    } else {      throw new Error("invalid format");    }  }  isPacketValid({ type, data, nsp, id }) {    const isNamespaceValid = typeof nsp === "string";    const isAckIdValid = id === undefined || Number.isInteger(id);    if (!isNamespaceValid || !isAckIdValid) {      return false;    }    switch (type) {      case 0: // CONNECT        return data === undefined || typeof data === "object";      case 1: // DISCONNECT        return data === undefined;      case 2: // EVENT        return Array.isArray(data) && data.length > 0;      case 3: // ACK        return Array.isArray(data);      case 4: // CONNECT_ERROR        return typeof data === "object";      default:        return false;    }  }  /**   * Clean up internal buffers   */  destroy() {}}module.exports = { Encoder, Decoder };
```

```js
socket.io-parser
```

```js
socket.emit("test", 42);
```

```js
2["test",42]|||└─ JSON-encoded payload└─ packet type (2 => EVENT)
```

```js
socket.emit("test", Uint8Array.from([42]), () => {  console.log("ack received");});
```

```js
51-/admin,13["test",{"_placeholder":true,"num":0}]||||     || └─ JSON-encoded payload with placeholders for binary attachments||||     |└─ acknowledgement id||||     └─ separator|||└─ namespace (not included when it's the main namespace)||└─ separator|└─ number of binary attachments└─ packet type (5 => BINARY EVENT)and an additional attachment (the extracted Uint8Array)
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  parser: require("socket.io-msgpack-parser")});
```

```js
const socket = require("socket.io-client")("https://example.com", {  parser: require("socket.io-msgpack-parser")});
```

```js
parser
```

```js
socket.io-msgpack-parser
```

```js
notepack.io
```

# https://socket.io/docs/v3/emit-cheatsheet

# Emit cheatsheet

## Server-side​

## Client-side​

## Reserved events​

On each side, the following events are reserved and should not be used as event names by your application:

- Events
- Emit cheatsheet
- connect
- connect_error
- disconnect
- disconnecting
- newListener
- removeListener
```js
io.on("connection", (socket) => {  // basic emit  socket.emit(/* ... */);  // to all clients in the current namespace except the sender  socket.broadcast.emit(/* ... */);  // to all clients in room1 except the sender  socket.to("room1").emit(/* ... */);  // to all clients in room1 and/or room2 except the sender  socket.to("room1").to("room2").emit(/* ... */);  // to all clients in room1  io.in("room1").emit(/* ... */);  // to all clients in namespace "myNamespace"  io.of("myNamespace").emit(/* ... */);  // to all clients in room1 in namespace "myNamespace"  io.of("myNamespace").to("room1").emit(/* ... */);  // to individual socketid (private message)  io.to(socketId).emit(/* ... */);  // to all clients on this node (when using multiple nodes)  io.local.emit(/* ... */);  // to all connected clients  io.emit(/* ... */);  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.  // with acknowledgement  socket.emit("question", (answer) => {    // ...  });  // without compression  socket.compress(false).emit(/* ... */);  // a message that might be dropped if the low-level transport is not writable  socket.volatile.emit(/* ... */);});
```

```js
// basic emitsocket.emit(/* ... */);// with acknowledgementsocket.emit("question", (answer) => {  // ...});// without compressionsocket.compress(false).emit(/* ... */);// a message that might be dropped if the low-level transport is not writablesocket.volatile.emit(/* ... */);
```

```js
// BAD, will throw an errorsocket.emit("disconnecting");
```

```js
io.on("connection", (socket) => {  // basic emit  socket.emit(/* ... */);  // to all clients in the current namespace except the sender  socket.broadcast.emit(/* ... */);  // to all clients in room1 except the sender  socket.to("room1").emit(/* ... */);  // to all clients in room1 and/or room2 except the sender  socket.to("room1").to("room2").emit(/* ... */);  // to all clients in room1  io.in("room1").emit(/* ... */);  // to all clients in namespace "myNamespace"  io.of("myNamespace").emit(/* ... */);  // to all clients in room1 in namespace "myNamespace"  io.of("myNamespace").to("room1").emit(/* ... */);  // to individual socketid (private message)  io.to(socketId).emit(/* ... */);  // to all clients on this node (when using multiple nodes)  io.local.emit(/* ... */);  // to all connected clients  io.emit(/* ... */);  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.  // with acknowledgement  socket.emit("question", (answer) => {    // ...  });  // without compression  socket.compress(false).emit(/* ... */);  // a message that might be dropped if the low-level transport is not writable  socket.volatile.emit(/* ... */);});
```

```js
// basic emitsocket.emit(/* ... */);// with acknowledgementsocket.emit("question", (answer) => {  // ...});// without compressionsocket.compress(false).emit(/* ... */);// a message that might be dropped if the low-level transport is not writablesocket.volatile.emit(/* ... */);
```

```js
connect
```

```js
connect_error
```

```js
disconnect
```

```js
disconnecting
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnecting");
```

# https://socket.io/docs/v3/emitting-events

# Emitting events

## Basic emit​

## Acknowledgements​

## Volatile events​

There are several ways to send events between the server and the client.

This also works in the other direction:

You can send any number of arguments, and all serializable data structures are supported, including binary objects like Buffer or TypedArray.

There is no need to run JSON.stringify() on objects as it will be done for you.

Note: Map and Set are not serializable and must be manually serialized:

You can add a callback as the last argument of the emit(), and this callback will be called once the other side acknowledges the event:

Timeout are not supported by default, but it is quite straightforward to implement:

Volatile events are events that will not be sent if the underlying connection is not ready (a bit like UDP, in terms of reliability).

This can be interesting for example if you need to send the position of the characters in an online game (as only the latest values are useful).

Another use case is to discard events when the client is not connected (by default, the events are buffered until reconnection).

Example:

If you restart the server, you will see in the console:

Without the volatile flag, you would see:

- Events
- Emitting events
```js
// server-sideio.on("connection", (socket) => {  socket.emit("hello", "world");});// client-sidesocket.on("hello", (arg) => {  console.log(arg); // world});
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("hello", (arg) => {    console.log(arg); // world  });});// client-sidesocket.emit("hello", "world");
```

```js
// server-sideio.on("connection", (socket) => {  socket.emit("hello", 1, "2", { 3: '4', 5: Buffer.from([6]) });});// client-sidesocket.on("hello", (arg1, arg2, arg3) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] }});
```

```js
// BADsocket.emit("hello", JSON.stringify({ name: "John" }));// GOODsocket.emit("hello", { name: "John" });
```

```js
const serializedMap = [...myMap.entries()];const serializedSet = [...mySet.keys()];
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("update item", (arg1, arg2, callback) => {    console.log(arg1); // 1    console.log(arg2); // { name: "updated" }    callback({      status: "ok"    });  });});// client-sidesocket.emit("update item", "1", { name: "updated" }, (response) => {  console.log(response.status); // ok});
```

```js
const withTimeout = (onSuccess, onTimeout, timeout) => {  let called = false;  const timer = setTimeout(() => {    if (called) return;    called = true;    onTimeout();  }, timeout);  return (...args) => {    if (called) return;    called = true;    clearTimeout(timer);    onSuccess.apply(this, args);  }}socket.emit("hello", 1, 2, withTimeout(() => {  console.log("success!");}, () => {  console.log("timeout!");}, 1000));
```

```js
socket.volatile.emit("hello", "might or might not be received");
```

```js
// server-sideio.on("connection", (socket) => {  console.log("connect");  socket.on("ping", (count) => {    console.log(count);  });});// client-sidelet count = 0;setInterval(() => {  socket.volatile.emit("ping", ++count);}, 1000);
```

```js
connect1234# the server is restarted, the client automatically reconnectsconnect91011
```

```js
connect1234# the server is restarted, the client automatically reconnects and sends its buffered eventsconnect567891011
```

```js
// server-sideio.on("connection", (socket) => {  socket.emit("hello", "world");});// client-sidesocket.on("hello", (arg) => {  console.log(arg); // world});
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("hello", (arg) => {    console.log(arg); // world  });});// client-sidesocket.emit("hello", "world");
```

```js
// server-sideio.on("connection", (socket) => {  socket.emit("hello", 1, "2", { 3: '4', 5: Buffer.from([6]) });});// client-sidesocket.on("hello", (arg1, arg2, arg3) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] }});
```

```js
JSON.stringify()
```

```js
// BADsocket.emit("hello", JSON.stringify({ name: "John" }));// GOODsocket.emit("hello", { name: "John" });
```

```js
const serializedMap = [...myMap.entries()];const serializedSet = [...mySet.keys()];
```

```js
emit()
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("update item", (arg1, arg2, callback) => {    console.log(arg1); // 1    console.log(arg2); // { name: "updated" }    callback({      status: "ok"    });  });});// client-sidesocket.emit("update item", "1", { name: "updated" }, (response) => {  console.log(response.status); // ok});
```

```js
const withTimeout = (onSuccess, onTimeout, timeout) => {  let called = false;  const timer = setTimeout(() => {    if (called) return;    called = true;    onTimeout();  }, timeout);  return (...args) => {    if (called) return;    called = true;    clearTimeout(timer);    onSuccess.apply(this, args);  }}socket.emit("hello", 1, 2, withTimeout(() => {  console.log("success!");}, () => {  console.log("timeout!");}, 1000));
```

```js
socket.volatile.emit("hello", "might or might not be received");
```

```js
// server-sideio.on("connection", (socket) => {  console.log("connect");  socket.on("ping", (count) => {    console.log(count);  });});// client-sidelet count = 0;setInterval(() => {  socket.volatile.emit("ping", ++count);}, 1000);
```

```js
connect1234# the server is restarted, the client automatically reconnectsconnect91011
```

```js
volatile
```

```js
connect1234# the server is restarted, the client automatically reconnects and sends its buffered eventsconnect567891011
```

# https://socket.io/docs/v3/faq

# FAQ

## Can I use wildcards in events?​

## Prevent flooding from single connection?​

## Socket.IO with Apache Cordova?​

## Socket.IO on iOS?​

## Socket.IO on Android?​

## Usage with express-session​

Not in Socket.IO directly, but check out this plugin by Hao-kang Den. It provides a Socket.IO middleware to deal with wildcards.

Limit number of events by IP, uniqueUserId or/and socket.id with rate-limiter-flexible package.

Take a look at this tutorial.

Take a look at socket.io-client-swift.

Take a look at socket.io-client.java.

- Miscellaneous
- FAQ
```js
const express = require('express');const session = require('express-session');const app = express();const server = require('http').createServer(app);const io = require('socket.io')(server);const sessionMiddleware = session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }});// register middleware in Expressapp.use(sessionMiddleware);// register middleware in Socket.IOio.use((socket, next) => {  sessionMiddleware(socket.request, {}, next);  // sessionMiddleware(socket.request, socket.request.res, next); will not work with websocket-only  // connections, as 'socket.request.res' will be undefined in that case});io.on('connection', (socket) => {  const session = socket.request.session;  session.connections++;  session.save();});const port = process.env.PORT || 3000;server.listen(port, () => console.log('server listening on port ' + port));
```

```js
uniqueUserId
```

```js
socket.id
```

```js
const express = require('express');const session = require('express-session');const app = express();const server = require('http').createServer(app);const io = require('socket.io')(server);const sessionMiddleware = session({ secret: 'keyboard cat', cookie: { maxAge: 60000 }});// register middleware in Expressapp.use(sessionMiddleware);// register middleware in Socket.IOio.use((socket, next) => {  sessionMiddleware(socket.request, {}, next);  // sessionMiddleware(socket.request, socket.request.res, next); will not work with websocket-only  // connections, as 'socket.request.res' will be undefined in that case});io.on('connection', (socket) => {  const session = socket.request.session;  session.connections++;  session.save();});const port = process.env.PORT || 3000;server.listen(port, () => console.log('server listening on port ' + port));
```

# https://socket.io/docs/v3/glossary

# Glossary

## Adapter​

## Engine.IO​

## Namespace​

## Room​

## Transport​

We will list here the terms that are related to the Socket.IO ecosystem:

An Adapter is a server-side component which is responsible for:

There are currently two official adapters:

The in-memory adapter can be extended to add support for other messaging systems, like RabbitMQ or Google Pub/Sub for example.

Please see the documentation here.

Engine.IO is an internal component of Socket.IO, which is responsible for establishing the low-level connection between the server and the client.

You will find more information here.

A Namespace is a concept that allows splitting the application logic on the server-side.

Please see the documentation here.

A Room is a server-side concept that allows broadcasting data to a subset of clients.

Please see the documentation here.

A Transport represents the low-level way of establishing a connection between the server and the client.

There are currently two implemented transports:

Please see the documentation here.

- Miscellaneous
- Glossary
- Adapter
- Engine.IO
- Namespace
- Room
- Transport
- storing the relationships between the Socket instances and the rooms
- broadcasting events to all (or a subset of) clients
- the in-memory adapter, which is included by default with the Socket.IO server
- the Redis adapter, which is useful when scaling horizontally (see here)
- the MongoDB adapter
- HTTP long-polling
- WebSocket
# https://socket.io/docs/v3/handling-cors

# Handling CORS

## Configuration​

## Troubleshooting​

Since Socket.IO v3, you need to explicitly enable Cross-Origin Resource Sharing (CORS).

All options will be forwarded to the cors package. The complete list of options can be found here.

Example with cookies (withCredentials) and additional headers:

Note: this also applies to localhost if your web application and your server are not served from the same port

You can disallow all cross-origin requests with the allowRequest option:

If you have properly configured your server (see above), this could mean that your browser wasn't able to reach the Socket.IO server.

The following command:

should return something like:

If that's not the case, please check that your server is listening and is actually reachable on the given port.

- Server
- Handling CORS
```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"]  }});
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});// client-sideconst io = require("socket.io-client");const socket = io("https://api.example.com", {  withCredentials: true,  extraHeaders: {    "my-custom-header": "abcd"  }});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "http://localhost:8080",    methods: ["GET", "POST"]  }});httpServer.listen(3000);
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    const noOriginHeader = req.headers.origin === undefined;    callback(null, noOriginHeader);  }});
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=4&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
curl "https://api.example.com/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"]  }});
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});// client-sideconst io = require("socket.io-client");const socket = io("https://api.example.com", {  withCredentials: true,  extraHeaders: {    "my-custom-header": "abcd"  }});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "http://localhost:8080",    methods: ["GET", "POST"]  }});httpServer.listen(3000);
```

```js
allowRequest
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    const noOriginHeader = req.headers.origin === undefined;    callback(null, noOriginHeader);  }});
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=4&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
curl "https://api.example.com/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}
```

# https://socket.io/docs/v3/how-it-works

# How it works

## Engine.IO​

## Socket.IO​

### Transports​

### Handshake​

### Upgrade mechanism​

### Disconnection detection​

The bidirectional channel between the Socket.IO server (Node.js) and the Socket.IO client (browser, Node.js, or another programming language) is established with a WebSocket connection whenever possible, and will use HTTP long-polling as fallback.

The Socket.IO codebase is split into two distinct layers:

Engine.IO is responsible for establishing the low-level connection between the server and the client. It handles:

The source code can be found here:

There are currently two implemented transports:

The HTTP long-polling transport (also simply referred as "polling") consists of successive HTTP requests:

Due to the nature of the transport, successive emits may be concatenated and sent within the same HTTP request.

The WebSocket transport consists, well, in a WebSocket connection, which provides a bidirectional and low-latency communication channel between the server and the client.

Due to the nature of the transport, each emit is sent in its own WebSocket frame (some emits may even result in two distinct WebSocket frames, more information here).

At the beginning of the Engine.IO connection, the server sends some information:

By default, the client establishes the connection with the HTTP long-polling transport.

But, why?

While WebSocket is clearly the best way to establish a bidirectional communication, experience has shown that it is not always possible to establish a WebSocket connection, due to corporate proxies, personal firewall, antivirus software...

From the user perspective, an unsuccessful WebSocket connection can translate in up to at least 10 seconds of waiting for the realtime application to begin exchanging data. This perceptively hurts user experience.

To summarize, Engine.IO focuses on reliability and user experience first, marginal potential UX improvements and increased server performance second.

To upgrade, the client will:

You can check in the Network Monitor of your browser:

The Engine.IO connection is considered as closed when:

There is also a heartbeat mechanism which checks that the connection between the server and the client is still up and running:

At a given interval (the pingInterval value sent in the handshake) the server sends a PING packet and the client has a few seconds (the pingTimeout value) to send a PONG packet back. If the server does not receive a PONG packet back, it will consider that the connection is closed. Conversely, if the client does not receive a PING packet within pingInterval + pingTimeout, it will consider that the connection is closed.

The disconnection reasons are listed here (server-side) and here (client-side).

Socket.IO provides some additional features over the Engine.IO connection:

The source code can be found here:

- Documentation
- How it works
- the low-level plumbing: what we call Engine.IO, the engine inside Socket.IO
- the various transports and the upgrade mechanism
- the disconnection detection
- server: https://github.com/socketio/engine.io
- client: https://github.com/socketio/engine.io-client
- parser: https://github.com/socketio/engine.io-parser
- protocol description: https://github.com/socketio/engine.io-protocol
- HTTP long-polling
- WebSocket
- long-running GET requests, for receiving data from the server
- short-running POST requests, for sending data to the server
- the sid is the ID of the session, it must be included in the sid query parameter in all subsequent HTTP requests
- the upgrades array contains the list of all "better" transports that are supported by the server
- the pingInterval and pingTimeout values are used in the heartbeat mechanism
- ensure its outgoing buffer is empty
- put the current transport in read-only mode
- try to establish a connection with the other transport
- if successful, close the first transport
- handshake (contains the session ID — here, zBjrh...AAAK — that is used in subsequent requests)
- send data (HTTP long-polling)
- receive data (HTTP long-polling)
- upgrade (WebSocket)
- receive data (HTTP long-polling, closed once the WebSocket connection in 4. is successfully established)
- one HTTP request (either GET or POST) fails (for example, when the server is shutdown)
- the WebSocket connection is closed (for example, when the user closes the tab in its browser)
- socket.disconnect() is called on the server-side or on the client-side
- automatic reconnection
- packet buffering
- acknowledgments
- broadcasting to all clients or to a subset of clients (what we call "Room")
- multiplexing (what we call "Namespace")
- server: https://github.com/socketio/socket.io
- client: https://github.com/socketio/socket.io-client
- parser: https://github.com/socketio/socket.io-parser
- protocol description: https://github.com/socketio/socket.io-protocol
```js
{  "sid": "FSDjX-WRwSA4zTZMALqx",  "upgrades": ["websocket"],  "pingInterval": 25000,  "pingTimeout": 5000}
```

```js
GET
```

```js
POST
```

```js
{  "sid": "FSDjX-WRwSA4zTZMALqx",  "upgrades": ["websocket"],  "pingInterval": 25000,  "pingTimeout": 5000}
```

```js
sid
```

```js
sid
```

```js
upgrades
```

```js
pingInterval
```

```js
pingTimeout
```

```js
zBjrh...AAAK
```

```js
socket.disconnect()
```

```js
pingInterval
```

```js
pingTimeout
```

```js
pingInterval + pingTimeout
```

# https://socket.io/docs/v3/listening-to-events

# Listening to events

## EventEmitter methods​

## Catch-all listeners​

## Validation​

## Error handling​

### socket.on(eventName, listener)​

### socket.once(eventName, listener)​

### socket.off(eventName, listener)​

### socket.removeAllListeners([eventName])​

### socket.onAny(listener)​

### socket.prependAny(listener)​

### socket.offAny([listener])​

There are several ways to handle events that are transmitted between the server and the client.

On the server-side, the Socket instance extends the Node.js EventEmitter class.

On the client-side, the Socket instance uses the event emitter provided by the component-emitter library, which exposes a subset of the EventEmitter methods.

Adds the listener function to the end of the listeners array for the event named eventName.

Adds a one-time listener function for the event named eventName

Removes the specified listener from the listener array for the event named eventName.

Removes all listeners, or those of the specified eventName.

This feature is available on both the client and the server.

Adds a listener that will be fired when any event is emitted.

Adds a listener that will be fired when any event is emitted. The listener is added to the beginning of the listeners array.

Removes all catch-all listeners, or the given listener.

The validation of the event arguments is out of the scope of the Socket.IO library.

There are many packages in the JS ecosystem which cover this use case, among them:

Example with joi and acknowledgements:

There is currently no built-in error handling in the Socket.IO library, which means you must catch any error that could be thrown in a listener.

On the server-side, using EventEmitter.captureRejections = true (experimental, see here) might be interesting too, depending on your use case.

- Events
- Listening to events
- joi
- ajv
- validatorjs
```js
socket.on("details", (...args) => {  // ...});
```

```js
socket.once("details", (...args) => {  // ...});
```

```js
const listener = (...args) => {  console.log(args);}socket.on("details", listener);// and then later...socket.off("details", listener);
```

```js
// for a specific eventsocket.removeAllListeners("details");// for all eventssocket.removeAllListeners();
```

```js
socket.onAny((eventName, ...args) => {  // ...});
```

```js
socket.prependAny((eventName, ...args) => {  // ...});
```

```js
const listener = (eventName, ...args) => {  console.log(eventName, args);}socket.onAny(listener);// and then later...socket.offAny(listener);// or all listenerssocket.offAny();
```

```js
const Joi = require("joi");const userSchema = Joi.object({  username: Joi.string().max(30).required(),  email: Joi.string().email().required()});io.on("connection", (socket) => {  socket.on("create user", (payload, callback) => {    if (typeof callback !== "function") {      // not an acknowledgement      return socket.disconnect();    }    const { error, value } = userSchema.validate(payload);    if (error) {      return callback({        status: "KO",        error      });    }    // do something with the value, and then    callback({      status: "OK"    });  });});
```

```js
io.on("connection", (socket) => {  socket.on("list items", async (callback) => {    try {      const items = await findItems();      callback({        status: "OK",        items      });    } catch (e) {      callback({        status: "NOK"      });    }  });});
```

```js
require("events").captureRejections = true;io.on("connection", (socket) => {  socket.on("list products", async () => {    const products = await findProducts();    socket.emit("products", products);  });  socket[Symbol.for('nodejs.rejection')] = (err) => {    socket.emit("error", err);  };});
```

```js
socket.on("details", (...args) => {  // ...});
```

```js
socket.once("details", (...args) => {  // ...});
```

```js
const listener = (...args) => {  console.log(args);}socket.on("details", listener);// and then later...socket.off("details", listener);
```

```js
// for a specific eventsocket.removeAllListeners("details");// for all eventssocket.removeAllListeners();
```

```js
socket.onAny((eventName, ...args) => {  // ...});
```

```js
socket.prependAny((eventName, ...args) => {  // ...});
```

```js
const listener = (eventName, ...args) => {  console.log(eventName, args);}socket.onAny(listener);// and then later...socket.offAny(listener);// or all listenerssocket.offAny();
```

```js
const Joi = require("joi");const userSchema = Joi.object({  username: Joi.string().max(30).required(),  email: Joi.string().email().required()});io.on("connection", (socket) => {  socket.on("create user", (payload, callback) => {    if (typeof callback !== "function") {      // not an acknowledgement      return socket.disconnect();    }    const { error, value } = userSchema.validate(payload);    if (error) {      return callback({        status: "KO",        error      });    }    // do something with the value, and then    callback({      status: "OK"    });  });});
```

```js
io.on("connection", (socket) => {  socket.on("list items", async (callback) => {    try {      const items = await findItems();      callback({        status: "OK",        items      });    } catch (e) {      callback({        status: "NOK"      });    }  });});
```

```js
EventEmitter.captureRejections = true
```

```js
require("events").captureRejections = true;io.on("connection", (socket) => {  socket.on("list products", async () => {    const products = await findProducts();    socket.emit("products", products);  });  socket[Symbol.for('nodejs.rejection')] = (err) => {    socket.emit("error", err);  };});
```

# https://socket.io/docs/v3/logging-and-debugging

# Logging and debugging

## Available debugging scopes​

## Error logs in the browser console​

### Removing debug from your browser bundle​

Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called debug by TJ Holowaychuk.

Before 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.

The basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the DEBUG env variable (Node.JS) or the localStorage.debug property (Browsers).

You can see it in action for example on our homepage:

The best way to see what information is available is to use the *:

or in the browser:

And then filter by the scopes you’re interested in. You can prefix the * with scopes, separated by comma if there is more than one. For example, to only see debug statements from the socket.io client on Node.js try this:

To see all debug messages from the engine and socket.io:

While useful during development, the debug package adds an extra weight to the final bundle (about 4KB minified and gzipped), that's why it is excluded from the slim bundle (more details about the various browser bundles can be found here).

If you are using webpack, you can remove it with webpack-remove-debug:

Please note that error logs such as:

are not emitted by the Socket.IO library but by the browser itself, and are therefore out of our control.

- Documentation
- Logging and debugging
- net::ERR_INTERNET_DISCONNECTED
- net::ERR_CONNECTION_REFUSED
- WebSocket is already in CLOSING or CLOSED state
- Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
- The connection to xxx was interrupted while the page was loading
```js
DEBUG=* node yourfile.js
```

```js
localStorage.debug = '*';
```

```js
DEBUG=socket.io:client* node yourfile.js
```

```js
DEBUG=engine,socket.io* node yourfile.js
```

```js
{  module: {    rules: [      {        test: /\.js$/,        loader: 'webpack-remove-debug'      }    ]  }}
```

```js
DEBUG
```

```js
localStorage.debug
```

```js
DEBUG=* node yourfile.js
```

```js
localStorage.debug = '*';
```

```js
DEBUG=socket.io:client* node yourfile.js
```

```js
DEBUG=engine,socket.io* node yourfile.js
```

```js
{  module: {    rules: [      {        test: /\.js$/,        loader: 'webpack-remove-debug'      }    ]  }}
```

```js
net::ERR_INTERNET_DISCONNECTED
```

```js
net::ERR_CONNECTION_REFUSED
```

```js
WebSocket is already in CLOSING or CLOSED state
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
The connection to xxx was interrupted while the page was loading
```

# https://socket.io/docs/v3/middlewares

# Middlewares

## Registering a middleware​

## Sending credentials​

## Handling middleware error​

## Compatibility with Express middleware​

A middleware function is a function that gets executed for every incoming connection.

Middleware functions can be useful for:

Note: this function will be executed only once per connection (even if the connection consists in multiple HTTP requests).

A middleware function has access to the Socket instance and to the next registered middleware function.

You can register several middleware functions, and they will be executed sequentially:

Please make sure to call next() in any case. Otherwise, the connection will be left hanging until it is closed after a given timeout.

Important note: the Socket instance is not actually connected when the middleware gets executed, which means that no disconnect event will be emitted if the connection eventually fails.

For example, if the client manually closes the connection:

The client can send credentials with the auth option:

Those credentials can be accessed in the handshake object on the server-side:

If the next method is called with an Error object, the connection will be refused and the client will receive an connect_error event.

You can attach additional details to the Error object:

Most existing Express middleware modules should be compatible with Socket.IO, you just need a little wrapper function to make the method signatures match:

The middleware functions that end the request-response cycle and do not call next() will not work though.

Example with express-session:

Example with Passport:

A complete example with Passport can be found here.

- Server
- Middlewares
- logging
- authentication / authorization
- rate limiting
```js
io.use((socket, next) => {  if (isValid(socket.request)) {    next();  } else {    next(new Error("invalid"));  }});
```

```js
io.use((socket, next) => {  next();});io.use((socket, next) => {  next(new Error("thou shall not pass"));});io.use((socket, next) => {  // not executed, since the previous middleware has returned an error  next();});
```

```js
// server-sideio.use((socket, next) => {  setTimeout(() => {    // next is called after the client disconnection    next();  }, 1000);  socket.on("disconnect", () => {    // not triggered  });});io.on("connection", (socket) => {  // not triggered});// client-sideconst socket = io();setTimeout(() => {  socket.disconnect();}, 500);
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});
```

```js
io.use((socket, next) => {  const token = socket.handshake.auth.token;  // ...});
```

```js
// client-sidesocket.on("connect_error", (err) => {  console.log(err.message); // prints the message associated with the error});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", (err) => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
const wrap = middleware => (socket, next) => middleware(socket.request, {}, next);
```

```js
const session = require("express-session");io.use(wrap(session({ secret: "cats" })));io.on("connection", (socket) => {  const session = socket.request.session;});
```

```js
const session = require("express-session");const passport = require("passport");io.use(wrap(session({ secret: "cats" })));io.use(wrap(passport.initialize()));io.use(wrap(passport.session()));io.use((socket, next) => {  if (socket.request.user) {    next();  } else {    next(new Error("unauthorized"))  }});
```

```js
io.use((socket, next) => {  if (isValid(socket.request)) {    next();  } else {    next(new Error("invalid"));  }});
```

```js
io.use((socket, next) => {  next();});io.use((socket, next) => {  next(new Error("thou shall not pass"));});io.use((socket, next) => {  // not executed, since the previous middleware has returned an error  next();});
```

```js
next()
```

```js
disconnect
```

```js
// server-sideio.use((socket, next) => {  setTimeout(() => {    // next is called after the client disconnection    next();  }, 1000);  socket.on("disconnect", () => {    // not triggered  });});io.on("connection", (socket) => {  // not triggered});// client-sideconst socket = io();setTimeout(() => {  socket.disconnect();}, 500);
```

```js
auth
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});
```

```js
io.use((socket, next) => {  const token = socket.handshake.auth.token;  // ...});
```

```js
next
```

```js
connect_error
```

```js
// client-sidesocket.on("connect_error", (err) => {  console.log(err.message); // prints the message associated with the error});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", (err) => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
const wrap = middleware => (socket, next) => middleware(socket.request, {}, next);
```

```js
next()
```

```js
const session = require("express-session");io.use(wrap(session({ secret: "cats" })));io.on("connection", (socket) => {  const session = socket.request.session;});
```

```js
const session = require("express-session");const passport = require("passport");io.use(wrap(session({ secret: "cats" })));io.use(wrap(passport.initialize()));io.use(wrap(passport.session()));io.use((socket, next) => {  if (socket.request.user) {    next();  } else {    next(new Error("unauthorized"))  }});
```

# https://socket.io/docs/v3/migrating-from-2-x-to-3-0

# Migrating from 2.x to 3.0

### Configuration​

### New features​

### Miscellaneous​

### How to upgrade an existing production deployment​

### Known migration issues​

This release should fix most of the inconsistencies of the Socket.IO library and provide a more intuitive behavior for
the end users. It is the result of the feedback of the community over the years. A big thanks to everyone involved!

TL;DR: due to several breaking changes, a v2 client will not be able to connect to a v3 server (and vice versa)

Update: As of Socket.IO 3.1.0, the v3 server is now able to communicate with v2 clients. More information below. A v3 client is still not be able to connect to a v2 server though.

For the low-level details, please see:

Here is the complete list of changes:

Configuration

New features

Miscellaneous

How to upgrade an existing production deployment

Known migration issues

In v2, the Socket.IO server automatically added the necessary headers to allow Cross-Origin Resource Sharing (CORS).

This behavior, while convenient, was not great in terms of security, because it meant that all domains were allowed to reach your Socket.IO server, unless otherwise specified with the origins option.

That's why, as of Socket.IO v3:

The complete list of options can be found here.

Before:

After:

In previous versions, an io cookie was sent by default. This cookie can be used to enable sticky-session, which is still required when you have several servers and HTTP long-polling enabled (more information here).

However, this cookie is not needed in some cases (i.e. single server deployment, sticky-session based on IP) so it must now be explicitly enabled.

Before:

After:

All other options (domain, maxAge, sameSite, ...) are now supported. Please see here for the complete list of options.

Below are listed the non backward-compatible changes.

This method was deprecated in the 1.0 release and kept for backward-compatibility. It is now removed.

It was replaced by middlewares.

Before:

After:

This change impacts the users of the multiplexing feature (what we call Namespace in Socket.IO).

In previous versions, a client would always connect to the default namespace (/), even if it requested access to another namespace. This meant that the middlewares registered for the default namespace were triggered, which may be quite surprising.

Besides, we will now refer to the "main" namespace instead of the "default" namespace.

The connected object (used to store all the Socket connected to the given Namespace) could be used to retrieve a Socket object from its id. It is now an ES6 Map.

Before:

After:

The rooms property contains the list of rooms the Socket is currently in. It was an object, it is now an ES6 Set.

Before:

After:

The binary  method could be used to indicate that a given event did not contain any binary data (in order to skip the lookup done by the library and improve performance in certain conditions).

It was replaced by the ability to provide your own parser, which was added in Socket.IO 2.0.

Before:

After:

Please see socket.io-msgpack-parser for example.

The asynchronicity was needed for the first versions of the Redis adapter, but this is not the case anymore.

For reference, an Adapter is an object that stores the relationships between Sockets and Rooms. There are two official adapters: the in-memory adapter (built-in) and the Redis adapter based on Redis pub-sub mechanism.

Before:

After:

Note: custom adapters may return a Promise, so the previous example becomes:

UPDATE: the Socket.use() method was restored in socket.io@3.0.5.

Before:

After:

The error event is renamed to connect_error and the object emitted is now an actual Error:

Before:

After:

In previous versions, the query option was used in two distinct places:

Let's take the following example:

Under the hood, here's what happened in the io() method:

This behavior could lead to weird behaviors, for example when the Manager was reused for another namespace (multiplexing):

That's why the query option of the Socket instance is renamed to auth in Socket.IO v3:

Note: the query option of the Manager can still be used in order to add a specific query parameter to the HTTP requests.

In previous versions, the Socket instance emitted the events related to the state of the underlying connection. This will not be the case anymore.

You can still have access to those events on the Manager instance (the io property of the socket) :

Before:

After:

Here is the updated list of events emitted by the Manager:

Here is the updated list of events emitted by the Socket:

And finally, here's the updated list of reserved events that you cannot use in your application:

This function returns the list of socket IDs that are connected to this namespace.

Before:

After:

Note: this function was (and still is) supported by the Redis adapter, which means that it will return the list of socket IDs across all the Socket.IO servers.

There are now 3 distinct bundles:

By default, all of them are served by the server, at /socket.io/<name>.

Before:

After:

In Socket.IO v2, you could listen to the pong event on the client-side, which included the duration of the last health check round-trip.

Due to the reversal of the heartbeat mechanism (more information here), this event has been removed.

Before:

After:

The ECMAScript modules syntax is now similar to the Typescript one (see below).

Before (using default import):

After (with named import):

The emit() method now matches the EventEmitter.emit() method signature, and returns true instead of the current object.

Before:

After:

We are now using Maps and Sets internally instead of plain objects, so the room names are not implicitly coerced to string anymore.

Before:

After:

Some of those new features may be backported to the 2.4.x branch, depending on the feedback of the users.

This feature is inspired from the EventEmitter2 library (which is not used directly in order not to increase the browser bundle size).

It is available for both the server and the client sides:

A volatile event is an event that is allowed to be dropped if the low-level transport is not ready yet (for example when an HTTP POST request is already pending).

This feature was already available on the server-side. It might be useful on the client-side as well, for example when the socket is not connected (by default, packets are buffered until reconnection).

A bundle with the socket.io-msgpack-parser will now be provided (either on the CDN or served by the server at /socket.io/socket.io.msgpack.min.js).

Pros:

Cons:

No additional configuration is needed on the client-side.

Which means npm i -D @types/socket.io should not be needed anymore.

Server:

Client:

Plain javascript is obviously still fully supported.

IE8 is no longer testable on the Sauce Labs platform, and requires a lot of efforts for very few users (if any?), so we are dropping support for it.

Besides, Node.js 8 is now EOL. Please upgrade as soon as possible!

Note: If you are using the Redis adapter to broadcast packets between nodes, you must use socket.io-redis@5 with socket.io@2 and socket.io-redis@6 with socket.io@3. Please note that both versions are compatible, so you can update each server one by one (no big bang is needed).

This step may actually take some time, as some clients may still have a v2 client in cache.

You can check the version of the connection with:

This matches the value of the EIO query parameter in the HTTP requests.

With allowEIO3 set to false, v2 clients will now receive an HTTP 400 error (Unsupported protocol version) when connecting.

This error is probably due to your version of Node.js. The pipeline method was introduced in Node.js 10.0.0.

The signature of the emit() method was fixed in version 3.0.1 (commit).

This is probably due to the fact that the default value of maxHttpBufferSize is now 1MB. When receiving a packet that is larger than this, the server disconnects the client, in order to prevent malicious clients from overloading the server.

You can adjust the value when creating the server:

Since Socket.IO v3, you need to explicitly enable Cross-Origin Resource Sharing (CORS). The documentation can be found here.

It seems that you are using a v3 client to connect to a v2 server, which is not possible. Please see the following section.

Since the codebase has been rewritten to TypeScript (more information here), @types/socket.io-client is no longer needed and will actually conflict with the typings coming from the socket.io-client package.

You now need to explicitly enable cookies if the front is not served from the same domain as the backend:

Server

Client

Reference:

- Migrations
- Migrating from 2.x to 3.0
- Engine.IO protocol v4
- Socket.IO protocol v5
- ConfigurationSaner default valuesCORS handlingNo more cookie by default
- Saner default values
- CORS handling
- No more cookie by default
- io.set() is removed
- No more implicit connection to the default namespace
- Namespace.connected is renamed to Namespace.sockets and is now a Map
- Socket.rooms is now a Set
- Socket.binary() is removed
- Socket.join() and Socket.leave() are now synchronous
- Socket.use() is removed
- A middleware error will now emit an Error object
- Add a clear distinction between the Manager query option and the Socket query option
- The Socket instance will no longer forward the events emitted by its Manager
- Namespace.clients() is renamed to Namespace.allSockets() and now returns a Promise
- Client bundles
- No more "pong" event for retrieving latency
- ES modules syntax
- emit() chains are not possible anymore
- Room names are not coerced to string anymore
- New featuresCatch-all listenersVolatile events (client)Official bundle with the msgpack parser
- Catch-all listeners
- Volatile events (client)
- Official bundle with the msgpack parser
- MiscellaneousThe Socket.IO codebase has been rewritten to TypeScriptSupport for IE8 and Node.js 8 is officially dropped
- The Socket.IO codebase has been rewritten to TypeScript
- Support for IE8 and Node.js 8 is officially dropped
- How to upgrade an existing production deployment
- Known migration issues
- the default value of maxHttpBufferSize was decreased from 100MB to 1MB.
- the WebSocket permessage-deflate extension is now disabled by default
- you must now explicitly list the domains that are allowed (for CORS, see below)
- the withCredentials option now defaults to false on the client side
- CORS is now disabled by default
- the origins option (used to provide a list of authorized domains) and the handlePreflightRequest option (used to edit the Access-Control-Allow-xxx headers) are replaced by the cors option, which will be forwarded to the cors package.
- in the query parameters of the HTTP requests (GET /socket.io/?EIO=3&abc=def)
- in the CONNECT packet
- connect (used on the client-side)
- connect_error (used on the client-side)
- disconnect (used on both sides)
- disconnecting (used on the server-side)
- newListener and removeListener (EventEmitter reserved events)
- events with binary content are sent as 1 WebSocket frame (instead of 2+ with the default parser)
- payloads with lots of numbers should be smaller
- no IE9 support (https://caniuse.com/mdn-javascript_builtins_arraybuffer)
- a slightly bigger bundle size
- first, update the servers with allowEIO3 set to true (added in socket.io@3.1.0)
- then, update the clients
- and finally, once every client was updated, set allowEIO3 to false (which is the default value)
- stream_1.pipeline is not a function
- error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.
- the client is disconnected when sending a big payload (> 1MB)
- Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=4&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
- Uncaught TypeError: packet.data is undefined
- Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
- missing cookie in a cross-origin context
- Handling CORS
- cors option
- withCredentials option
```js
const io = require("socket.io")(httpServer, {  origins: ["https://example.com"],  // optional, useful for custom headers  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": "https://example.com",      "Access-Control-Allow-Methods": "GET,POST",      "Access-Control-Allow-Headers": "my-custom-header",      "Access-Control-Allow-Credentials": true    });    res.end();  }});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
const io = require("socket.io")(httpServer, {  cookieName: "io",  cookieHttpOnly: false,  cookiePath: "/custom"});
```

```js
const io = require("socket.io")(httpServer, {  cookie: {    name: "test",    httpOnly: false,    path: "/custom"  }});
```

```js
io.set("authorization", (handshakeData, callback) => {  // make sure the handshake data looks good  callback(null, true); // error first, "authorized" boolean second });
```

```js
io.use((socket, next) => {  var handshakeData = socket.request;  // make sure the handshake data looks good as before  // if error do this:    // next(new Error("not authorized"));  // else just call next  next();});
```

```js
// client-sideconst socket = io("/admin");// server-sideio.use((socket, next) => {  // not triggered anymore});io.on("connection", socket => {  // not triggered anymore})io.of("/admin").use((socket, next) => {  // triggered});
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").connected[socketId];// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").connected[socketId];// loop through all socketsconst sockets = io.of("/").connected;for (const id in sockets) {  if (sockets.hasOwnProperty(id)) {    const socket = sockets[id];    // ...  }}// get the number of connected socketsconst count = Object.keys(io.of("/").connected).length;
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").sockets.get(socketId);// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").sockets.get(socketId);// loop through all socketsfor (const [_, socket] of io.of("/").sockets) {  // ...}// get the number of connected socketsconst count = io.of("/").sockets.size;
```

```js
io.on("connection", (socket) => {  console.log(Object.keys(socket.rooms)); // [ <socket.id> ]  socket.join("room1");  console.log(Object.keys(socket.rooms)); // [ <socket.id>, "room1" ]});
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
socket.binary(false).emit("hello", "no binary");
```

```js
const io = require("socket.io")(httpServer, {  parser: myCustomParser});
```

```js
socket.join("room1", () => { io.to("room1").emit("hello");});socket.leave("room2", () => {  io.to("room2").emit("bye");});
```

```js
socket.join("room1");io.to("room1").emit("hello");socket.leave("room2");io.to("room2").emit("bye");
```

```js
await socket.join("room1");io.to("room1").emit("hello");
```

```js
socket.use((packet, next) => {  console.log(packet.data);  next();});
```

```js
socket.onAny((event, ...args) => {  console.log(event);});
```

```js
// server-sideio.use((socket, next) => {  next(new Error("not authorized"));});// client-sidesocket.on("error", err => {  console.log(err); // not authorized});// or with an object// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("error", err => {  console.log(err); // { content: "Please retry later" }});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
const socket = io({  query: {    token: "abc"  }});
```

```js
const { Manager } = require("socket.io-client");// a new Manager is created (which will manage the low-level connection)const manager = new Manager({  query: { // sent in the query parameters    token: "abc"  }});// and then a Socket instance is created for the namespace (here, the main namespace, "/")const socket = manager.socket("/", {  query: { // sent in the CONNECT packet    token: "abc"  }});
```

```js
// client-sideconst socket1 = io({  query: {    token: "abc"  }});const socket2 = io("/my-namespace", {  query: {    token: "def"  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (ok!)});io.of("/my-namespace").on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (what?)});
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.auth.token); // abc});
```

```js
socket.on("reconnect_attempt", () => {});
```

```js
socket.io.on("reconnect_attempt", () => {});
```

```js
socket.emit("connect_error"); // will now throw an Error
```

```js
// all sockets in default namespaceio.clients((error, clients) => {  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]});// all sockets in the "chat" namespaceio.of("/chat").clients((error, clients) => {  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]});// all sockets in the "chat" namespace and in the "general" roomio.of("/chat").in("general").clients((error, clients) => {  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]});
```

```js
// all sockets in default namespaceconst ids = await io.allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
<!-- note: this bundle was actually minified but included the debug package --><script src="/socket.io/socket.io.js"></script>
```

```js
<!-- during development --><script src="/socket.io/socket.io.js"></script><!-- for production --><script src="/socket.io/socket.io.min.js"></script>
```

```js
socket.on("pong", (latency) => {  console.log(latency);});
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("ping", (cb) => {    if (typeof cb === "function")      cb();  });});// client-sidesetInterval(() => {  const start = Date.now();  // volatile, so the packet will be discarded if the socket is not connected  socket.volatile.emit("ping", () => {    const latency = Date.now() - start;    // ...  });}, 5000);
```

```js
// server-sideimport Server from "socket.io";const io = new Server(8080);// client-sideimport io from 'socket.io-client';const socket = io();
```

```js
// server-sideimport { Server } from "socket.io";const io = new Server(8080);// client-sideimport { io } from 'socket.io-client';const socket = io();
```

```js
socket.emit("event1").emit("event2");
```

```js
socket.emit("event1");socket.emit("event2");
```

```js
// mixed types were possiblesocket.join(42);io.to("42").emit("hello");// also workedsocket.join("42");io.to(42).emit("hello");
```

```js
// one waysocket.join("42");io.to("42").emit("hello");// or anothersocket.join(42);io.to(42).emit("hello");
```

```js
// serverio.on("connection", (socket) => {  socket.onAny((event, ...args) => {});  socket.prependAny((event, ...args) => {});  socket.offAny(); // remove all listeners  socket.offAny(listener);  const listeners = socket.listenersAny();});// clientconst socket = io();socket.onAny((event, ...args) => {});socket.prependAny((event, ...args) => {});socket.offAny(); // remove all listenerssocket.offAny(listener);const listeners = socket.listenersAny();
```

```js
socket.volatile.emit("volatile event", "might or might not be sent");
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  parser: require("socket.io-msgpack-parser")});
```

```js
import { Server, Socket } from "socket.io";const io = new Server(8080);io.on("connection", (socket: Socket) => {    console.log(`connect ${socket.id}`);    socket.on("disconnect", () => {        console.log(`disconnect ${socket.id}`);    });});
```

```js
import { io } from "socket.io-client";const socket = io("/");socket.on("connect", () => {    console.log(`connect ${socket.id}`);});
```

```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
io.on("connection", (socket) => {  const version = socket.conn.protocol; // either 3 or 4});
```

```js
const io = require("socket.io")({  allowEIO3: false});
```

```js
TypeError: stream_1.pipeline is not a function    at Function.sendFile (.../node_modules/socket.io/dist/index.js:249:26)    at Server.serve (.../node_modules/socket.io/dist/index.js:225:16)    at Server.srv.on (.../node_modules/socket.io/dist/index.js:186:22)    at emitTwo (events.js:126:13)    at Server.emit (events.js:214:7)    at parserOnIncoming (_http_server.js:602:12)    at HTTPParser.parserOnHeadersComplete (_http_common.js:116:23)
```

```js
node_modules/socket.io/dist/namespace.d.ts(89,5): error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => Namespace' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'Namespace' is not assignable to type 'boolean'.node_modules/socket.io/dist/socket.d.ts(84,5): error TS2416: Property 'emit' in type 'Socket' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => this' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'this' is not assignable to type 'boolean'.      Type 'Socket' is not assignable to type 'boolean'.
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
import { Server } from "socket.io";const io = new Server({  cors: {    origin: ["https://front.domain.com"],    credentials: true  }});
```

```js
import { io } from "socket.io-client";const socket = io("https://backend.domain.com", {  withCredentials: true});
```

```js
emit()
```

```js
maxHttpBufferSize
```

```js
100MB
```

```js
1MB
```

```js
withCredentials
```

```js
false
```

```js
origins
```

```js
origins
```

```js
handlePreflightRequest
```

```js
Access-Control-Allow-xxx
```

```js
cors
```

```js
const io = require("socket.io")(httpServer, {  origins: ["https://example.com"],  // optional, useful for custom headers  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": "https://example.com",      "Access-Control-Allow-Methods": "GET,POST",      "Access-Control-Allow-Headers": "my-custom-header",      "Access-Control-Allow-Credentials": true    });    res.end();  }});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
const io = require("socket.io")(httpServer, {  cookieName: "io",  cookieHttpOnly: false,  cookiePath: "/custom"});
```

```js
const io = require("socket.io")(httpServer, {  cookie: {    name: "test",    httpOnly: false,    path: "/custom"  }});
```

```js
io.set("authorization", (handshakeData, callback) => {  // make sure the handshake data looks good  callback(null, true); // error first, "authorized" boolean second });
```

```js
io.use((socket, next) => {  var handshakeData = socket.request;  // make sure the handshake data looks good as before  // if error do this:    // next(new Error("not authorized"));  // else just call next  next();});
```

```js
// client-sideconst socket = io("/admin");// server-sideio.use((socket, next) => {  // not triggered anymore});io.on("connection", socket => {  // not triggered anymore})io.of("/admin").use((socket, next) => {  // triggered});
```

```js
connected
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").connected[socketId];// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").connected[socketId];// loop through all socketsconst sockets = io.of("/").connected;for (const id in sockets) {  if (sockets.hasOwnProperty(id)) {    const socket = sockets[id];    // ...  }}// get the number of connected socketsconst count = Object.keys(io.of("/").connected).length;
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").sockets.get(socketId);// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").sockets.get(socketId);// loop through all socketsfor (const [_, socket] of io.of("/").sockets) {  // ...}// get the number of connected socketsconst count = io.of("/").sockets.size;
```

```js
rooms
```

```js
io.on("connection", (socket) => {  console.log(Object.keys(socket.rooms)); // [ <socket.id> ]  socket.join("room1");  console.log(Object.keys(socket.rooms)); // [ <socket.id>, "room1" ]});
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
binary
```

```js
socket.binary(false).emit("hello", "no binary");
```

```js
const io = require("socket.io")(httpServer, {  parser: myCustomParser});
```

```js
socket.join("room1", () => { io.to("room1").emit("hello");});socket.leave("room2", () => {  io.to("room2").emit("bye");});
```

```js
socket.join("room1");io.to("room1").emit("hello");socket.leave("room2");io.to("room2").emit("bye");
```

```js
await socket.join("room1");io.to("room1").emit("hello");
```

```js
socket.use()
```

```js
Socket.use()
```

```js
socket.io@3.0.5
```

```js
socket.use((packet, next) => {  console.log(packet.data);  next();});
```

```js
socket.onAny((event, ...args) => {  console.log(event);});
```

```js
error
```

```js
connect_error
```

```js
// server-sideio.use((socket, next) => {  next(new Error("not authorized"));});// client-sidesocket.on("error", err => {  console.log(err); // not authorized});// or with an object// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("error", err => {  console.log(err); // { content: "Please retry later" }});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
query
```

```js
GET /socket.io/?EIO=3&abc=def
```

```js
CONNECT
```

```js
const socket = io({  query: {    token: "abc"  }});
```

```js
io()
```

```js
const { Manager } = require("socket.io-client");// a new Manager is created (which will manage the low-level connection)const manager = new Manager({  query: { // sent in the query parameters    token: "abc"  }});// and then a Socket instance is created for the namespace (here, the main namespace, "/")const socket = manager.socket("/", {  query: { // sent in the CONNECT packet    token: "abc"  }});
```

```js
// client-sideconst socket1 = io({  query: {    token: "abc"  }});const socket2 = io("/my-namespace", {  query: {    token: "def"  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (ok!)});io.of("/my-namespace").on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (what?)});
```

```js
query
```

```js
auth
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.auth.token); // abc});
```

```js
query
```

```js
socket.on("reconnect_attempt", () => {});
```

```js
socket.io.on("reconnect_attempt", () => {});
```

```js
connect
```

```js
connect_error
```

```js
disconnect
```

```js
disconnecting
```

```js
newListener
```

```js
removeListener
```

```js
socket.emit("connect_error"); // will now throw an Error
```

```js
// all sockets in default namespaceio.clients((error, clients) => {  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]});// all sockets in the "chat" namespaceio.of("/chat").clients((error, clients) => {  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]});// all sockets in the "chat" namespace and in the "general" roomio.of("/chat").in("general").clients((error, clients) => {  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]});
```

```js
// all sockets in default namespaceconst ids = await io.allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
/socket.io/<name>
```

```js
<!-- note: this bundle was actually minified but included the debug package --><script src="/socket.io/socket.io.js"></script>
```

```js
<!-- during development --><script src="/socket.io/socket.io.js"></script><!-- for production --><script src="/socket.io/socket.io.min.js"></script>
```

```js
pong
```

```js
socket.on("pong", (latency) => {  console.log(latency);});
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("ping", (cb) => {    if (typeof cb === "function")      cb();  });});// client-sidesetInterval(() => {  const start = Date.now();  // volatile, so the packet will be discarded if the socket is not connected  socket.volatile.emit("ping", () => {    const latency = Date.now() - start;    // ...  });}, 5000);
```

```js
// server-sideimport Server from "socket.io";const io = new Server(8080);// client-sideimport io from 'socket.io-client';const socket = io();
```

```js
// server-sideimport { Server } from "socket.io";const io = new Server(8080);// client-sideimport { io } from 'socket.io-client';const socket = io();
```

```js
emit()
```

```js
emit()
```

```js
EventEmitter.emit()
```

```js
true
```

```js
socket.emit("event1").emit("event2");
```

```js
socket.emit("event1");socket.emit("event2");
```

```js
// mixed types were possiblesocket.join(42);io.to("42").emit("hello");// also workedsocket.join("42");io.to(42).emit("hello");
```

```js
// one waysocket.join("42");io.to("42").emit("hello");// or anothersocket.join(42);io.to(42).emit("hello");
```

```js
2.4.x
```

```js
// serverio.on("connection", (socket) => {  socket.onAny((event, ...args) => {});  socket.prependAny((event, ...args) => {});  socket.offAny(); // remove all listeners  socket.offAny(listener);  const listeners = socket.listenersAny();});// clientconst socket = io();socket.onAny((event, ...args) => {});socket.prependAny((event, ...args) => {});socket.offAny(); // remove all listenerssocket.offAny(listener);const listeners = socket.listenersAny();
```

```js
socket.volatile.emit("volatile event", "might or might not be sent");
```

```js
/socket.io/socket.io.msgpack.min.js
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  parser: require("socket.io-msgpack-parser")});
```

```js
npm i -D @types/socket.io
```

```js
import { Server, Socket } from "socket.io";const io = new Server(8080);io.on("connection", (socket: Socket) => {    console.log(`connect ${socket.id}`);    socket.on("disconnect", () => {        console.log(`disconnect ${socket.id}`);    });});
```

```js
import { io } from "socket.io-client";const socket = io("/");socket.on("connect", () => {    console.log(`connect ${socket.id}`);});
```

```js
allowEIO3
```

```js
true
```

```js
socket.io@3.1.0
```

```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
socket.io-redis@5
```

```js
socket.io@2
```

```js
socket.io-redis@6
```

```js
socket.io@3
```

```js
io.on("connection", (socket) => {  const version = socket.conn.protocol; // either 3 or 4});
```

```js
EIO
```

```js
allowEIO3
```

```js
false
```

```js
const io = require("socket.io")({  allowEIO3: false});
```

```js
allowEIO3
```

```js
false
```

```js
Unsupported protocol version
```

```js
stream_1.pipeline is not a function
```

```js
TypeError: stream_1.pipeline is not a function    at Function.sendFile (.../node_modules/socket.io/dist/index.js:249:26)    at Server.serve (.../node_modules/socket.io/dist/index.js:225:16)    at Server.srv.on (.../node_modules/socket.io/dist/index.js:186:22)    at emitTwo (events.js:126:13)    at Server.emit (events.js:214:7)    at parserOnIncoming (_http_server.js:602:12)    at HTTPParser.parserOnHeadersComplete (_http_common.js:116:23)
```

```js
error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.
```

```js
node_modules/socket.io/dist/namespace.d.ts(89,5): error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => Namespace' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'Namespace' is not assignable to type 'boolean'.node_modules/socket.io/dist/socket.d.ts(84,5): error TS2416: Property 'emit' in type 'Socket' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => this' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'this' is not assignable to type 'boolean'.      Type 'Socket' is not assignable to type 'boolean'.
```

```js
emit()
```

```js
3.0.1
```

```js
maxHttpBufferSize
```

```js
1MB
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=4&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
Uncaught TypeError: packet.data is undefined
```

```js
Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
```

```js
@types/socket.io-client
```

```js
socket.io-client
```

```js
import { Server } from "socket.io";const io = new Server({  cors: {    origin: ["https://front.domain.com"],    credentials: true  }});
```

```js
import { io } from "socket.io-client";const socket = io("https://backend.domain.com", {  withCredentials: true});
```

```js
cors
```

```js
withCredentials
```

# https://socket.io/docs/v3/migrating-from-3-x-to-4-0

# Migrating from 3.x to 4.0

### Breaking changes​

### Configuration​

### New features​

### Known migration issues​

Here is the complete list of changes:

Previously, broadcasting to a given room (by calling io.to()) would mutate the io instance, which could lead to surprising behaviors, like:

Calling io.to() (or any other broadcast modifier) will now return an immutable instance.

Examples:

The format of the wsEngine option was updated in order to get rid of the following error:

Critical dependency: the request of a dependency is an expression

when bundling the server with webpack.

Before:

After:

Before version 16.0.0, the Swift client would not include the EIO query parameter in the HTTP requests, and the Socket.IO v3 server would infer EIO=4 by default.

That's why a Swift client v15 was not able to connect to the server, even when the compatibility mode was enabled (allowEIO3: true), unless you explicitly specified the query param:

The Socket.IO v4 server will now infer EIO=3 if the EIO query param is not included.

The default value of pingTimeout (used in the heartbeat mechanism) value was updated from 60000 to 5000 in socket.io@2.1.0 (March 2018).

The reasoning back then:

Some users experienced long delays between disconnection on the server-side and on the client-side. The "disconnect" event would take a long time to fire in the browser, probably due to a timer being delayed. Hence the change.

That being said, the current value (5s) caused unexpected disconnections when a big payload was sent over a slow network, because it prevents the ping-pong packets from being exchanged between the client and the server. This can also happen when a synchronous task blocks the server for more than 5 seconds.

The new value (20s) thus seems like a good balance between quick disconnection detection and tolerance to various delays.

Thanks to the awesome work of Sebastiaan Marynissen, you can now exclude a specific room when broadcasting:

The to() method now accepts an array of rooms.

Before:

After:

Some (long-awaited) methods were added:

The sockets variable in the example above is an array of objects exposing a subset of the usual Socket class:

Those methods share the same semantics as broadcasting, and the same filters apply:

Which makes all Socket instances of the "admin" namespace

disconnect.

Thanks to the awesome work of Maxime Kjaer, TypeScript users can now type the events sent between the client and the server.

First, you declare the signature of each event:

And you can now use them on the client side:

Your IDE should now properly infer the type of each argument:

Similarly on the server side (the ServerToClientEvents and ClientToServerEvents are reversed):

By default, the events are untyped and the arguments will be inferred as any.

And finally, thanks to the awesome work of KC Erb, the autoUnref option was added.

With autoUnref set to true (default: false), the Socket.IO client will allow the program to exit if there is no other active timer/socket in the event system:

Note: this option only applies to Node.js clients.

The following expression:

was working in Socket.IO v3 but is now considered invalid, as the broadcast flag is useless because the to("room1") method already puts the Socket instance in broadcasting mode.

- Migrations
- Migrating from 3.x to 4.0
- Breaking changesio.to() is now immutablewsEngine option
- io.to() is now immutable
- wsEngine option
- ConfigurationEnsure compatibility with Swift v15 clientsThe default value of pingTimeout was increased
- Ensure compatibility with Swift v15 clients
- The default value of pingTimeout was increased
- New featuresAllow excluding specific rooms when broadcastingAllow to pass an array to io.to()Additional utility methodsTyped eventsautoUnref option
- Allow excluding specific rooms when broadcasting
- Allow to pass an array to io.to()
- Additional utility methods
- Typed events
- autoUnref option
- Known migration issues
- socketsJoin: makes the matching socket instances join the specified rooms
- socketsLeave: makes the matching socket instances leave the specified rooms
- disconnectSockets: makes the matching socket instances disconnect
- fetchSockets: returns the matching socket instances
- in the "room1" room (in("room1") or to("room1"))
- except the ones in "room2" (except("room2"))
- and only on the current Socket.IO server (local)
- cannot get emit of undefined
```js
io.to("room1");io.to("room2").emit(/* ... */); // also sent to room1// or with async/awaitio.to("room3").emit("details", await fetchDetails()); // random behavior: maybe in room3, maybe to all clients
```

```js
const operator1 = io.to("room1");const operator2 = operator1.to("room2");const operator3 = socket.broadcast;const operator4 = socket.to("room3").to("room4");operator1.emit(/* ... */); // only to clients in "room1"operator2.emit(/* ... */); // to clients in "room1" or in "room2"operator3.emit(/* ... */); // to all clients but the senderoperator4.emit(/* ... */); // to clients in "room3" or in "room4" but the sender
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: "eiows"});
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: require("eiows").Server});
```

```js
let manager = SocketManager(socketURL: URL(string: "http://localhost:8080")!, config: [  .log(true),  .connectParams(["EIO": "3"])])let socket = manager.defaultSocket
```

```js
io.except("room1").emit(/* ... */); // to all clients except the ones in "room1"io.to("room2").except("room3").emit(/* ... */); // to all clients in "room2" except the ones in "room3"socket.broadcast.except("room1").emit(/* ... */); // to all clients except the ones in "room1" and the sendersocket.except("room1").emit(/* ... */); // same as abovesocket.to("room4").except("room5").emit(/* ... */); // to all clients in "room4" except the ones in "room5" and the sender
```

```js
const rooms = ["room1", "room2", "room3"];for (const room of rooms) {  io.to(room);}// broadcast to clients in "room1", "room2" or "room3"// WARNING !!! this does not work anymore in v4, see the breaking change aboveio.emit(/* ... */);
```

```js
io.to(["room1", "room2", "room3"]).emit(/* ... */);socket.to(["room1", "room2", "room3"]).emit(/* ... */);
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances of the "admin" namespace in the "room1" room join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances of the "admin" namespace in the "room1" room leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances of the "admin" namespace in the "room1" room disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
// return all Socket instancesconst sockets = await io.fetchSockets();// return all Socket instances of the "admin" namespace in the "room1" roomconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
io.of("/admin").in("room1").except("room2").local.disconnectSockets();
```

```js
interface ClientToServerEvents {  noArg: () => void;  basicEmit: (a: number, b: string, c: number[]) => void;}interface ServerToClientEvents {  withAck: (d: string, cb: (e: number) => void) => void;}
```

```js
import { io, Socket } from "socket.io-client";const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();socket.emit("noArg");socket.emit("basicEmit", 1, "2", [3]);socket.on("withAck", (d, cb) => {    cb(4);});
```

```js
import { Server } from "socket.io";const io = new Server<ClientToServerEvents, ServerToClientEvents>(3000);io.on("connection", (socket) => {    socket.on("noArg", () => {      // ...    });    socket.on("basicEmit", (a, b, c) => {      // ...    });    socket.emit("withAck", "42", (e) => {        console.log(e);    });});
```

```js
const socket = io({  autoUnref: true});
```

```js
socket.to("room1").broadcast.emit(/* ... */);
```

```js
// VALIDsocket.broadcast.emit(/* ... */); // to all clients but the sendersocket.to("room1").emit(/* ... */); // to clients in "room1" but the sender// VALID (but useless 'broadcast' flag)socket.broadcast.to("room1").emit(/* ... */);// INVALIDsocket.to("room1").broadcast.emit(/* ... */);
```

```js
allowEIO3: true
```

```js
io.to()
```

```js
wsEngine
```

```js
pingTimeout
```

```js
io.to()
```

```js
autoUnref
```

```js
io.to()
```

```js
io.to()
```

```js
io.to("room1");io.to("room2").emit(/* ... */); // also sent to room1// or with async/awaitio.to("room3").emit("details", await fetchDetails()); // random behavior: maybe in room3, maybe to all clients
```

```js
io.to()
```

```js
const operator1 = io.to("room1");const operator2 = operator1.to("room2");const operator3 = socket.broadcast;const operator4 = socket.to("room3").to("room4");operator1.emit(/* ... */); // only to clients in "room1"operator2.emit(/* ... */); // to clients in "room1" or in "room2"operator3.emit(/* ... */); // to all clients but the senderoperator4.emit(/* ... */); // to clients in "room3" or in "room4" but the sender
```

```js
wsEngine
```

```js
wsEngine
```

```js
Critical dependency: the request of a dependency is an expression
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: "eiows"});
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: require("eiows").Server});
```

```js
EIO
```

```js
EIO=4
```

```js
allowEIO3: true
```

```js
let manager = SocketManager(socketURL: URL(string: "http://localhost:8080")!, config: [  .log(true),  .connectParams(["EIO": "3"])])let socket = manager.defaultSocket
```

```js
EIO=3
```

```js
EIO
```

```js
pingTimeout
```

```js
pingTimeout
```

```js
socket.io@2.1.0
```

```js
io.except("room1").emit(/* ... */); // to all clients except the ones in "room1"io.to("room2").except("room3").emit(/* ... */); // to all clients in "room2" except the ones in "room3"socket.broadcast.except("room1").emit(/* ... */); // to all clients except the ones in "room1" and the sendersocket.except("room1").emit(/* ... */); // same as abovesocket.to("room4").except("room5").emit(/* ... */); // to all clients in "room4" except the ones in "room5" and the sender
```

```js
io.to()
```

```js
to()
```

```js
const rooms = ["room1", "room2", "room3"];for (const room of rooms) {  io.to(room);}// broadcast to clients in "room1", "room2" or "room3"// WARNING !!! this does not work anymore in v4, see the breaking change aboveio.emit(/* ... */);
```

```js
io.to(["room1", "room2", "room3"]).emit(/* ... */);socket.to(["room1", "room2", "room3"]).emit(/* ... */);
```

```js
socketsJoin
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances of the "admin" namespace in the "room1" room join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");
```

```js
socketsLeave
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances of the "admin" namespace in the "room1" room leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");
```

```js
disconnectSockets
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances of the "admin" namespace in the "room1" room disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
fetchSockets
```

```js
// return all Socket instancesconst sockets = await io.fetchSockets();// return all Socket instances of the "admin" namespace in the "room1" roomconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
sockets
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
io.of("/admin").in("room1").except("room2").local.disconnectSockets();
```

```js
in("room1")
```

```js
to("room1")
```

```js
except("room2")
```

```js
local
```

```js
interface ClientToServerEvents {  noArg: () => void;  basicEmit: (a: number, b: string, c: number[]) => void;}interface ServerToClientEvents {  withAck: (d: string, cb: (e: number) => void) => void;}
```

```js
import { io, Socket } from "socket.io-client";const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();socket.emit("noArg");socket.emit("basicEmit", 1, "2", [3]);socket.on("withAck", (d, cb) => {    cb(4);});
```

```js
ServerToClientEvents
```

```js
ClientToServerEvents
```

```js
import { Server } from "socket.io";const io = new Server<ClientToServerEvents, ServerToClientEvents>(3000);io.on("connection", (socket) => {    socket.on("noArg", () => {      // ...    });    socket.on("basicEmit", (a, b, c) => {      // ...    });    socket.emit("withAck", "42", (e) => {        console.log(e);    });});
```

```js
any
```

```js
autoUnref
```

```js
autoUnref
```

```js
autoUnref
```

```js
const socket = io({  autoUnref: true});
```

```js
cannot get emit of undefined
```

```js
socket.to("room1").broadcast.emit(/* ... */);
```

```js
broadcast
```

```js
to("room1")
```

```js
// VALIDsocket.broadcast.emit(/* ... */); // to all clients but the sendersocket.to("room1").emit(/* ... */); // to clients in "room1" but the sender// VALID (but useless 'broadcast' flag)socket.broadcast.to("room1").emit(/* ... */);// INVALIDsocket.to("room1").broadcast.emit(/* ... */);
```

# https://socket.io/docs/v3/namespaces

# Namespaces

## Introduction​

## Main namespace​

## Custom namespaces​

## Client initialization​

## Dynamic namespaces​

A Namespace is a communication channel that allows you to split the logic of your application over a single shared connection (also called "multiplexing").

Each namespace has its own:

Possible use cases:

Until now, you interacted with the main namespace, called /. The io instance inherits all of its methods:

Some tutorials may also mention io.sockets, it's simply an alias for io.of("/").

To set up a custom namespace, you can call the of function on the server-side:

Same-origin version:

Cross-origin/Node.js version:

In the example above, only one WebSocket connection will be established, and the packets will automatically be routed to the right namespace.

Please note that multiplexing will be disabled in the following cases:

It is also possible to dynamically create namespaces, either with a regular expression:

or with a function:

You can have access to the new namespace in the connection event:

The return value of the of() method is what we call the parent namespace, from which you can:

The middleware will automatically be registered on each child namespace.

- Advanced
- Namespaces
- event handlers
- rooms
- middlewares
- you want to create a special namespace that only authorized users have access to, so the logic related to those users is separated from the rest of the application
- your application has multiple tenants so you want to dynamically create one namespace per tenant
- multiple creation for the same namespace
- different domains
- usage of the forceNew option
- register middlewares
- broadcast events
```js
io.of("/orders").on("connection", (socket) => {  socket.on("order:list", () => {});  socket.on("order:create", () => {});});io.of("/users").on("connection", (socket) => {  socket.on("user:list", () => {});});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.on("connection", (socket) => {  socket.join("room1");  orderNamespace.to("room1").emit("hello");});const userNamespace = io.of("/users");userNamespace.on("connection", (socket) => {  socket.join("room1"); // distinct from the room in the "orders" namespace  userNamespace.to("room1").emit("holà");});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.use((socket, next) => {  // ensure the socket has access to the "orders" namespace, and then  next();});const userNamespace = io.of("/users");userNamespace.use((socket, next) => {  // ensure the socket has access to the "users" namespace, and then  next();});
```

```js
const adminNamespace = io.of("/admin");adminNamespace.use((socket, next) => {  // ensure the user has sufficient rights  next();});adminNamespace.on("connection", socket => {  socket.on("delete user", () => {    // ...  });});
```

```js
const workspaces = io.of(/^\/\w+$/);workspaces.on("connection", socket => {  const workspace = socket.nsp;  workspace.emit("hello");});
```

```js
io.on("connection", (socket) => {});io.use((socket, next) => { next() });io.emit("hello");// are actually equivalent toio.of("/").on("connection", (socket) => {});io.of("/").use((socket, next) => { next() });io.of("/").emit("hello");
```

```js
io.sockets === io.of("/")
```

```js
const nsp = io.of("/my-namespace");nsp.on("connection", socket => {  console.log("someone connected");});nsp.emit("hi", "everyone!");
```

```js
const socket = io(); // or io("/"), the main namespaceconst orderSocket = io("/orders"); // the "orders" namespaceconst userSocket = io("/users"); // the "users" namespace
```

```js
const socket = io("https://example.com"); // or io("https://example.com/"), the main namespaceconst orderSocket = io("https://example.com/orders"); // the "orders" namespaceconst userSocket = io("https://example.com/users"); // the "users" namespace
```

```js
const socket1 = io();const socket2 = io(); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io("https://first.example.com");const socket2 = io("https://second.example.com"); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io();const socket2 = io("/admin", { forceNew: true }); // no multiplexing, two distinct WebSocket connections
```

```js
io.of(/^\/dynamic-\d+$/);
```

```js
io.of((name, auth, next) => {  next(null, true); // or false, when the creation is denied});
```

```js
io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const namespace = socket.nsp;});
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.use((socket, next) => { next() });
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.emit("hello"); // will be sent to users in /dynamic-1, /dynamic-2, ...
```

```js
io.of("/orders").on("connection", (socket) => {  socket.on("order:list", () => {});  socket.on("order:create", () => {});});io.of("/users").on("connection", (socket) => {  socket.on("user:list", () => {});});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.on("connection", (socket) => {  socket.join("room1");  orderNamespace.to("room1").emit("hello");});const userNamespace = io.of("/users");userNamespace.on("connection", (socket) => {  socket.join("room1"); // distinct from the room in the "orders" namespace  userNamespace.to("room1").emit("holà");});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.use((socket, next) => {  // ensure the socket has access to the "orders" namespace, and then  next();});const userNamespace = io.of("/users");userNamespace.use((socket, next) => {  // ensure the socket has access to the "users" namespace, and then  next();});
```

```js
const adminNamespace = io.of("/admin");adminNamespace.use((socket, next) => {  // ensure the user has sufficient rights  next();});adminNamespace.on("connection", socket => {  socket.on("delete user", () => {    // ...  });});
```

```js
const workspaces = io.of(/^\/\w+$/);workspaces.on("connection", socket => {  const workspace = socket.nsp;  workspace.emit("hello");});
```

```js
io.on("connection", (socket) => {});io.use((socket, next) => { next() });io.emit("hello");// are actually equivalent toio.of("/").on("connection", (socket) => {});io.of("/").use((socket, next) => { next() });io.of("/").emit("hello");
```

```js
io.sockets
```

```js
io.of("/")
```

```js
io.sockets === io.of("/")
```

```js
const nsp = io.of("/my-namespace");nsp.on("connection", socket => {  console.log("someone connected");});nsp.emit("hi", "everyone!");
```

```js
const socket = io(); // or io("/"), the main namespaceconst orderSocket = io("/orders"); // the "orders" namespaceconst userSocket = io("/users"); // the "users" namespace
```

```js
const socket = io("https://example.com"); // or io("https://example.com/"), the main namespaceconst orderSocket = io("https://example.com/orders"); // the "orders" namespaceconst userSocket = io("https://example.com/users"); // the "users" namespace
```

```js
const socket1 = io();const socket2 = io(); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io("https://first.example.com");const socket2 = io("https://second.example.com"); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io();const socket2 = io("/admin", { forceNew: true }); // no multiplexing, two distinct WebSocket connections
```

```js
io.of(/^\/dynamic-\d+$/);
```

```js
io.of((name, auth, next) => {  next(null, true); // or false, when the creation is denied});
```

```js
connection
```

```js
io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const namespace = socket.nsp;});
```

```js
of()
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.use((socket, next) => { next() });
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.emit("hello"); // will be sent to users in /dynamic-1, /dynamic-2, ...
```

# https://socket.io/docs/v3/reverse-proxy

# Behind a reverse proxy

## NginX​

## Apache HTTPD​

## Node.js http-proxy​

## Caddy 2​

You will find below the configuration needed for deploying a Socket.IO server behind a reverse-proxy solution, such as:

In a multi-server setup, please check the documentation here.

Content of /etc/nginx/nginx.conf:

Related:

If you only want to forward the Socket.IO requests (for example when NginX handles the static content):

Or with a custom path:

In that case, the server and the client must be configured accordingly:

Server

Client

Content of /usr/local/apache2/conf/httpd.conf:

Related:

Installation: npm i http-proxy

Documentation

Content of Caddyfile for Caddy 2

Related

- Server
- Behind a reverse proxy
- NginX
- Apache HTTPD
- Node.js http-proxy
- Caddy 2
- proxy_pass documentation
- configuration in a multi-server setup
- mod_proxy_wstunnel documentation
- configuration in a multi-server setup
- Solution forum post
- Caddyfile directives
```js
http {  server {    listen 80;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
http {  server {    listen 80;    root /var/www/html;    location /socket.io/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
http {  server {    listen 80;    root /var/www/html;    location /my-custom-path/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
import { Server } from "socket.io";const io = new Server({  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/my-custom-path/"});
```

```js
Listen 80ServerName example.comLoadModule mpm_event_module             modules/mod_mpm_event.soLoadModule authn_file_module            modules/mod_authn_file.soLoadModule authn_core_module            modules/mod_authn_core.soLoadModule authz_host_module            modules/mod_authz_host.soLoadModule authz_groupfile_module       modules/mod_authz_groupfile.soLoadModule authz_user_module            modules/mod_authz_user.soLoadModule authz_core_module            modules/mod_authz_core.soLoadModule headers_module               modules/mod_headers.soLoadModule lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.soLoadModule proxy_module                 modules/mod_proxy.soLoadModule proxy_balancer_module        modules/mod_proxy_balancer.soLoadModule proxy_http_module            modules/mod_proxy_http.soLoadModule proxy_wstunnel_module        modules/mod_proxy_wstunnel.soLoadModule rewrite_module               modules/mod_rewrite.soLoadModule slotmem_shm_module           modules/mod_slotmem_shm.soLoadModule unixd_module                 modules/mod_unixd.soUser daemonGroup daemonProxyPass / http://localhost:3000/RewriteEngine onRewriteCond %{HTTP:Upgrade} websocket [NC]RewriteCond %{HTTP:Connection} upgrade [NC]RewriteRule ^/?(.*) "ws://localhost:3000/$1" [P,L]ProxyTimeout 3
```

```js
const httpProxy = require("http-proxy");httpProxy  .createProxyServer({    target: "http://localhost:3000",    ws: true,  })  .listen(80);
```

```js
example.com {  rewrite /path /path/  handle_path /path/* {    rewrite * /socket.io{path}    reverse_proxy localhost:3000  }}
```

```js
http-proxy
```

```js
/etc/nginx/nginx.conf
```

```js
http {  server {    listen 80;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
http {  server {    listen 80;    root /var/www/html;    location /socket.io/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
http {  server {    listen 80;    root /var/www/html;    location /my-custom-path/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
import { Server } from "socket.io";const io = new Server({  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/my-custom-path/"});
```

```js
/usr/local/apache2/conf/httpd.conf
```

```js
Listen 80ServerName example.comLoadModule mpm_event_module             modules/mod_mpm_event.soLoadModule authn_file_module            modules/mod_authn_file.soLoadModule authn_core_module            modules/mod_authn_core.soLoadModule authz_host_module            modules/mod_authz_host.soLoadModule authz_groupfile_module       modules/mod_authz_groupfile.soLoadModule authz_user_module            modules/mod_authz_user.soLoadModule authz_core_module            modules/mod_authz_core.soLoadModule headers_module               modules/mod_headers.soLoadModule lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.soLoadModule proxy_module                 modules/mod_proxy.soLoadModule proxy_balancer_module        modules/mod_proxy_balancer.soLoadModule proxy_http_module            modules/mod_proxy_http.soLoadModule proxy_wstunnel_module        modules/mod_proxy_wstunnel.soLoadModule rewrite_module               modules/mod_rewrite.soLoadModule slotmem_shm_module           modules/mod_slotmem_shm.soLoadModule unixd_module                 modules/mod_unixd.soUser daemonGroup daemonProxyPass / http://localhost:3000/RewriteEngine onRewriteCond %{HTTP:Upgrade} websocket [NC]RewriteCond %{HTTP:Connection} upgrade [NC]RewriteRule ^/?(.*) "ws://localhost:3000/$1" [P,L]ProxyTimeout 3
```

```js
http-proxy
```

```js
npm i http-proxy
```

```js
const httpProxy = require("http-proxy");httpProxy  .createProxyServer({    target: "http://localhost:3000",    ws: true,  })  .listen(80);
```

```js
Caddyfile
```

```js
example.com {  rewrite /path /path/  handle_path /path/* {    rewrite * /socket.io{path}    reverse_proxy localhost:3000  }}
```

# https://socket.io/docs/v3/rooms

# Rooms

## Joining and leaving​

## Default room​

## Sample use cases​

## Usage with asynchronous code​

## Disconnection​

## With multiple Socket.IO servers​

## Implementation details​

## Room events​

A room is an arbitrary channel that sockets can join and leave. It can be used to broadcast events to a subset of clients:

Please note that rooms are a server-only concept (i.e. the client does not have access to the list of rooms it has joined).

You can call join to subscribe the socket to a given channel:

And then simply use to or in (they are the same) when broadcasting or emitting:

You can emit to several rooms at the same time:

In that case, a union is performed: every socket that is at least in one of the rooms will get the event once (even if the socket is in two or more rooms).

You can also broadcast to a room from a given socket:

In that case, every socket in the room excluding the sender will get the event.

To leave a channel you call leave in the same fashion as join.

Each Socket in Socket.IO is identified by a random, unguessable, unique identifier Socket#id. For your convenience, each socket automatically joins a room identified by its own id.

This makes it easy to implement private messages:

Please make sure to use io.to(...).emit(...) (or socket.to(...).emit(...)) in a synchronous manner.

Example with callback:

Example with async/await:

Explanation: the to() method does not return a new object, it mutates an attribute on the io (respectively, the socket) object.

This also applies to other broadcast modifiers:

Upon disconnection, sockets leave all the channels they were part of automatically, and no special teardown is needed on your part.

You can fetch the rooms the Socket was in by listening to the disconnecting event:

Like global broadcasting, broadcasting to rooms also works with multiple Socket.IO servers.

You just need to replace the default Adapter by the Redis Adapter. More information about it here.

The "room" feature is implemented by what we call an Adapter. This Adapter is a server-side component which is responsible for:

You can find the code of the default in-memory adapter here.

Basically, it consists in two ES6 Maps:

Calling socket.join("the-room") will result in:

Those two maps are then used when broadcasting:

You can access those objects with:

Notes:

Starting with socket.io@3.1.0, the underlying Adapter will emit the following events:

Example:

- Events
- Rooms
- broadcast data to each device / tab of a given user
- send notifications about a given entity
- local
- broadcast
- volatile
- storing the relationships between the Socket instances and the rooms
- broadcasting events to all (or a subset of) clients
- sids: Map<SocketId, Set<Room>>
- rooms: Map<Room, Set<SocketId>>
- in the sids Map, adding "the-room" to the Set identified by the socket ID
- in the rooms Map, adding the socket ID in the Set identified by the string "the-room"
- a broadcast to all sockets (io.emit()) loops through the sids Map, and send the packet to all sockets
- a broadcast to a given room (io.to("room21").emit()) loops through the Set in the rooms Map, and sends the packet to all matching sockets
- those objects are not meant to be directly modified, you should always use socket.join(...) and socket.leave(...) instead.
- in a multi-server setup, the rooms and sids objects are not shared between the Socket.IO servers (a room may only "exist" on one server and not on another).
- create-room (argument: room)
- delete-room (argument: room)
- join-room (argument: room, id)
- leave-room (argument: room, id)
```js
io.on("connection", socket => {  socket.join("some room");});
```

```js
io.to("some room").emit("some event");
```

```js
io.to("room1").to("room2").to("room3").emit("some event");
```

```js
io.on("connection", function(socket){  socket.to("some room").emit("some event");});
```

```js
io.on("connection", socket => {  socket.on("private message", (anotherSocketId, msg) => {    socket.to(anotherSocketId).emit("private message", socket.id, msg);  });});
```

```js
io.on("connection", async (socket) => {  const userId = await computeUserIdFromHeaders(socket);  socket.join(userId);  // and then later  io.to(userId).emit("hi");});
```

```js
io.on("connection", async (socket) => {  const projects = await fetchProjects(socket);  projects.forEach(project => socket.join("project:" + project.id));  // and then later  io.to("project:4321").emit("project updated");});
```

```js
// BADconst room = socket.to("room1");saveProduct(() => {  room.emit("product-updated");});// GOODsaveProduct(() => {  socket.to("room1").emit("product-updated");});
```

```js
// BADio.to("room2").emit("details", await fetchDetails());// GOODconst details = await fetchDetails();io.to("room2").emit("details", details);
```

```js
io.on("connection", socket => {  socket.on("disconnecting", () => {    console.log(socket.rooms); // the Set contains at least the socket ID  });  socket.on("disconnect", () => {    // socket.rooms.size === 0  });});
```

```js
// main namespaceconst rooms = io.of("/").adapter.rooms;const sids = io.of("/").adapter.sids;// custom namespaceconst rooms = io.of("/my-namespace").adapter.rooms;const sids = io.of("/my-namespace").adapter.sids;
```

```js
io.of("/").adapter.on("create-room", (room) => {  console.log(`room ${room} was created`);});io.of("/").adapter.on("join-room", (room, id) => {  console.log(`socket ${id} has joined room ${room}`);});
```

```js
join
```

```js
leave
```

```js
join
```

```js
io.on("connection", socket => {  socket.join("some room");});
```

```js
io.to("some room").emit("some event");
```

```js
io.to("room1").to("room2").to("room3").emit("some event");
```

```js
io.on("connection", function(socket){  socket.to("some room").emit("some event");});
```

```js
leave
```

```js
join
```

```js
Socket
```

```js
io.on("connection", socket => {  socket.on("private message", (anotherSocketId, msg) => {    socket.to(anotherSocketId).emit("private message", socket.id, msg);  });});
```

```js
io.on("connection", async (socket) => {  const userId = await computeUserIdFromHeaders(socket);  socket.join(userId);  // and then later  io.to(userId).emit("hi");});
```

```js
io.on("connection", async (socket) => {  const projects = await fetchProjects(socket);  projects.forEach(project => socket.join("project:" + project.id));  // and then later  io.to("project:4321").emit("project updated");});
```

```js
io.to(...).emit(...)
```

```js
socket.to(...).emit(...)
```

```js
// BADconst room = socket.to("room1");saveProduct(() => {  room.emit("product-updated");});// GOODsaveProduct(() => {  socket.to("room1").emit("product-updated");});
```

```js
async/await
```

```js
// BADio.to("room2").emit("details", await fetchDetails());// GOODconst details = await fetchDetails();io.to("room2").emit("details", details);
```

```js
to()
```

```js
socket
```

```js
leave
```

```js
disconnecting
```

```js
io.on("connection", socket => {  socket.on("disconnecting", () => {    console.log(socket.rooms); // the Set contains at least the socket ID  });  socket.on("disconnect", () => {    // socket.rooms.size === 0  });});
```

```js
sids
```

```js
Map<SocketId, Set<Room>>
```

```js
rooms
```

```js
Map<Room, Set<SocketId>>
```

```js
socket.join("the-room")
```

```js
sids
```

```js
rooms
```

```js
io.emit()
```

```js
sids
```

```js
io.to("room21").emit()
```

```js
rooms
```

```js
// main namespaceconst rooms = io.of("/").adapter.rooms;const sids = io.of("/").adapter.sids;// custom namespaceconst rooms = io.of("/my-namespace").adapter.rooms;const sids = io.of("/my-namespace").adapter.sids;
```

```js
socket.join(...)
```

```js
socket.leave(...)
```

```js
rooms
```

```js
sids
```

```js
socket.io@3.1.0
```

```js
create-room
```

```js
delete-room
```

```js
join-room
```

```js
leave-room
```

```js
io.of("/").adapter.on("create-room", (room) => {  console.log(`room ${room} was created`);});io.of("/").adapter.on("join-room", (room, id) => {  console.log(`socket ${id} has joined room ${room}`);});
```

# https://socket.io/docs/v3/server-api

## Server​

## Namespace​

## Socket​

## Client​

### new Server(httpServer[, options])​

### new Server(port[, options])​

### new Server(options)​

### server.sockets​

### server.serveClient([value])​

### server.path([value])​

### server.adapter([value])​

### server.attach(httpServer[, options])​

### server.attach(port[, options])​

### server.listen(httpServer[, options])​

### server.listen(port[, options])​

### server.bind(engine)​

### server.onconnection(socket)​

### server.of(nsp)​

### server.close([callback])​

### server.engine.generateId​

### namespace.name​

### namespace.sockets​

### namespace.adapter​

### namespace.to(room)​

### namespace.in(room)​

### namespace.emit(eventName[, ...args])​

### namespace.allSockets()​

### namespace.use(fn)​

### Event: 'connection'​

### Event: 'connect'​

### Flag: 'volatile'​

### Flag: 'local'​

### socket.id​

### socket.rooms​

### socket.client​

### socket.conn​

### socket.request​

### socket.handshake​

### socket.use(fn)​

### socket.send([...args][, ack])​

### socket.emit(eventName[, ...args][, ack])​

### socket.on(eventName, callback)​

### socket.once(eventName, listener)​

### socket.removeListener(eventName, listener)​

### socket.removeAllListeners([eventName])​

### socket.eventNames()​

### socket.onAny(callback)​

### socket.prependAny(callback)​

### socket.offAny([listener])​

### socket.listenersAny()​

### socket.join(room)​

### socket.leave(room)​

### socket.to(room)​

### socket.in(room)​

### socket.compress(value)​

### socket.disconnect(close)​

### Flag: 'broadcast'​

### Flag: 'volatile'​

### Event: 'disconnect'​

### Event: 'disconnecting'​

### client.conn​

### client.request​

Exposed by require("socket.io").

Related documentation pages:

Works with and without new:

Available options:

Available options for the underlying Engine.IO server:

More information here.

See above for the list of available options.

See above for the list of available options.

An alias for the default (/) namespace.

If value is true the attached server (see Server#attach) will serve the client files. Defaults to true. This method has no effect after attach is called. If no arguments are supplied this method returns the current value.

Sets the path value under which engine.io and the static files will be served. Defaults to /socket.io. If no arguments are supplied this method returns the current value.

Sets the adapter value. Defaults to an instance of the Adapter that ships with socket.io which is memory based. See socket.io-adapter. If no arguments are supplied this method returns the current value.

Attaches the Server to an engine.io instance on httpServer with the supplied options (optionally).

Attaches the Server to an engine.io instance on a new http.Server with the supplied options (optionally).

Synonym of server.attach(httpServer[, options]).

Synonym of server.attach(port[, options]).

Initializes and retrieves the given Namespace by its pathname identifier nsp. If the namespace was already initialized it returns it immediately.

A regex or a function can also be provided, in order to create namespace in a dynamic way:

With a function:

Closes the Socket.IO server. The callback argument is optional and will be called when all connections are closed.

Note: this also closes the underlying HTTP server.

Overwrites the default method to generate your custom socket id.

The function is called with a node request object (http.IncomingMessage) as first parameter.

Represents a pool of sockets connected under a given scope identified by a pathname (eg: /chat).

More information can be found here.

The namespace identifier property.

A map of Socket instances that are connected to this namespace.

The "Adapter" used for the namespace. Useful when using the Adapter based on Redis, as it exposes methods to manage sockets and rooms across your cluster.

Note: the adapter of the main namespace can be accessed with io.of("/").adapter.

Please see the explanation here.

Sets a modifier for a subsequent event emission that the event will only be broadcasted to clients that have joined the given room.

To emit to multiple rooms, you can call to several times.

Synonym of namespace.to(room).

Emits an event to all connected clients. The following two are equivalent:

Note: acknowledgements are not supported when emitting from namespace.

Gets a list of socket IDs connected to this namespace (across all nodes if applicable).

Registers a middleware, which is a function that gets executed for every incoming Socket, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.

Errors passed to middleware callbacks are sent as special connect_error packets to clients.

Fired upon a connection from client.

Synonym of Event: "connection".

Sets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node (when the Redis adapter is used).

A Socket is the fundamental class for interacting with browser clients. A Socket belongs to a certain Namespace (by default /) and uses an underlying Client to communicate.

It should be noted the Socket doesn't relate directly to the actual underlying TCP/IP socket and it is only the name of the class.

Within each Namespace, you can also define arbitrary channels (called room) that the Socket can join and leave. That provides a convenient way to broadcast to a group of Sockets (see Socket#to below).

The Socket class inherits from EventEmitter. The Socket class overrides the emit method, and does not modify any other EventEmitter method. All methods documented here which also appear as EventEmitter methods (apart from emit) are implemented by EventEmitter, and documentation for EventEmitter applies.

More information can be found here.

A unique identifier for the session, that comes from the underlying Client.

A Set of strings identifying the rooms this client is in.

A reference to the underlying Client object.

A reference to the underlying Client transport connection (engine.io Socket object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.

A getter proxy that returns the reference to the request that originated the underlying engine.io Client. Useful for accessing request headers such as Cookie or User-Agent.

The handshake details:

Usage:

Registers a middleware, which is a function that gets executed for every incoming Packet and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.

Errors passed to the middleware callback are then emitted as error events on the server-side:

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

(overrides EventEmitter.emit)

Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including Buffer.

The ack argument is optional and will be called with the client's answer.

(inherited from EventEmitter)

Register a new handler for the given event.

Inherited from EventEmitter (along with other methods not mentioned here). See the Node.js documentation for the events module.

Register a new catch-all listener.

Register a new catch-all listener. The listener is added to the beginning of the listeners array.

Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed.

Returns the list of registered catch-all listeners.

Adds the socket to the given room or to the list of rooms.

The mechanics of joining rooms are handled by the Adapter that has been configured (see Server#adapter above), defaulting to socket.io-adapter.

For your convenience, each socket automatically joins a room identified by its id (see Socket#id). This makes it easy to broadcast messages to other sockets:

Removes the socket from the given room.

Rooms are left automatically upon disconnection.

Sets a modifier for a subsequent event emission that the event will only be broadcasted to clients that have joined the given room (the socket itself being excluded).

To emit to multiple rooms, you can call to several times.

Note: acknowledgements are not supported when broadcasting.

Synonym of socket.to(room).

Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method.

Disconnects this socket. If value of close is true, closes the underlying connection. Otherwise, it just disconnects the namespace.

Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the sender.

Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

Fired upon disconnection.

Possible reasons:

Fired when the client is going to be disconnected (but hasn't left its rooms yet).

Note: those events, along with connect, connect_error, newListener and removeListener, are special events that shouldn't be used in your application:

The Client class represents an incoming transport (engine.io) connection. A Client can be associated with many multiplexed Sockets that belong to different Namespaces.

A reference to the underlying engine.io Socket connection.

A getter proxy that returns the reference to the request that originated the engine.io connection. Useful for accessing request headers such as Cookie or User-Agent.

- installation
- initialization
- details of the server instance
- httpServer (http.Server) the server to bind to.
- options (Object)
- port (Number) a port to listen to (a new http.Server will be created)
- options (Object)
- options (Object)
- (Namespace)
- value (Boolean)
- Returns Server|Boolean
- value (String)
- Returns Server|String
- value (Adapter)
- Returns Server|Adapter
- httpServer (http.Server) the server to attach to
- options (Object)
- port (Number) the port to listen on
- options (Object)
- engine (engine.Server)
- Returns Server
- socket (engine.Socket)
- Returns Server
- nsp (String|RegExp|Function)
- Returns Namespace
- callback (Function)
- (String)
- (Map<SocketId, Socket>)
- (Adapter)
- room (String)
- Returns Namespace for chaining
- eventName (String)
- args
- Returns true
- Returns Promise<Set<SocketId>>
- fn (Function)
- socket (Socket) socket connection with client
- (String)
- (Set)
- (Client)
- (engine.Socket)
- (Request)
- (Object)
- fn (Function)
- args
- ack (Function)
- Returns Socket
- eventName (String)
- args
- ack (Function)
- Returns true
- eventName (String)
- callback (Function)
- Returns Socket
- callback (Function)
- callback (Function)
- listener (Function)
- Returns Function[]
- room (string) | (string[])
- Returns void | Promise
- room (String)
- Returns void | Promise
- room (String)
- Returns Socket for chaining
- value (Boolean) whether to following packet will be compressed
- Returns Socket for chaining
- close (Boolean) whether to close the underlying connection
- Returns Socket
- reason (String) the reason of the disconnection (either client or server-side)
- reason (String) the reason of the disconnection (either client or server-side)
- (engine.Socket)
- (Request)
```js
const io = require("socket.io")();// orconst { Server } = require("socket.io");const io = new Server();
```

```js
const io = require("socket.io")(3000, {  path: "/test",  serveClient: false,  // below are engine.IO options  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
const io = require("socket.io")({  path: "/test",  serveClient: false,});// eitherconst server = require("http").createServer();io.attach(server, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});server.listen(3000);// orio.attach(3000, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
io.sockets.emit("hi", "everyone");// is equivalent toio.of("/").emit("hi", "everyone");
```

```js
// pass a server and the `serveClient` optionconst io = require("socket.io")(http, { serveClient: false });// or pass no server and then you can call the methodconst io = require("socket.io")();io.serveClient(false);io.attach(http);
```

```js
const io = require("socket.io")();io.path("/myownpath");// client-sideconst socket = io({  path: "/myownpath"});
```

```js
const io = require("socket.io")(3000);const redis = require("socket.io-redis");io.adapter(redis({ host: "localhost", port: 6379 }));
```

```js
const adminNamespace = io.of("/admin");
```

```js
const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const newNamespace = socket.nsp; // newNamespace.name === "/dynamic-101"  // broadcast to all clients in the given sub-namespace  newNamespace.emit("hello");});// client-sideconst socket = io("/dynamic-101");// broadcast to all clients in each sub-namespacedynamicNsp.emit("hello");// use a middleware for each sub-namespacedynamicNsp.use((socket, next) => { /* ... */ });
```

```js
io.of((name, query, next) => {  // the checkToken method must return a boolean, indicating whether the client is able to connect or not.  next(null, checkToken(query.token));}).on("connection", (socket) => { /* ... */ });
```

```js
const Server = require("socket.io");const PORT   = 3030;const server = require("http").Server();const io = Server(PORT);io.close(); // Close current serverserver.listen(PORT); // PORT is free to useio = Server(server);
```

```js
const uuid = require("uuid");io.engine.generateId = (req) => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
// number of sockets in this namespace (on this node)const socketCount = io.of("/admin").sockets.size;
```

```js
const io = require("socket.io")();const adminNamespace = io.of("/admin");adminNamespace.to("level1").emit("an event", { some: "data" });
```

```js
const io = require("socket.io")();io.emit("an event sent to all connected clients"); // main namespaceconst chat = io.of("/chat");chat.emit("an event sent to all connected clients in chat namespace");
```

```js
// all sockets in the main namespaceconst ids = await io.allSockets();// all sockets in the main namespace and in the "user:1234" roomconst ids = await io.in("user:1234").allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
io.on("connection", (socket) => {  // ...});io.of("/admin").on("connection", (socket) => {  // ...});
```

```js
io.volatile.emit("an event", { some: "data" }); // the clients may or may not receive it
```

```js
io.local.emit("an event", { some: "data" });
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
const cookie = require("cookie");io.on("connection", (socket) => {  const cookies = cookie.parse(socket.request.headers.cookie || "");});
```

```js
{  headers: /* the headers sent as part of the handshake */,  time: /* the date of creation (as string) */,  address: /* the ip of the client */,  xdomain: /* whether the connection is cross-domain */,  secure: /* whether the connection is secure */,  issued: /* the date of creation (as unix timestamp) */,  url: /* the request URL string */,  query: /* the query params of the first request */,  auth: /* the authentication payload */}
```

```js
io.use((socket, next) => {  let handshake = socket.handshake;  // ...});io.on("connection", (socket) => {  let handshake = socket.handshake;  // ...});
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    // do not forget to call next    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
socket.emit("hello", "world");socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6]) });
```

```js
io.on("connection", (socket) => {  socket.emit("an event", { some: "data" });  socket.emit("ferret", "tobi", (data) => {    console.log(data); // data will be "woot"  });  // the client code  // client.on("ferret", (name, fn) => {  //   fn("woot");  // });});
```

```js
socket.on("news", (data) => {  console.log(data);});// with several argumentssocket.on("news", (arg1, arg2, arg3) => {  // ...});// or with acknowledgementsocket.on("news", (data, callback) => {  callback(0);});
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
const listeners = socket.listenersAny();
```

```js
io.on("connection", (socket) => {  socket.join("room 237");    console.log(socket.rooms); // Set { <socket.id>, "room 237" }  socket.join(["room 237", "room 238"]);  io.to("room 237").emit("a new user has joined the room"); // broadcast to everyone in the room});
```

```js
io.on("connection", (socket) => {  socket.on("say to someone", (id, msg) => {    // send a private message to the socket with the given id    socket.to(id).emit("my message", msg);  });});
```

```js
io.on("connection", (socket) => {  socket.leave("room 237");  io.to("room 237").emit(`user ${socket.id} has left the room`);});
```

```js
io.on("connection", (socket) => {  // to one room  socket.to("others").emit("an event", { some: "data" });  // to multiple rooms  socket.to("room1").to("room2").emit("hello");  // a private message to another socket  socket.to(/* another socket id */).emit("hey");  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.});
```

```js
io.on("connection", (socket) => {  socket.compress(false).emit("uncompressed", "that's rough");});
```

```js
io.on("connection", (socket) => {  setTimeout(() => socket.disconnect(true), 5000);});
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("an event", { some: "data" }); // everyone gets it but the sender});
```

```js
io.on("connection", (socket) => {  socket.volatile.emit("an event", { some: "data" }); // the client may or may not receive it});
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    console.log(socket.rooms); // Set { ... }  });});
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
require("socket.io")
```

```js
httpServer
```

```js
options
```

```js
new
```

```js
const io = require("socket.io")();// orconst { Server } = require("socket.io");const io = new Server();
```

```js
path
```

```js
/socket.io
```

```js
serveClient
```

```js
true
```

```js
adapter
```

```js
Adapter
```

```js
parser
```

```js
Parser
```

```js
connectTimeout
```

```js
45000
```

```js
pingTimeout
```

```js
5000
```

```js
pingInterval
```

```js
25000
```

```js
upgradeTimeout
```

```js
10000
```

```js
maxHttpBufferSize
```

```js
1e6
```

```js
allowRequest
```

```js
fn(err, success)
```

```js
success
```

```js
transports
```

```js
["polling", "websocket"]
```

```js
allowUpgrades
```

```js
true
```

```js
perMessageDeflate
```

```js
false
```

```js
true
```

```js
httpCompression
```

```js
true
```

```js
false
```

```js
wsEngine
```

```js
cors
```

```js
cookie
```

```js
allowEIO3
```

```js
false
```

```js
port
```

```js
http.Server
```

```js
options
```

```js
options
```

```js
const io = require("socket.io")(3000, {  path: "/test",  serveClient: false,  // below are engine.IO options  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
options
```

```js
options
```

```js
const io = require("socket.io")({  path: "/test",  serveClient: false,});// eitherconst server = require("http").createServer();io.attach(server, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});server.listen(3000);// orio.attach(3000, {  pingInterval: 10000,  pingTimeout: 5000,  cookie: false});
```

```js
io.sockets.emit("hi", "everyone");// is equivalent toio.of("/").emit("hi", "everyone");
```

```js
value
```

```js
Server|Boolean
```

```js
value
```

```js
true
```

```js
Server#attach
```

```js
true
```

```js
attach
```

```js
// pass a server and the `serveClient` optionconst io = require("socket.io")(http, { serveClient: false });// or pass no server and then you can call the methodconst io = require("socket.io")();io.serveClient(false);io.attach(http);
```

```js
value
```

```js
Server|String
```

```js
value
```

```js
engine.io
```

```js
/socket.io
```

```js
const io = require("socket.io")();io.path("/myownpath");// client-sideconst socket = io({  path: "/myownpath"});
```

```js
value
```

```js
Server|Adapter
```

```js
value
```

```js
Adapter
```

```js
const io = require("socket.io")(3000);const redis = require("socket.io-redis");io.adapter(redis({ host: "localhost", port: 6379 }));
```

```js
httpServer
```

```js
options
```

```js
Server
```

```js
httpServer
```

```js
options
```

```js
port
```

```js
options
```

```js
Server
```

```js
options
```

```js
engine
```

```js
Server
```

```js
Server
```

```js
socket
```

```js
Server
```

```js
socket.io
```

```js
Socket
```

```js
nsp
```

```js
Namespace
```

```js
Namespace
```

```js
nsp
```

```js
const adminNamespace = io.of("/admin");
```

```js
const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const newNamespace = socket.nsp; // newNamespace.name === "/dynamic-101"  // broadcast to all clients in the given sub-namespace  newNamespace.emit("hello");});// client-sideconst socket = io("/dynamic-101");// broadcast to all clients in each sub-namespacedynamicNsp.emit("hello");// use a middleware for each sub-namespacedynamicNsp.use((socket, next) => { /* ... */ });
```

```js
io.of((name, query, next) => {  // the checkToken method must return a boolean, indicating whether the client is able to connect or not.  next(null, checkToken(query.token));}).on("connection", (socket) => { /* ... */ });
```

```js
callback
```

```js
callback
```

```js
const Server = require("socket.io");const PORT   = 3030;const server = require("http").Server();const io = Server(PORT);io.close(); // Close current serverserver.listen(PORT); // PORT is free to useio = Server(server);
```

```js
http.IncomingMessage
```

```js
const uuid = require("uuid");io.engine.generateId = (req) => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
/chat
```

```js
// number of sockets in this namespace (on this node)const socketCount = io.of("/admin").sockets.size;
```

```js
Adapter
```

```js
io.of("/").adapter
```

```js
room
```

```js
Namespace
```

```js
room
```

```js
const io = require("socket.io")();const adminNamespace = io.of("/admin");adminNamespace.to("level1").emit("an event", { some: "data" });
```

```js
eventName
```

```js
args
```

```js
true
```

```js
const io = require("socket.io")();io.emit("an event sent to all connected clients"); // main namespaceconst chat = io.of("/chat");chat.emit("an event sent to all connected clients in chat namespace");
```

```js
Promise<Set<SocketId>>
```

```js
// all sockets in the main namespaceconst ids = await io.allSockets();// all sockets in the main namespace and in the "user:1234" roomconst ids = await io.in("user:1234").allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
Socket
```

```js
connect_error
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
socket
```

```js
io.on("connection", (socket) => {  // ...});io.of("/admin").on("connection", (socket) => {  // ...});
```

```js
io.volatile.emit("an event", { some: "data" }); // the clients may or may not receive it
```

```js
io.local.emit("an event", { some: "data" });
```

```js
Socket
```

```js
Socket
```

```js
Namespace
```

```js
Client
```

```js
Socket
```

```js
socket
```

```js
Namespace
```

```js
room
```

```js
Socket
```

```js
Socket
```

```js
Socket#to
```

```js
Socket
```

```js
Socket
```

```js
emit
```

```js
EventEmitter
```

```js
EventEmitter
```

```js
emit
```

```js
EventEmitter
```

```js
EventEmitter
```

```js
Client
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
Client
```

```js
Client
```

```js
Socket
```

```js
request
```

```js
Client
```

```js
Cookie
```

```js
User-Agent
```

```js
const cookie = require("cookie");io.on("connection", (socket) => {  const cookies = cookie.parse(socket.request.headers.cookie || "");});
```

```js
{  headers: /* the headers sent as part of the handshake */,  time: /* the date of creation (as string) */,  address: /* the ip of the client */,  xdomain: /* whether the connection is cross-domain */,  secure: /* whether the connection is secure */,  issued: /* the date of creation (as unix timestamp) */,  url: /* the request URL string */,  query: /* the query params of the first request */,  auth: /* the authentication payload */}
```

```js
io.use((socket, next) => {  let handshake = socket.handshake;  // ...});io.on("connection", (socket) => {  let handshake = socket.handshake;  // ...});
```

```js
socket.onAny()
```

```js
error
```

```js
Packet
```

```js
error
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    // do not forget to call next    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
args
```

```js
ack
```

```js
Socket
```

```js
message
```

```js
EventEmitter.emit
```

```js
eventName
```

```js
args
```

```js
ack
```

```js
true
```

```js
Buffer
```

```js
socket.emit("hello", "world");socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6]) });
```

```js
ack
```

```js
io.on("connection", (socket) => {  socket.emit("an event", { some: "data" });  socket.emit("ferret", "tobi", (data) => {    console.log(data); // data will be "woot"  });  // the client code  // client.on("ferret", (name, fn) => {  //   fn("woot");  // });});
```

```js
EventEmitter
```

```js
eventName
```

```js
callback
```

```js
Socket
```

```js
socket.on("news", (data) => {  console.log(data);});// with several argumentssocket.on("news", (arg1, arg2, arg3) => {  // ...});// or with acknowledgementsocket.on("news", (data, callback) => {  callback(0);});
```

```js
EventEmitter
```

```js
callback
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
callback
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
listener
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
Function[]
```

```js
const listeners = socket.listenersAny();
```

```js
room
```

```js
void
```

```js
Promise
```

```js
room
```

```js
io.on("connection", (socket) => {  socket.join("room 237");    console.log(socket.rooms); // Set { <socket.id>, "room 237" }  socket.join(["room 237", "room 238"]);  io.to("room 237").emit("a new user has joined the room"); // broadcast to everyone in the room});
```

```js
Adapter
```

```js
Server#adapter
```

```js
Socket#id
```

```js
io.on("connection", (socket) => {  socket.on("say to someone", (id, msg) => {    // send a private message to the socket with the given id    socket.to(id).emit("my message", msg);  });});
```

```js
room
```

```js
void
```

```js
Promise
```

```js
room
```

```js
io.on("connection", (socket) => {  socket.leave("room 237");  io.to("room 237").emit(`user ${socket.id} has left the room`);});
```

```js
room
```

```js
Socket
```

```js
room
```

```js
io.on("connection", (socket) => {  // to one room  socket.to("others").emit("an event", { some: "data" });  // to multiple rooms  socket.to("room1").to("room2").emit("hello");  // a private message to another socket  socket.to(/* another socket id */).emit("hey");  // WARNING: `socket.to(socket.id).emit()` will NOT work, as it will send to everyone in the room  // named `socket.id` but the sender. Please use the classic `socket.emit()` instead.});
```

```js
value
```

```js
Socket
```

```js
true
```

```js
true
```

```js
io.on("connection", (socket) => {  socket.compress(false).emit("uncompressed", "that's rough");});
```

```js
close
```

```js
Socket
```

```js
true
```

```js
io.on("connection", (socket) => {  setTimeout(() => socket.disconnect(true), 5000);});
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("an event", { some: "data" }); // everyone gets it but the sender});
```

```js
io.on("connection", (socket) => {  socket.volatile.emit("an event", { some: "data" }); // the client may or may not receive it});
```

```js
reason
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
server namespace disconnect
```

```js
client namespace disconnect
```

```js
server shutting down
```

```js
ping timeout
```

```js
pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
reason
```

```js
rooms
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    console.log(socket.rooms); // Set { ... }  });});
```

```js
connect
```

```js
connect_error
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
Client
```

```js
Client
```

```js
Socket
```

```js
Namespace
```

```js
engine.io
```

```js
Socket
```

```js
request
```

```js
Cookie
```

```js
User-Agent
```

# https://socket.io/docs/v3/server-application-structure

# Application structure

## Registering event handlers​

### Each file registers its own event handlers​

### All event handlers are registered in the index.js file​

You will find below two suggestions on how to register your event handlers.

Please note that these are merely suggestions and not strict guidelines that you must follow. Please adapt it to your own liking!

Here, the entrypoint is kept tidy, but the event listeners may be less discoverable (though strong naming convention/ctrl+f will help).

index.js

orderHandler.js

Here, each event name is located in the same place, which is great for discoverability, but could get out of hand in a medium/big application.

index.js

orderHandler.js

- Server
- Application structure
```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const registerOrderHandlers = require("./orderHandler");const registerUserHandlers = require("./userHandler");const onConnection = (socket) => {  registerOrderHandlers(io, socket);  registerUserHandlers(io, socket);}io.on("connection", onConnection);
```

```js
module.exports = (io, socket) => {  const createOrder = (payload) => {    // ...  }  const readOrder = (orderId, callback) => {    // ...  }  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);}
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const { createOrder, readOrder } = require("./orderHandler")(io);const { updatePassword } = require("./userHandler")(io);const onConnection = (socket) => {  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);  socket.on("user:update-password", updatePassword);}io.on("connection", onConnection);
```

```js
module.exports = (io) => {  const createOrder = function (payload) {    const socket = this; // hence the 'function' above, as an arrow function will not work    // ...  };  const readOrder = function (orderId, callback) {    // ...  };  return {    createOrder,    readOrder  }}
```

```js
index.js
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const registerOrderHandlers = require("./orderHandler");const registerUserHandlers = require("./userHandler");const onConnection = (socket) => {  registerOrderHandlers(io, socket);  registerUserHandlers(io, socket);}io.on("connection", onConnection);
```

```js
orderHandler.js
```

```js
module.exports = (io, socket) => {  const createOrder = (payload) => {    // ...  }  const readOrder = (orderId, callback) => {    // ...  }  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);}
```

```js
index.js
```

```js
index.js
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const { createOrder, readOrder } = require("./orderHandler")(io);const { updatePassword } = require("./userHandler")(io);const onConnection = (socket) => {  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);  socket.on("user:update-password", updatePassword);}io.on("connection", onConnection);
```

```js
orderHandler.js
```

```js
module.exports = (io) => {  const createOrder = function (payload) {    const socket = this; // hence the 'function' above, as an arrow function will not work    // ...  };  const readOrder = function (orderId, callback) {    // ...  };  return {    createOrder,    readOrder  }}
```

# https://socket.io/docs/v3/server-initialization

# Server Initialization

## Syntax​

## Initialization​

## Options​

### CommonJS​

### ES modules​

### TypeScript​

### Standalone​

### Attached to an existing HTTP server​

### With Express​

### With Koa​

### Socket.IO server options​

### Low-level engine options​

Once you have installed the Socket.IO server library, you can now init the server. The complete list of options can be found below.

Please see here for enabling ECMAScript modules in your Node.js project.

Socket.IO has now first-class support for TypeScript:

You can also pass the port as the first argument:

This implicitly starts a Node.js HTTP server, which can be accessed through io.httpServer.

Node.js documentation

Node.js documentation

More information here.

More information here.

Default value: /socket.io/

It is the name of the path that is captured on the server side.

The server and the client values must match (unless you are using a path-rewriting proxy in between):

Server

Client

Default value: true

Whether to serve the client files. If true, the different bundles will be served at the following location:

(including their associated source maps)

See also here.

Default value: socket.io-adapter (in-memory adapter, whose source code can be found here)

The "Adapter" to use.

Example with the Redis adapter (the socket.io-redis package, more information here):

Default value: socket.io-parser

The parser to use. Please see the documentation here.

Default value: 45000

The number of ms before disconnecting a client that has not successfully joined a namespace.

Default value: 5000

This value is used in the heartbeat mechanism, which periodically checks if the connection is still alive between the server and the client.

The server sends a ping, and if the client does not answer with a pong within pingTimeout ms, the server considers that the connection is closed.

Similarly, if the client does not receive a ping from the server within pingInterval + pingTimeout ms, the client also considers that the connection is closed.

In both cases, the disconnection reason will be: ping timeout

Note: the default value might be a bit low if you need to send big files in your application. Please increase it if that's the case:

Default value: 25000

See above.

Default value: 10000

This is the delay in milliseconds before an uncompleted transport upgrade is cancelled.

Default value: 1e6 (1 MB)

This defines how many bytes a single message can be, before closing the socket. You may increase or decrease this value depending on your needs.

It matches the maxPayload option of the ws package.

Default: -

A function that receives a given handshake or upgrade request as its first parameter, and can decide whether to continue or not.

Example:

Default value: ["polling", "websocket"]

The low-level transports that are allowed on the server-side.

See also: client-side transports

Default value: true

Whether to allow transport upgrades.

Default value: false

Whether to enable the permessage-deflate extension for the WebSocket transport. This extension is known to add a significant overhead in terms of performance and memory consumption, so we suggest to only enable it if it is really needed.

Please note that if perMessageDeflate is set to false (which is the default), the compress flag used when emitting (socket.compress(true).emit(...)) will be ignored when the connection is established with WebSockets, as the permessage-deflate extension cannot be enabled on a per-message basis.

All options from the ws module are supported:

Default value: true

Whether to enable the compression for the HTTP long-polling transport.

Please note that if httpCompression is set to false, the compress flag used when emitting (socket.compress(true).emit(...)) will be ignored when the connection is established with HTTP long-polling requests.

Example:

Default value: "ws" (source code can be found here)

The WebSocket server implementation to use. Please see the documentation here.

Example:

Default value: -

The list of options that will be forwarded to the cors module. More information can be found here.

Example:

Default value: -

The list of options that will be forwarded to the cookie module.

Please note that since Socket.IO v3, there is no cookie sent by default anymore (reference).

Example:

Default value: false

Whether to enable compatibility with Socket.IO v2 clients.

See also: Migrating from 2.x to 3.0

Example:

- Server
- Initialization
- Socket.IO server optionspathserveClientadapterparserconnectTimeout
- path
- serveClient
- adapter
- parser
- connectTimeout
- Low-level engine optionspingTimeoutpingIntervalupgradeTimeoutmaxHttpBufferSizeallowRequesttransportsallowUpgradesperMessageDeflatehttpCompressionwsEnginecorscookieallowEIO3
- pingTimeout
- pingInterval
- upgradeTimeout
- maxHttpBufferSize
- allowRequest
- transports
- allowUpgrades
- perMessageDeflate
- httpCompression
- wsEngine
- cors
- cookie
- allowEIO3
- <url>/socket.io/socket.io.js
- <url>/socket.io/socket.io.min.js
- <url>/socket.io/socket.io.msgpack.min.js
```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server, Socket } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket: Socket) => {  // ...});httpServer.listen(3000);
```

```js
const options = { /* ... */ };const io = require("socket.io")(options);io.on("connection", socket => { /* ... */ });io.listen(3000);
```

```js
const options = { /* ... */ };const io = require("socket.io")(3000, options);io.on("connection", socket => { /* ... */ });
```

```js
const httpServer = require("http").createServer();const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
const fs = require("fs");const httpServer = require("https").createServer({  key: fs.readFileSync("/tmp/key.pem"),  cert: fs.readFileSync("/tmp/cert.pem")});const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
const fs = require("fs");const httpServer = require("http2").createSecureServer({  allowHTTP1: true,  key: fs.readFileSync("/tmp/key.pem"),  cert: fs.readFileSync("/tmp/cert.pem")});const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
const app = require("express")();const httpServer = require("http").createServer(app);const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);// WARNING !!! app.listen(3000); will not work here, as it creates a new HTTP server
```

```js
const app = require("koa")();const httpServer = require("http").createServer(app.callback());const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
const httpServer = require("http").createServer();const redisClient = require("redis").createClient();const io = require("socket.io")(httpServer, {  adapter: require("socket.io-redis")({    pubClient: redisClient,    subClient: redisClient.duplicate()  })});
```

```js
socket.on("disconnect", (reason) => {  console.log(reason); // "ping timeout"});
```

```js
const io = require("socket.io")(httpServer, {  pingTimeout: 30000});
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    const isOriginValid = check(req);    callback(null, isOriginValid);  }});
```

```js
const io = require("socket.io")(httpServer, {  perMessageDeflate: {    threshold: 2048, // defaults to 1024    zlibDeflateOptions: {      chunkSize: 8 * 1024, // defaults to 16 * 1024    },    zlibInflateOptions: {      windowBits: 14, // defaults to 15      memLevel: 7, // defaults to 8    },    clientNoContextTakeover: true, // defaults to negotiated value.    serverNoContextTakeover: true, // defaults to negotiated value.    serverMaxWindowBits: 10, // defaults to negotiated value.    concurrencyLimit: 20, // defaults to 10  }});
```

```js
const io = require("socket.io")(httpServer, {  httpCompression: {    threshold: 2048, // defaults to 1024    chunkSize: 8 * 1024, // defaults to 16 * 1024    windowBits: 14, // defaults to 15    memLevel: 7, // defaults to 8  }});
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: "eiows"});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: ["https://example.com", "https://dev.example.com"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
const io = require("socket.io")(httpServer, {  cookie: {    name: "my-cookie",    httpOnly: true,    sameSite: "strict",    maxAge: 86400  }});
```

```js
const io = require("socket.io")(httpServer, {  allowEIO3: true // false by default});
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server, Socket } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // ...});io.on("connection", (socket: Socket) => {  // ...});httpServer.listen(3000);
```

```js
const options = { /* ... */ };const io = require("socket.io")(options);io.on("connection", socket => { /* ... */ });io.listen(3000);
```

```js
const options = { /* ... */ };const io = require("socket.io")(3000, options);io.on("connection", socket => { /* ... */ });
```

```js
io.httpServer
```

```js
const httpServer = require("http").createServer();const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
const fs = require("fs");const httpServer = require("https").createServer({  key: fs.readFileSync("/tmp/key.pem"),  cert: fs.readFileSync("/tmp/cert.pem")});const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
const fs = require("fs");const httpServer = require("http2").createSecureServer({  allowHTTP1: true,  key: fs.readFileSync("/tmp/key.pem"),  cert: fs.readFileSync("/tmp/cert.pem")});const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
const app = require("express")();const httpServer = require("http").createServer(app);const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);// WARNING !!! app.listen(3000); will not work here, as it creates a new HTTP server
```

```js
const app = require("koa")();const httpServer = require("http").createServer(app.callback());const options = { /* ... */ };const io = require("socket.io")(httpServer, options);io.on("connection", socket => { /* ... */ });httpServer.listen(3000);
```

```js
path
```

```js
/socket.io/
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
serveClient
```

```js
true
```

```js
true
```

```js
<url>/socket.io/socket.io.js
```

```js
<url>/socket.io/socket.io.min.js
```

```js
<url>/socket.io/socket.io.msgpack.min.js
```

```js
adapter
```

```js
socket.io-adapter
```

```js
socket.io-redis
```

```js
const httpServer = require("http").createServer();const redisClient = require("redis").createClient();const io = require("socket.io")(httpServer, {  adapter: require("socket.io-redis")({    pubClient: redisClient,    subClient: redisClient.duplicate()  })});
```

```js
parser
```

```js
socket.io-parser
```

```js
connectTimeout
```

```js
45000
```

```js
pingTimeout
```

```js
5000
```

```js
pingTimeout
```

```js
pingInterval + pingTimeout
```

```js
ping timeout
```

```js
socket.on("disconnect", (reason) => {  console.log(reason); // "ping timeout"});
```

```js
const io = require("socket.io")(httpServer, {  pingTimeout: 30000});
```

```js
pingInterval
```

```js
25000
```

```js
upgradeTimeout
```

```js
10000
```

```js
maxHttpBufferSize
```

```js
1e6
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
allowRequest
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    const isOriginValid = check(req);    callback(null, isOriginValid);  }});
```

```js
transports
```

```js
["polling", "websocket"]
```

```js
transports
```

```js
allowUpgrades
```

```js
true
```

```js
perMessageDeflate
```

```js
false
```

```js
perMessageDeflate
```

```js
false
```

```js
socket.compress(true).emit(...)
```

```js
const io = require("socket.io")(httpServer, {  perMessageDeflate: {    threshold: 2048, // defaults to 1024    zlibDeflateOptions: {      chunkSize: 8 * 1024, // defaults to 16 * 1024    },    zlibInflateOptions: {      windowBits: 14, // defaults to 15      memLevel: 7, // defaults to 8    },    clientNoContextTakeover: true, // defaults to negotiated value.    serverNoContextTakeover: true, // defaults to negotiated value.    serverMaxWindowBits: 10, // defaults to negotiated value.    concurrencyLimit: 20, // defaults to 10  }});
```

```js
httpCompression
```

```js
true
```

```js
httpCompression
```

```js
false
```

```js
socket.compress(true).emit(...)
```

```js
const io = require("socket.io")(httpServer, {  httpCompression: {    threshold: 2048, // defaults to 1024    chunkSize: 8 * 1024, // defaults to 16 * 1024    windowBits: 14, // defaults to 15    memLevel: 7, // defaults to 8  }});
```

```js
wsEngine
```

```js
"ws"
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: "eiows"});
```

```js
cors
```

```js
cors
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: ["https://example.com", "https://dev.example.com"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
cookie
```

```js
cookie
```

```js
const io = require("socket.io")(httpServer, {  cookie: {    name: "my-cookie",    httpOnly: true,    sameSite: "strict",    maxAge: 86400  }});
```

```js
allowEIO3
```

```js
false
```

```js
const io = require("socket.io")(httpServer, {  allowEIO3: true // false by default});
```

# https://socket.io/docs/v3/server-installation

# Server Installation

## Prerequisites​

## Installation​

## Additional packages​

## Other WebSocket server implementations​

Please make sure that Node.js is installed on your system. The current Long Term Support (LTS) release is an ideal starting point.

At least Node.js 10 is needed, older versions are not supported anymore.

The latest Socket.IO release is:

To install the latest release:

To install a specific version:

By default, Socket.IO use the WebSocket server provided by the ws package.

There are 2 optional packages that can be installed alongside this package. These packages are binary add-ons which improve certain operations. Prebuilt binaries are available for the most popular platforms so you don't necessarily need to have a C++ compiler installed on your machine.

To install those packages:

Please note that these packages are optional, the WebSocket server will fallback to the Javascript implementation if they are not available. More information can be found here.

For example, you can use the eiows package, which is a fork of the (now deprecated) uws package:

And then use the wsEngine option:

This implementation "allows, but doesn't guarantee" significant performance and memory-usage improvements over the default implementation. As usual, please benchmark it against your own usage.

- Server
- Installation
- bufferutil: Allows to efficiently perform operations such as masking and unmasking the data payload of the WebSocket frames.
- utf-8-validate: Allows to efficiently check if a message contains valid UTF-8 as required by the spec.
```js
$ npm install socket.io
```

```js
$ npm install socket.io@<version>
```

```js
$ npm install --save-optional bufferutil utf-8-validate
```

```js
$ npm install eiows
```

```js
const io = require("socket.io")(3000, {  wsEngine: "eiows"});
```

```js
$ npm install socket.io
```

```js
$ npm install socket.io@<version>
```

```js
$ npm install --save-optional bufferutil utf-8-validate
```

```js
$ npm install eiows
```

```js
wsEngine
```

```js
const io = require("socket.io")(3000, {  wsEngine: "eiows"});
```

# https://socket.io/docs/v3/server-instance

# The Server instance

## Server#engine​

## Events​

### connection​

The Server instance (often called io in the code examples) has a few attributes that may be of use in your application.

It also inherits all the methods of the main namespace, like namespace.use() (see here) or namespace.allSockets().

A reference to the underlying Engine.IO server.

It can be used to fetch the number of currently connected clients:

Or to generate a custom session ID (the sid query parameter):

The Server instance emits one single event (well, technically two, but connect is an alias for connection):

This event is fired upon a new connection. The first argument is a Socket instance.

- Server
- The Server instance
- connection
```js
const count = io.engine.clientsCount;// may or may not be similar to the count of Socket instances in the main namespace, depending on your usageconst count2 = io.of("/").sockets.size;
```

```js
const uuid = require("uuid");io.engine.generateId = (req) => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
io.on("connection", (socket) => {  // ...});
```

```js
namespace.use()
```

```js
namespace.allSockets()
```

```js
const count = io.engine.clientsCount;// may or may not be similar to the count of Socket instances in the main namespace, depending on your usageconst count2 = io.of("/").sockets.size;
```

```js
sid
```

```js
const uuid = require("uuid");io.engine.generateId = (req) => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
connect
```

```js
connection
```

```js
connection
```

```js
connection
```

```js
io.on("connection", (socket) => {  // ...});
```

# https://socket.io/docs/v3/server-socket-instance

# The Socket instance (server-side)

## Socket#id​

## Socket#handshake​

## Socket#rooms​

## Additional attributes​

## Socket middlewares​

## Events​

### disconnect​

### disconnecting​

Besides:

The Socket instance has a few attributes that may be of use in your application:

Each new connection is assigned a random 20-characters identifier.

This identifier is synced with the value on the client-side.

Upon creation, the Socket joins the room identified by its own id, which means you can use it for private messaging:

Note: you can't overwrite this identifier, as it is used in several parts of the Socket.IO codebase.

This object contains some details about the handshake that happens at the beginning of the Socket.IO session.

Example:

This is a reference to the rooms the Socket is currently in.

As long as you do not overwrite any existing attribute, you can attach any attribute to the Socket instance and use it later:

Those middlewares look a lot like the usual middlewares, except that they are called for each incoming packet:

The next method can also be called with an error object. In that case, the event will not reach the registered event handlers and an error event will be emitted instead:

Note: this feature only exists on the server-side. For the client-side, you might be interested in catch-all listeners.

On the server-side, the Socket instance emits two special events:

This event is fired by the Socket instance upon disconnection.

Here is the list of possible reasons:

This event is similar to disconnect but is fired a bit earlier, when the Socket#rooms set is not empty yet

Note: those events, along with connect, connect_error, newListener and removeListener, are special events that shouldn't be used in your application:

- Server
- The Socket instance
- emitting and listening to events
- broadcasting events
- joining and leaving rooms
- disconnect
- disconnecting
```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});// client-sidesocket.on("connect", () => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});
```

```js
io.on("connection", socket => {  socket.on("private message", (anotherSocketId, msg) => {    socket.to(anotherSocketId).emit("private message", socket.id, msg);  });});
```

```js
{  headers: /* the headers of the initial request */  query: /* the query params of the initial request */  auth: /* the authentication payload */  time: /* the date of creation (as string) */  issued: /* the date of creation (unix timestamp) */  url: /* the request URL string */  address: /* the ip of the client */  xdomain: /* whether the connection is cross-domain */  secure: /* whether the connection is secure */}
```

```js
{  "headers": {    "user-agent": "xxxx",    "accept": "*/*",    "host": "example.com",    "connection": "close"  },  "query": {    "EIO": "4",    "transport": "polling",    "t": "NNjNltH"  },  "auth": {    "token": "123"  },  "time": "Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)",  "issued": 1606005226969,  "url": "/socket.io/?EIO=4&transport=polling&t=NNjNltH",  "address": "::ffff:1.2.3.4",  "xdomain": false,  "secure": true}
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
// in a middlewareio.use(async (socket, next) => {  try {    const user = await fetchUser(socket);    socket.user = user;  } catch (e) {    next(new Error("unknown user"));  }});io.on("connection", (socket) => {  console.log(socket.user);  // in a listener  socket.on("set username", (username) => {    socket.username = username;  });});
```

```js
socket.use(([event, ...args], next) => {  // do something with the packet (logging, authorization, rate limiting...)  // do not forget to call next() at the end  next();});
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    for (const room of socket.rooms) {      if (room !== socket.id) {        socket.to(room).emit("user has left", socket.id);      }    }  });});
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});// client-sidesocket.on("connect", () => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});
```

```js
io.on("connection", socket => {  socket.on("private message", (anotherSocketId, msg) => {    socket.to(anotherSocketId).emit("private message", socket.id, msg);  });});
```

```js
{  headers: /* the headers of the initial request */  query: /* the query params of the initial request */  auth: /* the authentication payload */  time: /* the date of creation (as string) */  issued: /* the date of creation (unix timestamp) */  url: /* the request URL string */  address: /* the ip of the client */  xdomain: /* whether the connection is cross-domain */  secure: /* whether the connection is secure */}
```

```js
{  "headers": {    "user-agent": "xxxx",    "accept": "*/*",    "host": "example.com",    "connection": "close"  },  "query": {    "EIO": "4",    "transport": "polling",    "t": "NNjNltH"  },  "auth": {    "token": "123"  },  "time": "Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)",  "issued": 1606005226969,  "url": "/socket.io/?EIO=4&transport=polling&t=NNjNltH",  "address": "::ffff:1.2.3.4",  "xdomain": false,  "secure": true}
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
// in a middlewareio.use(async (socket, next) => {  try {    const user = await fetchUser(socket);    socket.user = user;  } catch (e) {    next(new Error("unknown user"));  }});io.on("connection", (socket) => {  console.log(socket.user);  // in a listener  socket.on("set username", (username) => {    socket.username = username;  });});
```

```js
socket.use(([event, ...args], next) => {  // do something with the packet (logging, authorization, rate limiting...)  // do not forget to call next() at the end  next();});
```

```js
next
```

```js
error
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
disconnect
```

```js
disconnecting
```

```js
disconnect
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
server namespace disconnect
```

```js
client namespace disconnect
```

```js
server shutting down
```

```js
ping timeout
```

```js
pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
disconnecting
```

```js
disconnect
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    for (const room of socket.rooms) {      if (room !== socket.id) {        socket.to(room).emit("user has left", socket.id);      }    }  });});
```

```js
connect
```

```js
connect_error
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

# https://socket.io/docs/v3/testing

# Testing

## Example with mocha​

## Example with jest​

## Example with tape​

You will find below some code examples with common testing libraries:

Installation: npm i -D mocha chai

Installation: npm i -D jest

Installation: npm i -D tape

- Documentation
- Testing
- mocha
- jest
- tape
```js
// with { "type": "module" } in your package.jsonimport { createServer } from "http";import { io as Client } from "socket.io-client";import { Server } from "socket.io";import { assert } from "chai";// with { "type": "commonjs" } in your package.json// const { createServer } = require("http");// const { Server } = require("socket.io");// const Client = require("socket.io-client");// const assert = require("chai").assert;describe("my awesome project", () => {  let io, serverSocket, clientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket = new Client(`http://localhost:${port}`);      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.close();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work (with ack)", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });});
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const Client = require("socket.io-client");describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket = new Client(`http://localhost:${port}`);      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.close();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work (with ack)", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });});
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const Client = require("socket.io-client");const test = require("tape");let io, serverSocket, clientSocket;test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = httpServer.address().port;    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket = new Client(`http://localhost:${port}`);    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works (with ack)", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test.onFinish(() => {  io.close();  clientSocket.close();});
```

```js
mocha
```

```js
npm i -D mocha chai
```

```js
// with { "type": "module" } in your package.jsonimport { createServer } from "http";import { io as Client } from "socket.io-client";import { Server } from "socket.io";import { assert } from "chai";// with { "type": "commonjs" } in your package.json// const { createServer } = require("http");// const { Server } = require("socket.io");// const Client = require("socket.io-client");// const assert = require("chai").assert;describe("my awesome project", () => {  let io, serverSocket, clientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket = new Client(`http://localhost:${port}`);      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.close();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work (with ack)", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });});
```

```js
jest
```

```js
npm i -D jest
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const Client = require("socket.io-client");describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket = new Client(`http://localhost:${port}`);      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.close();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work (with ack)", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });});
```

```js
tape
```

```js
npm i -D tape
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const Client = require("socket.io-client");const test = require("tape");let io, serverSocket, clientSocket;test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = httpServer.address().port;    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket = new Client(`http://localhost:${port}`);    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works (with ack)", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test.onFinish(() => {  io.close();  clientSocket.close();});
```

# https://socket.io/docs/v3/troubleshooting-connection-issues

# Troubleshooting connection issues

## In Node.js​

## In the browser​

### Listening to the connect_error event​

### Debug logs​

### In the Network Monitor of your browser​

First and foremost, please note that disconnections are common and expected, even on a stable Internet connection:

That being said, the Socket.IO client will always try to reconnect, unless specifically told otherwise.

Let's review how you can troubleshoot a connection failure.

Common errors:

Please make sure the Socket.IO server is actually reachable at the given URL. You can test it with:

which should return something like this:

If that's not the case, please check that the Socket.IO server is running, and that there is nothing in between that prevents the connection.

You can test it with rejectUnauthorized set to false.

If that works, it could mean that the SSL certificate is invalid, or, if you are using a self-signed certificate, that you have to trust it on the client-side:

As explained here, you can also enable the logs to see what's going on under the hood.

For reference, here are the logs for a successful connection:

In most cases, you should see something like this:

The Socket.IO server may return the following HTTP status:

In case of an HTTP 400 response, the response payload will be one of the following:

The transport query parameter is missing or invalid.

To reproduce: curl "<url>/socket.io/" or curl "<url>/socket.io/?transport=udp"

The session ID (included in the sid query parameter) is unknown from the server. That may happen in a multi-server setup.

To reproduce: curl "<url>/socket.io/?transport=polling&sid=1234"

The initial request must be a GET request.

To reproduce: curl -X PUT "<url>/socket.io/?transport=polling"

An error has occurred during the handshake process.

This error cannot be easily reproduced with a single curl command.

The request was denied in the allowRequest handler.

To reproduce:

The protocol version is not supported by the server. Support for Socket.IO v2 clients must be explicitly enabled with the allowEIO3 option:

To reproduce: curl "<url>/socket.io/?transport=polling&EIO=3"

Another quite common error is:

Which probably means that you have to enable Cross-Origin Resource Sharing (CORS) on the server-side. Please see the documentation here.

- Documentation
- Troubleshooting
- anything between the user and the Socket.IO server may encounter a temporary failure or be restarted
- the server itself may be killed as part of an autoscaling policy
- the user may lose connection or switch from WiFi to 4G, in case of a mobile browser
- the browser itself may freeze an inactive tab
- ...
- the server might not be reachable
- there might be an issue with the SSL certificate of the server
- the Engine.IO handshake (contains the session ID — here, zBjrh...AAAK — that is used in subsequent requests)
- the Socket.IO handshake request (contains the value of the auth option)
- the Socket.IO handshake response (contains the Socket#id)
- the WebSocket connection
- the first HTTP long-polling request, which is closed once the WebSocket connection is established
- 101 Switching Protocols: when the WebSocket connection is established
- 200 OK: when in HTTP long-polling mode (GET for reading, POST for writing)
- 400 Bad Request: when something went wrong
- {"code":0,"message":"Transport unknown"}
- {"code":1,"message":"Session ID unknown"}
- {"code":2,"message":"Bad handshake method"}
- {"code":3,"message":"Bad request"}
- {"code":4,"message":"Forbidden"}
- {"code":5,"message":"Unsupported protocol version"}
```js
const socket = require("socket.io-client")("https://example.com");socket.on("connect_error", (err) => {  console.log(`connect_error due to ${err.message}`);});
```

```js
curl "https://example.com/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}
```

```js
const socket = require("socket.io-client")("https://example.com", {  rejectUnauthorized: false // WARN: please do not do this in production});
```

```js
const socket = require("socket.io-client")("https://example.com", {  ca: fs.readFileSync('./cert.pem')});
```

```js
$ DEBUG=socket* node index.jssocket.io-client:url parse https://example.com +0mssocket.io-client new io instance for https://example.com +0mssocket.io-client:manager readyState closed +0mssocket.io-client:manager opening https://example.com +0mssocket.io-client:manager connect attempt will timeout after 20000 +7mssocket.io-client:manager readyState opening +1mssocket.io-client:manager open +6mssocket.io-client:manager cleanup +0mssocket.io-client:socket transport is open - connecting +0mssocket.io-client:manager writing packet {"type":0,"nsp":"/"} +1mssocket.io-parser encoding packet {"type":0,"nsp":"/"} +0mssocket.io-parser encoded {"type":0,"nsp":"/"} as 0 +0mssocket.io-parser decoded 0{"sid":"emVyzJPFYLlVMB7YAAAD"} as {"type":0,"nsp":"/","data":{"sid":"emVyzJPFYLlVMB7YAAAD"}} +2mssocket.io-client:socket socket connected with id emVyzJPFYLlVMB7YAAAD +2ms
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    callback(null, false);  }});
```

```js
const io = require("socket.io")(httpServer, {  allowEIO3: true // false by default});
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ...
```

```js
connect_error
```

```js
const socket = require("socket.io-client")("https://example.com");socket.on("connect_error", (err) => {  console.log(`connect_error due to ${err.message}`);});
```

```js
curl "https://example.com/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}
```

```js
rejectUnauthorized
```

```js
false
```

```js
const socket = require("socket.io-client")("https://example.com", {  rejectUnauthorized: false // WARN: please do not do this in production});
```

```js
const socket = require("socket.io-client")("https://example.com", {  ca: fs.readFileSync('./cert.pem')});
```

```js
$ DEBUG=socket* node index.jssocket.io-client:url parse https://example.com +0mssocket.io-client new io instance for https://example.com +0mssocket.io-client:manager readyState closed +0mssocket.io-client:manager opening https://example.com +0mssocket.io-client:manager connect attempt will timeout after 20000 +7mssocket.io-client:manager readyState opening +1mssocket.io-client:manager open +6mssocket.io-client:manager cleanup +0mssocket.io-client:socket transport is open - connecting +0mssocket.io-client:manager writing packet {"type":0,"nsp":"/"} +1mssocket.io-parser encoding packet {"type":0,"nsp":"/"} +0mssocket.io-parser encoded {"type":0,"nsp":"/"} as 0 +0mssocket.io-parser decoded 0{"sid":"emVyzJPFYLlVMB7YAAAD"} as {"type":0,"nsp":"/","data":{"sid":"emVyzJPFYLlVMB7YAAAD"}} +2mssocket.io-client:socket socket connected with id emVyzJPFYLlVMB7YAAAD +2ms
```

```js
zBjrh...AAAK
```

```js
auth
```

```js
101 Switching Protocols
```

```js
200 OK
```

```js
GET
```

```js
POST
```

```js
400 Bad Request
```

```js
{"code":0,"message":"Transport unknown"}
```

```js
transport
```

```js
curl "<url>/socket.io/"
```

```js
curl "<url>/socket.io/?transport=udp"
```

```js
{"code":1,"message":"Session ID unknown"}
```

```js
sid
```

```js
curl "<url>/socket.io/?transport=polling&sid=1234"
```

```js
{"code":2,"message":"Bad handshake method"}
```

```js
GET
```

```js
curl -X PUT "<url>/socket.io/?transport=polling"
```

```js
{"code":3,"message":"Bad request"}
```

```js
curl
```

```js
{"code":4,"message":"Forbidden"}
```

```js
allowRequest
```

```js
const io = require("socket.io")(httpServer, {  allowRequest: (req, callback) => {    callback(null, false);  }});
```

```js
{"code":5,"message":"Unsupported protocol version"}
```

```js
allowEIO3
```

```js
const io = require("socket.io")(httpServer, {  allowEIO3: true // false by default});
```

```js
curl "<url>/socket.io/?transport=polling&EIO=3"
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ...
```

# https://socket.io/docs/v3/using-multiple-nodes

# Using multiple nodes

## Sticky load balancing​

## Passing events between nodes​

### Why is sticky-session required​

### Enabling sticky-session​

### NginX configuration​

### Apache HTTPD configuration​

### HAProxy configuration​

### Traefik​

### Using Node.js Cluster​

### The Redis adapter​

### Sending messages from the outside world​

When deploying multiple Socket.IO servers, there are two things to take care of:

If you plan to distribute the load of connections among different processes or machines, you have to make sure that all requests associated with a particular session ID reach the process that originated them.

This is because the HTTP long-polling transport sends multiple HTTP requests during the lifetime of the Socket.IO session.

In fact, Socket.IO could technically work without sticky sessions, with the following synchronization (in dashed lines):

While obviously possible to implement, we think that this synchronization process between the Socket.IO servers would result in a big performance hit for your application.

Remarks:

Documentation: transports

To achieve sticky-session, there are two main solutions:

You will find below some examples with common load-balancing solutions:

For other platforms, please refer to the relevant documentation:

Important note: if you are in a CORS situation (the front domain is different from the server domain) and session affinity is achieved with a cookie, you need to allow credentials:

Server

Client

Without it, the cookie will not be sent by the browser and you will experience HTTP 400 "Session ID unknown" responses. More information here.

Within the http { } section of your nginx.conf file, you can declare a upstream section with a list of Socket.IO process you want to balance load between:

Notice the hash instruction that indicates the connections will be sticky.

Make sure you also configure worker_processes in the topmost level to indicate how many workers NginX should use. You might also want to look into tweaking the worker_connections setting within the events { } block.

Links:

Links:

Links:

Using container labels:

With the File provider:

Links:

Just like NginX, Node.js comes with built-in clustering support through the cluster module.

There are several solutions, depending on your use case:

Example with @socket.io/sticky:

Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to all clients (or to the clients in a certain room) you’ll need some way of passing messages between processes or computers.

The interface in charge of routing messages is what we call the Adapter. You can implement your own on top of the socket.io-adapter (by inheriting from it) or you can use the one we provide on top of Redis: socket.io-redis:

Then the following call:

will be broadcast to every clients through the Pub/Sub mechanism of Redis:

Using the Redis adapter has another benefit: you can now emit events from outside the context of your Socket.IO processes.

This emitter is available in several languages:

- Server
- Using multiple nodes
- enabling sticky session, if HTTP long-polling is enabled (which is the default): see below
- using the Redis adapter (or another compatible Adapter): see below
- without enabling sticky-session, you will experience HTTP 400 errors due to "Session ID unknown"
- the WebSocket transport does not have this limitation, since it relies on a single TCP connection for the whole session. Which means that if you disable the HTTP long-polling transport (which is a perfectly valid choice in 2021), you won't need sticky sessions:
- routing clients based on a cookie (recommended solution)
- routing clients based on their originating address
- NginX (IP-based)
- Apache HTTPD (cookie-based)
- HAProxy (cookie-based)
- Traefik (cookie-based)
- Node.js cluster module
- Kubernetes: https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/
- AWS (Application Load Balancers): https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#sticky-sessions
- GCP: https://cloud.google.com/load-balancing/docs/backend-service#session_affinity
- Heroku: https://devcenter.heroku.com/articles/session-affinity
- Example
- NginX Documentation
- Example
- Documentation
- Example
- Documentation
- Example
- Documentation
- Javascript: https://github.com/socketio/socket.io-emitter
- Java: https://github.com/sunsus/socket.io-java-emitter
- Python: https://pypi.org/project/socket.io-emitter/
- PHP: https://github.com/rase-/socket.io-php-emitter
- Golang: https://github.com/yosuke-furukawa/socket.io-go-emitter
- Perl: https://metacpan.org/pod/SocketIO::Emitter
- Rust: https://github.com/epli2/socketio-rust-emitter
```js
const socket = io("https://io.yourhost.com", {  // WARNING: in that case, there is no fallback to long-polling  transports: [ "websocket" ] // or [ "websocket", "polling" ] (the order matters)});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://front-domain.com",    methods: ["GET", "POST"],    credentials: true  }});
```

```js
const io = require("socket.io-client");const socket = io("https://server-domain.com", {  withCredentials: true});
```

```js
http {  server {    listen 3000;    server_name io.yourhost.com;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://nodes;      # enable WebSockets      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }  upstream nodes {    # enable sticky session with either "hash" (uses the complete IP address)    hash $remote_addr consistent;    # or "ip_hash" (uses the first three octets of the client IPv4 address, or the entire IPv6 address)    # ip_hash;    # or "sticky" (needs commercial subscription)    # sticky cookie srv_id expires=1h domain=.example.com path=/;    server app01:3000;    server app02:3000;    server app03:3000;  }}
```

```js
Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED<Proxy "balancer://nodes_polling">    BalancerMember "http://app01:3000" route=app01    BalancerMember "http://app02:3000" route=app02    BalancerMember "http://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy><Proxy "balancer://nodes_ws">    BalancerMember "ws://app01:3000" route=app01    BalancerMember "ws://app02:3000" route=app02    BalancerMember "ws://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy>RewriteEngine OnRewriteCond %{HTTP:Upgrade} =websocket [NC]RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]RewriteCond %{HTTP:Upgrade} !=websocket [NC]RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]ProxyTimeout 3
```

```js
# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03
```

```js
# docker-compose.ymlservices:  traefik:    image: traefik:2.4    volumes:      - /var/run/docker.sock:/var/run/docker.sock    links:      - server  server:    image: my-image:latest    labels:      - "traefik.http.routers.my-service.rule=PathPrefix(`/`)"      - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id      - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true
```

```js
## Dynamic configurationhttp:  services:    my-service:      rule: "PathPrefix(`/`)"      loadBalancer:        sticky:          cookie:            name: server_id            httpOnly: true
```

```js
const cluster = require("cluster");const http = require("http");const { Server } = require("socket.io");const redisAdapter = require("socket.io-redis");const numCPUs = require("os").cpus().length;const { setupMaster, setupWorker } = require("@socket.io/sticky");if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  const httpServer = http.createServer();  setupMaster(httpServer, {    loadBalancingMethod: "least-connection", // either "random", "round-robin" or "least-connection"  });  httpServer.listen(3000);  for (let i = 0; i < numCPUs; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });} else {  console.log(`Worker ${process.pid} started`);  const httpServer = http.createServer();  const io = new Server(httpServer);  io.adapter(redisAdapter({ host: "localhost", port: 6379 }));  setupWorker(io);  io.on("connection", (socket) => {    /* ... */  });}
```

```js
const io = require("socket.io")(3000);const redis = require("socket.io-redis");io.adapter(redis({ host: "localhost", port: 6379 }));
```

```js
io.emit("hi", "all sockets");
```

```js
const socket = io("https://io.yourhost.com", {  // WARNING: in that case, there is no fallback to long-polling  transports: [ "websocket" ] // or [ "websocket", "polling" ] (the order matters)});
```

```js
transports
```

```js
cluster
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://front-domain.com",    methods: ["GET", "POST"],    credentials: true  }});
```

```js
const io = require("socket.io-client");const socket = io("https://server-domain.com", {  withCredentials: true});
```

```js
http { }
```

```js
nginx.conf
```

```js
upstream
```

```js
http {  server {    listen 3000;    server_name io.yourhost.com;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://nodes;      # enable WebSockets      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }  upstream nodes {    # enable sticky session with either "hash" (uses the complete IP address)    hash $remote_addr consistent;    # or "ip_hash" (uses the first three octets of the client IPv4 address, or the entire IPv6 address)    # ip_hash;    # or "sticky" (needs commercial subscription)    # sticky cookie srv_id expires=1h domain=.example.com path=/;    server app01:3000;    server app02:3000;    server app03:3000;  }}
```

```js
hash
```

```js
worker_processes
```

```js
worker_connections
```

```js
events { }
```

```js
Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED<Proxy "balancer://nodes_polling">    BalancerMember "http://app01:3000" route=app01    BalancerMember "http://app02:3000" route=app02    BalancerMember "http://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy><Proxy "balancer://nodes_ws">    BalancerMember "ws://app01:3000" route=app01    BalancerMember "ws://app02:3000" route=app02    BalancerMember "ws://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy>RewriteEngine OnRewriteCond %{HTTP:Upgrade} =websocket [NC]RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]RewriteCond %{HTTP:Upgrade} !=websocket [NC]RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]ProxyTimeout 3
```

```js
# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03
```

```js
# docker-compose.ymlservices:  traefik:    image: traefik:2.4    volumes:      - /var/run/docker.sock:/var/run/docker.sock    links:      - server  server:    image: my-image:latest    labels:      - "traefik.http.routers.my-service.rule=PathPrefix(`/`)"      - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id      - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true
```

```js
## Dynamic configurationhttp:  services:    my-service:      rule: "PathPrefix(`/`)"      loadBalancer:        sticky:          cookie:            name: server_id            httpOnly: true
```

```js
cluster
```

```js
@socket.io/sticky
```

```js
sid
```

```js
sticky-session
```

```js
connection.remoteAddress
```

```js
socketio-sticky-session
```

```js
x-forwarded-for
```

```js
@socket.io/sticky
```

```js
const cluster = require("cluster");const http = require("http");const { Server } = require("socket.io");const redisAdapter = require("socket.io-redis");const numCPUs = require("os").cpus().length;const { setupMaster, setupWorker } = require("@socket.io/sticky");if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  const httpServer = http.createServer();  setupMaster(httpServer, {    loadBalancingMethod: "least-connection", // either "random", "round-robin" or "least-connection"  });  httpServer.listen(3000);  for (let i = 0; i < numCPUs; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });} else {  console.log(`Worker ${process.pid} started`);  const httpServer = http.createServer();  const io = new Server(httpServer);  io.adapter(redisAdapter({ host: "localhost", port: 6379 }));  setupWorker(io);  io.on("connection", (socket) => {    /* ... */  });}
```

```js
const io = require("socket.io")(3000);const redis = require("socket.io-redis");io.adapter(redis({ host: "localhost", port: 6379 }));
```

```js
io.emit("hi", "all sockets");
```

# https://socket.io/docs/v4

# Introduction

## What Socket.IO is​

## What Socket.IO is not​

## Features​

## Common questions​

## Next steps​

### Server implementations​

### Client implementations​

### HTTP long-polling fallback​

### Automatic reconnection​

### Packet buffering​

### Acknowledgements​

### Broadcasting​

### Multiplexing​

### Is Socket.IO still needed today?​

### What is the overhead of the Socket.IO protocol?​

### Something does not work properly, please help?​

If you are new to Socket.IO, we recommend checking out our tutorial.

Socket.IO is a library that enables low-latency, bidirectional and event-based communication between a client and a server.

The Socket.IO connection can be established with different low-level transports:

Socket.IO will automatically pick the best available option, depending on:

You can find more detail about that in the "How it works" section.

Socket.IO is NOT a WebSocket implementation.

Although Socket.IO indeed uses WebSocket for transport when possible, it adds additional metadata to each packet. That is why a WebSocket client will not be able to successfully connect to a Socket.IO server, and a Socket.IO client will not be able to connect to a plain WebSocket server either.

If you are looking for a plain WebSocket server, please take a look at ws or µWebSockets.js.

There are also discussions for including a WebSocket server in the Node.js core.

On the client-side, you might be interested in the robust-websocket package.

Socket.IO is not meant to be used in a background service for mobile applications.

The Socket.IO library keeps an open TCP connection to the server, which may result in a high battery drain for your users. Please use a dedicated messaging platform like FCM for this use case.

Here are the features provided by Socket.IO over plain WebSockets:

The connection will fall back to HTTP long-polling in case the WebSocket connection cannot be established.

This feature was the #1 reason people used Socket.IO when the project was created more than ten years ago (!), as the browser support for WebSockets was still in its infancy.

Even if most browsers now support WebSockets (more than 97%), it is still a great feature as we still receive reports from users that cannot establish a WebSocket connection because they are behind some misconfigured proxy.

Under some particular conditions, the WebSocket connection between the server and the client can be interrupted with both sides being unaware of the broken state of the link.

That's why Socket.IO includes a heartbeat mechanism, which periodically checks the status of the connection.

And when the client eventually gets disconnected, it automatically reconnects with an exponential back-off delay, in order not to overwhelm the server.

The packets are automatically buffered when the client is disconnected, and will be sent upon reconnection.

More information here.

Socket.IO provides a convenient way to send an event and receive a response:

Sender

Receiver

You can also add a timeout:

On the server-side, you can send an event to all connected clients or to a subset of clients:

This also works when scaling to multiple nodes.

Namespaces allow you to split the logic of your application over a single shared connection. This can be useful for example if you want to create an "admin" channel that only authorized users can join.

More on that here.

That's a fair question, since WebSockets are supported almost everywhere now.

That being said, we believe that, if you use plain WebSockets for your application, you will eventually need to implement most of the features that are already included (and battle-tested) in Socket.IO, like reconnection, acknowledgements or broadcasting.

socket.emit("hello", "world") will be sent as a single WebSocket frame containing 42["hello","world"] with:

So, a few additional bytes for each message, which can be further reduced by the usage of a custom parser.

The size of the browser bundle itself is 10.4 kB (minified and gzipped).

You can find the details of the Socket.IO protocol here.

Please check our Troubleshooting guide.

- Documentation
- Introduction
- HTTP long-polling
- WebSocket
- WebTransport
- the capabilities of the browser (see here and here)
- the network (some networks block WebSocket and/or WebTransport connections)
- 4 being Engine.IO "message" packet type
- 2 being Socket.IO "message" packet type
- ["hello","world"] being the JSON.stringify()-ed version of the arguments array
- Get started example
- Server installation
- Client installation
```js
// WARNING: the client will NOT be able to connect!const socket = io("ws://echo.websocket.org");
```

```js
socket.emit("hello", "world", (response) => {  console.log(response); // "got it"});
```

```js
socket.on("hello", (arg, callback) => {  console.log(arg); // "world"  callback("got it");});
```

```js
socket.timeout(5000).emit("hello", "world", (err, response) => {  if (err) {    // the other side did not acknowledge the event in the given delay  } else {    console.log(response); // "got it"  }});
```

```js
// to all connected clientsio.emit("hello");// to all connected clients in the "news" roomio.to("news").emit("hello");
```

```js
io.on("connection", (socket) => {  // classic users});io.of("/admin").on("connection", (socket) => {  // admin users});
```

```js
// WARNING: the client will NOT be able to connect!const socket = io("ws://echo.websocket.org");
```

```js
socket.emit("hello", "world", (response) => {  console.log(response); // "got it"});
```

```js
socket.on("hello", (arg, callback) => {  console.log(arg); // "world"  callback("got it");});
```

```js
socket.timeout(5000).emit("hello", "world", (err, response) => {  if (err) {    // the other side did not acknowledge the event in the given delay  } else {    console.log(response); // "got it"  }});
```

```js
// to all connected clientsio.emit("hello");// to all connected clients in the "news" roomio.to("news").emit("hello");
```

```js
io.on("connection", (socket) => {  // classic users});io.of("/admin").on("connection", (socket) => {  // admin users});
```

```js
socket.emit("hello", "world")
```

```js
42["hello","world"]
```

```js
["hello","world"]
```

```js
JSON.stringify()
```

```js
10.4 kB
```

# https://socket.io/docs/v4/adapter

# Adapter

## Emitter​

## Emitter cheatsheet​

An Adapter is a server-side component which is responsible for broadcasting events to all or a subset of clients.

When scaling to multiple Socket.IO servers, you will need to replace the default in-memory adapter by another implementation, so the events are properly routed to all clients.

Here is the list of adapters that are maintained by our team:

There are also several other options which are maintained by the (awesome!) community:

Please note that enabling sticky sessions is still needed when using multiple Socket.IO servers and HTTP long-polling. More information here.

You can have access to the adapter instance with:

Starting with socket.io@3.1.0, each Adapter instance emits the following events:

Example:

Most adapter implementations come with their associated emitter package, which allows communicating to the group of Socket.IO servers from another Node.js process.

This may be useful for example in a microservice setup, where all clients connect to the microservice M1, while the microservice M2 uses the emitter to broadcast packets (uni-directional communication).

The emitter also supports the utility methods that were added in socket.io@4.0.0:

- Adapters
- Introduction
- the Redis adapter
- the Redis Streams adapter
- the MongoDB adapter
- the Postgres adapter
- the Cluster adapter
- the Google Cloud Pub/Sub adapter
- the AWS SQS adapter
- the Azure Service Bus adapter
- AMQP (e.g. RabbitMQ)
- NATS
- NATS
- create-room (argument: room)
- delete-room (argument: room)
- join-room (argument: room, id)
- leave-room (argument: room, id)
- socketsJoin()
- socketsLeave()
- disconnectSockets()
- serverSideEmit()
```js
// main namespaceconst mainAdapter = io.of("/").adapter; // WARNING! io.adapter() will not work// custom namespaceconst adminAdapter = io.of("/admin").adapter;
```

```js
io.of("/").adapter.on("create-room", (room) => {  console.log(`room ${room} was created`);});io.of("/").adapter.on("join-room", (room, id) => {  console.log(`socket ${id} has joined room ${room}`);});
```

```js
// to all clientsemitter.emit(/* ... */);// to all clients in "room1"emitter.to("room1").emit(/* ... */);// to all clients in "room1" except those in "room2"emitter.to("room1").except("room2").emit(/* ... */);const adminEmitter = emitter.of("/admin");// to all clients in the "admin" namespaceadminEmitter.emit(/* ... */);// to all clients in the "admin" namespace and in the "room1" roomadminEmitter.to("room1").emit(/* ... */);
```

```js
// make all Socket instances join the "room1" roomemitter.socketsJoin("room1");// make all Socket instances of the "admin" namespace in the "room1" room join the "room2" roomemitter.of("/admin").in("room1").socketsJoin("room2");
```

```js
// make all Socket instances leave the "room1" roomemitter.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsemitter.in("room1").socketsLeave(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" roomemitter.of("/admin").in("room1").socketsLeave("room2");
```

```js
// make all Socket instances disconnectemitter.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and discard the low-level connection)emitter.in("room1").disconnectSockets(true);// make all Socket instances in the "room1" room of the "admin" namespace disconnectemitter.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDemitter.of("/admin").in(theSocketId).disconnectSockets();
```

```js
// emit an event to all the Socket.IO servers of the clusteremitter.serverSideEmit("hello", "world");// Socket.IO server (server-side)io.on("hello", (arg) => {  console.log(arg); // prints "world"});
```

```js
// main namespaceconst mainAdapter = io.of("/").adapter; // WARNING! io.adapter() will not work// custom namespaceconst adminAdapter = io.of("/admin").adapter;
```

```js
socket.io@3.1.0
```

```js
create-room
```

```js
delete-room
```

```js
join-room
```

```js
leave-room
```

```js
io.of("/").adapter.on("create-room", (room) => {  console.log(`room ${room} was created`);});io.of("/").adapter.on("join-room", (room, id) => {  console.log(`socket ${id} has joined room ${room}`);});
```

```js
// to all clientsemitter.emit(/* ... */);// to all clients in "room1"emitter.to("room1").emit(/* ... */);// to all clients in "room1" except those in "room2"emitter.to("room1").except("room2").emit(/* ... */);const adminEmitter = emitter.of("/admin");// to all clients in the "admin" namespaceadminEmitter.emit(/* ... */);// to all clients in the "admin" namespace and in the "room1" roomadminEmitter.to("room1").emit(/* ... */);
```

```js
socket.io@4.0.0
```

```js
socketsJoin()
```

```js
// make all Socket instances join the "room1" roomemitter.socketsJoin("room1");// make all Socket instances of the "admin" namespace in the "room1" room join the "room2" roomemitter.of("/admin").in("room1").socketsJoin("room2");
```

```js
socketsLeave()
```

```js
// make all Socket instances leave the "room1" roomemitter.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsemitter.in("room1").socketsLeave(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" roomemitter.of("/admin").in("room1").socketsLeave("room2");
```

```js
disconnectSockets()
```

```js
// make all Socket instances disconnectemitter.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and discard the low-level connection)emitter.in("room1").disconnectSockets(true);// make all Socket instances in the "room1" room of the "admin" namespace disconnectemitter.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDemitter.of("/admin").in(theSocketId).disconnectSockets();
```

```js
serverSideEmit()
```

```js
// emit an event to all the Socket.IO servers of the clusteremitter.serverSideEmit("hello", "world");// Socket.IO server (server-side)io.on("hello", (arg) => {  console.log(arg); // prints "world"});
```

# https://socket.io/docs/v4/admin-ui

# Admin UI

## Current features​

## Installation​

## How it works​

## Latest releases​

### Server-side​

### Client-side​

### Available options​

The Socket.IO admin UI can be used to have an overview of the state of your Socket.IO deployment.

The source code can be found here: https://github.com/socketio/socket.io-admin-ui/

Link to the hosted version: https://admin.socket.io/

If you have any feedback / suggestions, do not hesitate!

First, install the @socket.io/admin-ui package:

And then invoke the instrument method on your Socket.IO server:

The module is compatible with:

Example with NestJS:

You can then head up to https://admin.socket.io, or host the files found in the ui/dist folder here.

Important note: the website at https://admin.socket.io is totally static (hosted on Vercel), we do not (and will never) store any information about yourself or your browser (no tracking, no analytics, ...). That being said, hosting the files yourself is totally fine.

You should see the following modal:

Please enter the URL of your server (for example, http://localhost:3000 or https://example.com) and the credentials, if applicable (see the auth option below).

Default value: -

This option is mandatory. You can either disable authentication (please use with caution):

Or use basic authentication:

Please note that the bcrypt package does not currently support hashes starting with the $2y$ prefix, which is used by some BCrypt implementations (for example https://bcrypt-generator.com/ or https://www.bcrypt.fr/). You can check the validity of the hash with:

You can generate a valid hash with:

See also:

Default value: /admin

The name of the namespace which will be created to handle the administrative tasks.

This namespace is a classic Socket.IO namespace, you can access it with:

More information here.

Default value: false

Whether to put the admin UI in read-only mode (no join, leave or disconnect allowed).

Default value: require("os").hostname()

The ID of the given server. If you have several Socket.IO servers on the same machine, you'll need to give them a distinct ID:

Default value: new InMemoryStore()

The store is used to store the session IDs so the user do not have to retype the credentials upon reconnection.

If you use basic authentication in a multi-server setup, you should provide a custom store:

Default value: development

In production mode, the server won't send all details about the socket instances and the rooms, thus reducing the memory footprint of the instrumentation.

The production mode can also be enabled with the NODE_ENV environment variable:

The source code can be found here: https://github.com/socketio/socket.io-admin-ui/

The instrument method simply:

- Advanced
- Admin UI
- overview of the servers and the clients that are currently connected
- details of each socket instance (active transport, handshake, rooms, ...)
- details of each room
- details of every event emitted or received by the server
- administrative operations (join, leave, disconnect)
- Socket.IO v4 server
- Socket.IO v3 server (>= 3.1.0), but without the operations on rooms (join, leave, disconnection)
- https://github.com/kelektiv/node.bcrypt.js/issues/849
- https://stackoverflow.com/a/36225192/5138796
- creates a namespace and adds an authentication middleware if applicable
- register listeners for the connection and disconnect events for each existing namespaces to track the socket instances
- register a timer which will periodically send stats from the server to the UI
- register handlers for the join, leave and _disconnect commands sent from the UI
- 0.5.1 (Oct 2022): GitHub release / diff
- 0.5.0 (Sep 2022): GitHub release / diff
- 0.4.0 (Jun 2022): GitHub release / diff
```js
npm i @socket.io/admin-ui
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const { instrument } = require("@socket.io/admin-ui");const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: ["https://admin.socket.io"],    credentials: true  }});instrument(io, {  auth: false,  mode: "development",});httpServer.listen(3000);
```

```js
import { instrument } from "@socket.io/admin-ui";@WebSocketGateway()export class MyGateway {    // ...    afterInit() {        instrument(this.server, {            auth: false,            mode: "development",        });    }}
```

```js
instrument(io, {  auth: false});
```

```js
instrument(io, {  auth: {    type: "basic",    username: "admin",    password: "$2b$10$heqvAkYMez.Va6Et2uXInOnkCT6/uQj1brkrbyG3LpopDklcq7ZOS" // "changeit" encrypted with bcrypt  },});
```

```js
$ node> require("bcryptjs").compareSync("<the password>", "<the hash>")true
```

```js
$ node> require("bcryptjs").hashSync("changeit", 10)'$2b$10$LQUE...'
```

```js
instrument(io, {  namespaceName: "/custom"});
```

```js
const adminNamespace = io.of("/admin");
```

```js
instrument(io, {  readonly: true});
```

```js
instrument(io, {  serverId: `${require("os").hostname()}#${process.pid}`});
```

```js
const { instrument, RedisStore } = require("@socket.io/admin-ui");instrument(io, {  store: new RedisStore(redisClient)});
```

```js
instrument(io, {  mode: "production"});
```

```js
NODE_ENV=production node index.js
```

```js
@socket.io/admin-ui
```

```js
npm i @socket.io/admin-ui
```

```js
instrument
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const { instrument } = require("@socket.io/admin-ui");const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: ["https://admin.socket.io"],    credentials: true  }});instrument(io, {  auth: false,  mode: "development",});httpServer.listen(3000);
```

```js
import { instrument } from "@socket.io/admin-ui";@WebSocketGateway()export class MyGateway {    // ...    afterInit() {        instrument(this.server, {            auth: false,            mode: "development",        });    }}
```

```js
ui/dist
```

```js
http://localhost:3000
```

```js
https://example.com
```

```js
auth
```

```js
auth
```

```js
instrument(io, {  auth: false});
```

```js
instrument(io, {  auth: {    type: "basic",    username: "admin",    password: "$2b$10$heqvAkYMez.Va6Et2uXInOnkCT6/uQj1brkrbyG3LpopDklcq7ZOS" // "changeit" encrypted with bcrypt  },});
```

```js
bcrypt
```

```js
$2y$
```

```js
$ node> require("bcryptjs").compareSync("<the password>", "<the hash>")true
```

```js
$ node> require("bcryptjs").hashSync("changeit", 10)'$2b$10$LQUE...'
```

```js
namespaceName
```

```js
/admin
```

```js
instrument(io, {  namespaceName: "/custom"});
```

```js
const adminNamespace = io.of("/admin");
```

```js
readonly
```

```js
false
```

```js
instrument(io, {  readonly: true});
```

```js
serverId
```

```js
require("os").hostname()
```

```js
instrument(io, {  serverId: `${require("os").hostname()}#${process.pid}`});
```

```js
store
```

```js
new InMemoryStore()
```

```js
const { instrument, RedisStore } = require("@socket.io/admin-ui");instrument(io, {  store: new RedisStore(redisClient)});
```

```js
mode
```

```js
development
```

```js
instrument(io, {  mode: "production"});
```

```js
NODE_ENV=production node index.js
```

```js
instrument
```

```js
connection
```

```js
disconnect
```

```js
join
```

```js
leave
```

```js
_disconnect
```

```js
0.5.1
```

```js
0.5.0
```

```js
0.4.0
```

# https://socket.io/docs/v4/aws-sqs-adapter

# AWS SQS adapter

## How it works​

## Supported features​

## Installation​

## Usage​

## Options​

## Latest releases​

This adapter uses AWS Simple Queue Service to forward messages between the nodes of a Socket.IO cluster.

Unlike the existing socket.io-sqs package, this package supports binary payloads and dynamic namespaces.

The source code of this adapter can be found here.

Complete changelog

- Adapters
- AWS SQS adapter
```js
npm install @socket.io/aws-sqs-adapter
```

```js
import { SNS } from "@aws-sdk/client-sns";import { SQS } from "@aws-sdk/client-sqs";import { Server } from "socket.io";import { createAdapter } from "@socket.io/aws-sqs-adapter";const snsClient = new SNS();const sqsClient = new SQS();const io = new Server({  adapter: createAdapter(snsClient, sqsClient)});// wait for the creation of the SQS queueawait io.of("/").adapter.init();io.listen(3000);
```

```js
socket.io-sqs
```

```js
socket.io
```

```js
4.0.0
```

```js
0.1.0
```

```js
4.1.0
```

```js
0.1.0
```

```js
4.5.0
```

```js
0.1.0
```

```js
4.6.0
```

```js
npm install @socket.io/aws-sqs-adapter
```

```js
import { SNS } from "@aws-sdk/client-sns";import { SQS } from "@aws-sdk/client-sqs";import { Server } from "socket.io";import { createAdapter } from "@socket.io/aws-sqs-adapter";const snsClient = new SNS();const sqsClient = new SQS();const io = new Server({  adapter: createAdapter(snsClient, sqsClient)});// wait for the creation of the SQS queueawait io.of("/").adapter.init();io.listen(3000);
```

```js
topicName
```

```js
socket.io
```

```js
topicTags
```

```js
queuePrefix
```

```js
socket.io
```

```js
queueTags
```

```js
heartbeatInterval
```

```js
5_000
```

```js
heartbeatTimeout
```

```js
10_000
```

```js
0.1.1
```

```js
0.1.0...0.1.1
```

```js
0.1.0
```

# https://socket.io/docs/v4/azure-service-bus-adapter

# Azure Service Bus adapter

## How it works​

## Supported features​

## Installation​

## Usage​

## Options​

## Latest releases​

This adapter uses Azure Service Bus service to forward messages between the nodes of a Socket.IO cluster.

The source code of this adapter can be found here.

Complete changelog

- Adapters
- Azure Service Bus adapter
```js
npm install @socket.io/azure-service-bus-adapter
```

```js
import { ServiceBusClient, ServiceBusAdministrationClient } from "@azure/service-bus";import { Server } from "socket.io";import { createAdapter } from "@socket.io/azure-service-bus-adapter";const connectionString = "Endpoint=...";const serviceBusClient = new ServiceBusClient(connectionString);const serviceBusAdminClient = new ServiceBusAdministrationClient(connectionString);const io = new Server({  adapter: createAdapter(serviceBusClient, serviceBusAdminClient)});// wait for the creation of the subscriptionawait io.of("/").adapter.init();io.listen(3000);
```

```js
socket.io
```

```js
4.0.0
```

```js
0.1.0
```

```js
4.1.0
```

```js
0.1.0
```

```js
4.5.0
```

```js
0.1.0
```

```js
4.6.0
```

```js
npm install @socket.io/azure-service-bus-adapter
```

```js
import { ServiceBusClient, ServiceBusAdministrationClient } from "@azure/service-bus";import { Server } from "socket.io";import { createAdapter } from "@socket.io/azure-service-bus-adapter";const connectionString = "Endpoint=...";const serviceBusClient = new ServiceBusClient(connectionString);const serviceBusAdminClient = new ServiceBusAdministrationClient(connectionString);const io = new Server({  adapter: createAdapter(serviceBusClient, serviceBusAdminClient)});// wait for the creation of the subscriptionawait io.of("/").adapter.init();io.listen(3000);
```

```js
topicName
```

```js
socket.io
```

```js
topicOptions
```

```js
subscriptionPrefix
```

```js
socket.io
```

```js
receiverOptions
```

```js
topicOptions
```

```js
heartbeatInterval
```

```js
5_000
```

```js
heartbeatTimeout
```

```js
10_000
```

```js
0.1.0
```

# https://socket.io/docs/v4/broadcasting-events

# Broadcasting events

## To all connected clients​

## To all connected clients except the sender​

## With acknowledgements​

## With multiple Socket.IO servers​

Socket.IO makes it easy to send events to all the connected clients.

Please note that broadcasting is a server-only feature.

Clients that are currently disconnected (or in the process of reconnecting) won't receive the event. Storing this event somewhere (in a database, for example) is up to you, depending on your use case.

In the example above, using socket.emit("hello", "world") (without broadcast flag) would send the event to "client A". You can find the list of all the ways to send an event in the cheatsheet.

Starting with Socket.IO 4.5.0, you can now broadcast an event to multiple clients and expect an acknowledgement from each one of them:

All broadcasting forms are supported:

Broadcasting also works with multiple Socket.IO servers.

You just need to replace the default adapter by the Redis Adapter or another compatible adapter.

In certain cases, you may want to only broadcast to clients that are connected to the current server. You can achieve this with the local flag:

In order to target specific clients when broadcasting, please see the documentation about Rooms.

- Events
- Broadcasting events
- in a room
- from a specific socket
- in a namespace
```js
io.emit("hello", "world");
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("hello", "world");});
```

```js
io.timeout(5000).emit("hello", "world", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
io.to("room123").timeout(5000).emit("hello", "world", (err, responses) => {  // ...});
```

```js
socket.broadcast.timeout(5000).emit("hello", "world", (err, responses) => {  // ...});
```

```js
io.of("/the-namespace").timeout(5000).emit("hello", "world", (err, responses) => {  // ...});
```

```js
io.local.emit("hello", "world");
```

```js
io.emit("hello", "world");
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("hello", "world");});
```

```js
socket.emit("hello", "world")
```

```js
broadcast
```

```js
io.timeout(5000).emit("hello", "world", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
io.to("room123").timeout(5000).emit("hello", "world", (err, responses) => {  // ...});
```

```js
socket
```

```js
socket.broadcast.timeout(5000).emit("hello", "world", (err, responses) => {  // ...});
```

```js
io.of("/the-namespace").timeout(5000).emit("hello", "world", (err, responses) => {  // ...});
```

```js
local
```

```js
io.local.emit("hello", "world");
```

# https://socket.io/docs/v4/changelog

# Changelog

## Versioning Policy​

## Breaking changes​

## Important milestones​

## Version usage​

Socket.IO releases closely follow Semantic Versioning.

That means that with a version number x.y.z:

Breaking changes are inconvenient for everyone, so we try to minimize the number of major releases.

We have had two major breaking changes impacting the Socket.IO protocol over the years:

Reference: Migrating from 3.x to 4.0

Aside from the breaking changes listed above, here are the latest important changes in Socket.IO:

As of June 2024:

socket.io package

socket.io-client package

- Changelog
- when releasing critical bug fixes, we make a patch release by increasing the z number (ex: 1.2.3 to 1.2.4).
- when releasing new features or non-critical fixes, we make a minor release by increasing the y number (ex: 1.2.3 to 1.3.0).
- when releasing breaking changes, we make a major release by increasing the x number (ex: 1.2.3 to 2.0.0).
- Socket.IO v2 was released in May 2017
- Socket.IO v3 was released in November 2020
```js
x.y.z
```

```js
1.2.3
```

```js
1.2.4
```

```js
1.2.3
```

```js
1.3.0
```

```js
1.2.3
```

```js
2.0.0
```

```js
4.7.0
```

```js
4.6.0
```

```js
4.4.0
```

```js
4.1.0
```

```js
serverSideEmit()
```

```js
4.0.0
```

```js
socket.io
```

```js
socket.io-client
```

# https://socket.io/docs/v4/changelog/2.5.0

# Version 2.5.0

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

June 26, 2022

⚠️ WARNING ⚠️

The default value of the maxHttpBufferSize option has been decreased from 100 MB to 1 MB, in order to prevent attacks by denial of service.

Security advisory: GHSA-j4f2-536g-r55m

- 2.5.0 (June 26, 2022)
- fix race condition in dynamic namespaces (05e1278)
- ignore packet received after disconnection (22d4bdf)
- only set 'connected' to true after middleware execution (226cc16)
- prevent the socket from joining a room after disconnection (f223178)
- engine.io@~3.6.0 (https://github.com/socketio/engine.io/compare/3.5.0...3.6.0)
- ws@~7.4.2 (no change)
- ensure buffered events are sent in order (991eb0b)
- engine.io-client@~3.5.0 (no change)
- ws@~7.4.2 (no change)
```js
maxHttpBufferSize
```

```js
engine.io@~3.6.0
```

```js
ws@~7.4.2
```

```js
engine.io-client@~3.5.0
```

```js
ws@~7.4.2
```

# https://socket.io/docs/v4/changelog/4.5.0

# Version 4.5.0

## Server​

## Client​

### Bug Fixes​

### Features​

### Dependencies​

### Features​

### Dependencies​

April 23, 2022

This is similar to onAny(), but for outgoing packets.

Syntax:

Added in 531104d.

Syntax:

Added in 8b20457.

A "maxPayload" field is now included in the Engine.IO handshake, so that clients in HTTP long-polling can decide how many packets they have to send to stay under the maxHttpBufferSize value.

This is a backward compatible change which should not mandate a new major revision of the protocol (we stay in v4), as we only add a field in the JSON-encoded handshake data:

Added in 088dcb4.

The "disconnect" event will now include additional details to help debugging if anything has gone wrong.

Example when a payload is over the maxHttpBufferSize value in HTTP long-polling mode:

Added in b862924.

This is similar to onAny(), but for outgoing packets.

Syntax:

Added in 74e3e60.

The server will now include a "maxPayload" field in the handshake details, allowing the clients to decide how many packets they have to send to stay under the maxHttpBufferSize value.

Added in 46fdc2f.

- 4.5.0 (April 23, 2022)
- typings: ensure compatibility with TypeScript 3.x (#4259) (02c87a8)
- engine.io@~6.2.0 (https://github.com/socketio/engine.io/compare/6.1.0...6.2.0)
- ws@~8.2.3 (no change)
- engine.io-client@~6.2.1 (https://github.com/socketio/engine.io-client/compare/6.1.1...6.2.1)
- ws@~8.2.3 (no change)
```js
socket.onAnyOutgoing((event, ...args) => {  console.log(event);});
```

```js
io.timeout(1000).emit("some-event", (err, responses) => {  // ...});
```

```js
0{"sid":"lv_VI97HAXpY6yYWAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000,"maxPayload":1000000}
```

```js
socket.on("disconnect", (reason, details) => {  console.log(reason); // "transport error"  // in that case, details is an error object  console.log(details.message); "xhr post error"  console.log(details.description); // 413 (the HTTP status of the response)  // details.context refers to the XMLHttpRequest object  console.log(details.context.status); // 413  console.log(details.context.responseText); // ""});
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(event);});
```

```js
onAny()
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(event);});
```

```js
io.timeout(1000).emit("some-event", (err, responses) => {  // ...});
```

```js
maxHttpBufferSize
```

```js
maxHttpBufferSize
```

```js
0{"sid":"lv_VI97HAXpY6yYWAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000,"maxPayload":1000000}
```

```js
engine.io@~6.2.0
```

```js
ws@~8.2.3
```

```js
socket.on("disconnect", (reason, details) => {  console.log(reason); // "transport error"  // in that case, details is an error object  console.log(details.message); "xhr post error"  console.log(details.description); // 413 (the HTTP status of the response)  // details.context refers to the XMLHttpRequest object  console.log(details.context.status); // 413  console.log(details.context.responseText); // ""});
```

```js
onAny()
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(event);});
```

```js
maxHttpBufferSize
```

```js
engine.io-client@~6.2.1
```

```js
ws@~8.2.3
```

# https://socket.io/docs/v4/changelog/4.5.1

# Version 4.5.1

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Dependencies​

May 17, 2022

There were some minor bug fixes on the server side, which mandate a client bump.

- 4.5.1 (May 17, 2022)
- forward the local flag to the adapter when using fetchSockets() (30430f0)
- typings: add HTTPS server to accepted types (#4351) (9b43c91)
- engine.io@~6.2.0 (no change)
- ws@~8.2.3 (no change)
- engine.io-client@~6.2.1 (no change)
- ws@~8.2.3 (no change)
```js
engine.io@~6.2.0
```

```js
ws@~8.2.3
```

```js
engine.io-client@~6.2.1
```

```js
ws@~8.2.3
```

# https://socket.io/docs/v4/changelog/4.5.2

# Version 4.5.2

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

September 2, 2022

- 4.5.2 (September 2, 2022)
- prevent the socket from joining a room after disconnection (18f3fda)
- uws: prevent the server from crashing after upgrade (ba497ee)
- engine.io@~6.2.0 (no change)
- ws@~8.2.3 (no change)
- handle ill-formatted packet from server (c597023)
- engine.io-client@~6.2.1 (no change)
- ws@~8.2.3 (no change)
```js
engine.io@~6.2.0
```

```js
ws@~8.2.3
```

```js
engine.io-client@~6.2.1
```

```js
ws@~8.2.3
```

# https://socket.io/docs/v4/changelog/4.5.3

# Version 4.5.3

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

October 15, 2022

- 4.5.3 (October 15, 2022)
- typings: accept an HTTP2 server in the constructor (d3d0a2d)
- typings: apply types to "io.timeout(...).emit()" calls (e357daf)
- engine.io@~6.2.0 (no change)
- ws@~8.2.3 (no change)
- do not swallow user exceptions (2403b88)
- engine.io-client@~6.2.3 (https://github.com/socketio/engine.io-client/compare/6.2.1...6.2.3)
- ws@~8.2.3 (no change)
```js
engine.io@~6.2.0
```

```js
ws@~8.2.3
```

```js
engine.io-client@~6.2.3
```

```js
ws@~8.2.3
```

# https://socket.io/docs/v4/changelog/4.5.4

# Version 4.5.4

## Server​

## Client​

### Dependencies​

### Dependencies​

November 22, 2022

This release contains a bump of:

This release contains a bump of the socket.io-parser dependency, in order to fix CVE-2022-2421.

- 4.5.4 (November 22, 2022)
- engine.io in order to fix CVE-2022-41940
- socket.io-parser in order to fix CVE-2022-2421.
- engine.io@~6.2.1 (https://github.com/socketio/engine.io/compare/6.2.0...6.2.1)
- ws@~8.2.3 (no change)
- engine.io-client@~6.2.3 (no change)
- ws@~8.2.3 (no change)
```js
engine.io
```

```js
socket.io-parser
```

```js
engine.io@~6.2.1
```

```js
ws@~8.2.3
```

```js
socket.io-parser
```

```js
engine.io-client@~6.2.3
```

```js
ws@~8.2.3
```

# https://socket.io/docs/v4/changelog/4.6.0

# Version 4.6.0

## Server​

## Client​

### Bug Fixes​

### Features​

### Performance Improvements​

### Dependencies​

### Bug Fixes​

### Features​

### Dependencies​

February 7, 2023

This commit adds some syntactic sugar around acknowledgements:

Added in 184f3cf.

This feature allows a client to reconnect after a temporary disconnection and restore its state:

Usage:

Here's how it works:

The in-memory adapter already supports this feature, and we will soon update the Postgres and MongoDB adapters. We will also create a new adapter based on Redis Streams, which will support this feature.

Added in 54d5ee0.

This feature implements middlewares at the Engine.IO level, because Socket.IO middlewares are meant for namespace authorization and are not executed during a classic HTTP request/response cycle.

Syntax:

A workaround was possible by using the allowRequest option and the "headers" event, but this feels way cleaner and works with upgrade requests too.

Added in 24786e7.

The disconnect event will now contain additional details about the disconnection reason.

Added in 8aa9499.

This commit adds a new option, "cleanupEmptyChildNamespaces". With this option enabled (disabled by default), when a socket disconnects from a dynamic namespace and if there are no other sockets connected to it then the namespace will be cleaned up and its adapter will be closed.

Added in 5d9220b.

The trailing slash which was added by default can now be disabled:

In the example above, the clients can omit the trailing slash and use /socket.io instead of /socket.io/.

Added in d0fd474.

The trailing slash which was added by default can now be disabled:

In the example above, the request URL will be https://example.com/socket.io instead of https://example.com/socket.io/.

Added in 21a6e12.

This commit adds some syntactic sugar around acknowledgements:

Note: environments that do not support Promises will need to add a polyfill in order to use this feature.

Added in 47b979d.

This feature allows a client to reconnect after a temporary disconnection and restore its ID and receive any packets that was missed during the disconnection gap. It must be enabled on the server side.

A new boolean attribute named recovered is added on the socket object:

Added in 54d5ee0 (server) and b4e20c5 (client).

Two new options are available:

In all examples above, "my-event" will be sent up to 4 times (1 + 3), until the server sends an acknowledgement.

Assigning a unique ID to each packet is the duty of the user, in order to allow deduplication on the server side.

Added in 655dce9.

- 4.6.0 (February 7, 2023)
- add timeout method to remote socket (#4558) (0c0eb00)
- typings: properly type emits with timeout (f3ada7d)
- emitWithAck()
- serverSideEmitWithAck()
- rooms
- data
- missed packets
- the server sends a session ID during the handshake (which is different from the current id attribute, which is public and can be freely shared)
- the server also includes an offset in each packet (added at the end of the data array, for backward compatibility)
- upon temporary disconnection, the server stores the client state for a given delay (implemented at the adapter level)
- upon reconnection, the client sends both the session ID and the last offset it has processed, and the server tries to restore the state
- precompute the WebSocket frames when broadcasting (da2b542)
- engine.io@~6.4.0 (https://github.com/socketio/engine.io/compare/6.2.1...6.4.0)
- ws@~8.11.0 (https://github.com/websockets/ws/compare/8.2.3...8.11.0)
- typings: do not expose browser-specific types (4d6d95e)
- ensure manager.socket() returns an active socket (b7dd891)
- typings: properly type emits with timeout (#1570) (33e4172)
- retries: the maximum number of retries. Above the limit, the packet will be discarded.
- ackTimeout: the default timeout in milliseconds used when waiting for an acknowledgement (not to be mixed up with the already existing timeout option, which is used by the Manager during the connection)
- engine.io-client@~6.4.0 (diff)
- ws@~8.11.0 (diff)
```js
try {  const responses = await io.timeout(1000).emitWithAck("some-event");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}io.on("connection", async (socket) => {    // without timeout  const response = await socket.emitWithAck("hello", "world");  // with a specific timeout  try {    const response = await socket.timeout(1000).emitWithAck("hello", "world");  } catch (err) {    // the client did not acknowledge the event in the given delay  }});
```

```js
try {  const responses = await io.timeout(1000).serverSideEmitWithAck("some-event");  console.log(responses); // one response per server (except itself)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
import { Server } from "socket.io";const io = new Server({  connectionStateRecovery: {    // default values    maxDisconnectionDuration: 2 * 60 * 1000,    skipMiddlewares: true,  },});io.on("connection", (socket) => {  console.log(socket.recovered); // whether the state was recovered or not});
```

```js
io.engine.use((req, res, next) => {  // do something  next();});// with express-sessionimport session from "express-session";io.engine.use(session({  secret: "keyboard cat",  resave: false,  saveUninitialized: true,  cookie: { secure: true }}));// with helmetimport helmet from "helmet";io.engine.use(helmet());
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason, description) => {    console.log(description);  });});
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cleanupEmptyChildNamespaces: true});
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  addTrailingSlash: false});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  addTrailingSlash: false});
```

```js
// without timeoutconst response = await socket.emitWithAck("hello", "world");// with a specific timeouttry {  const response = await socket.timeout(1000).emitWithAck("hello", "world");} catch (err) {  // the server did not acknowledge the event in the given delay}
```

```js
socket.on("connect", () => {  console.log(socket.recovered); // whether the recovery was successful});
```

```js
const socket = io({  retries: 3,  ackTimeout: 10000});// implicit acksocket.emit("my-event");// explicit acksocket.emit("my-event", (err, val) => { /* ... */ });// custom timeout (in that case the ackTimeout is optional)socket.timeout(5000).emit("my-event", (err, val) => { /* ... */ });
```

```js
emitWithAck()
```

```js
try {  const responses = await io.timeout(1000).emitWithAck("some-event");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}io.on("connection", async (socket) => {    // without timeout  const response = await socket.emitWithAck("hello", "world");  // with a specific timeout  try {    const response = await socket.timeout(1000).emitWithAck("hello", "world");  } catch (err) {    // the client did not acknowledge the event in the given delay  }});
```

```js
serverSideEmitWithAck()
```

```js
try {  const responses = await io.timeout(1000).serverSideEmitWithAck("some-event");  console.log(responses); // one response per server (except itself)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
import { Server } from "socket.io";const io = new Server({  connectionStateRecovery: {    // default values    maxDisconnectionDuration: 2 * 60 * 1000,    skipMiddlewares: true,  },});io.on("connection", (socket) => {  console.log(socket.recovered); // whether the state was recovered or not});
```

```js
io.engine.use((req, res, next) => {  // do something  next();});// with express-sessionimport session from "express-session";io.engine.use(session({  secret: "keyboard cat",  resave: false,  saveUninitialized: true,  cookie: { secure: true }}));// with helmetimport helmet from "helmet";io.engine.use(helmet());
```

```js
disconnect
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason, description) => {    console.log(description);  });});
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cleanupEmptyChildNamespaces: true});
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  addTrailingSlash: false});
```

```js
/socket.io
```

```js
/socket.io/
```

```js
engine.io@~6.4.0
```

```js
ws@~8.11.0
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  addTrailingSlash: false});
```

```js
https://example.com/socket.io
```

```js
https://example.com/socket.io/
```

```js
// without timeoutconst response = await socket.emitWithAck("hello", "world");// with a specific timeouttry {  const response = await socket.timeout(1000).emitWithAck("hello", "world");} catch (err) {  // the server did not acknowledge the event in the given delay}
```

```js
recovered
```

```js
socket
```

```js
socket.on("connect", () => {  console.log(socket.recovered); // whether the recovery was successful});
```

```js
retries
```

```js
ackTimeout
```

```js
timeout
```

```js
const socket = io({  retries: 3,  ackTimeout: 10000});// implicit acksocket.emit("my-event");// explicit acksocket.emit("my-event", (err, val) => { /* ... */ });// custom timeout (in that case the ackTimeout is optional)socket.timeout(5000).emit("my-event", (err, val) => { /* ... */ });
```

```js
engine.io-client@~6.4.0
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.6.1

# Version 4.6.1

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

February 20, 2023

- 4.6.1 (February 20, 2023)
- properly handle manually created dynamic namespaces (0d0a7a2)
- types: fix nodenext module resolution compatibility (#4625) (d0b22c6)
- engine.io@~6.4.0 (no change)
- ws@~8.11.0 (no change)
- do not drain the queue while the socket is offline (4996f9e)
- prevent duplicate connections when multiplexing (46213a6)
- engine.io-client@~6.4.0 (no change)
- ws@~8.11.0 (no change)
```js
engine.io@~6.4.0
```

```js
ws@~8.11.0
```

```js
engine.io-client@~6.4.0
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.6.2

# Version 4.6.2

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

May 31, 2023

- 4.6.2 (May 31, 2023)
- exports: move types condition to the top (#4698) (3d44aae)
- engine.io@~6.4.2 (diff)
- ws@~8.11.0 (no change)
- exports: move types condition to the top (#1580) (7ead241)
- engine.io-client@~6.4.0 (no change)
- ws@~8.11.0 (no change)
```js
types
```

```js
engine.io@~6.4.2
```

```js
ws@~8.11.0
```

```js
types
```

```js
engine.io-client@~6.4.0
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.7.0

# Version 4.7.0

## Server​

## Client​

### Bug Fixes​

### Features​

### Dependencies​

### Bug Fixes​

### Features​

### Dependencies​

June 22, 2023

The Socket.IO server can now use WebTransport as the underlying transport.

References:

Until WebTransport support lands in Node.js, you can use the @fails-components/webtransport package:

Added in 123b68c.

The bundles will now have the right Access-Control-Allow-xxx headers.

Added in 63f181c.

The Socket.IO client can now use WebTransport as the underlying transport.

References:

For Node.js clients: until WebTransport support lands in Node.js, you can use the @fails-components/webtransport package:

Added in 7195c0f.

When setting the withCredentials option to true, the Node.js client will now include the cookies in the HTTP requests, making it easier to use it with cookie-based sticky sessions.

Added in 5fc88a6.

By default, the ESM build does not include the debug package in the browser environments, because it increases the bundle size (see 16b6569).

Which means that, unfortunately, debug logs are not available in the devtools console, even when setting the localStorage.debug = ... attribute.

You can now import the build which includes the debug packages with a conditional import. Example with vite:

Reference: https://v2.vitejs.dev/config/#resolve-conditions

Added in 781d753.

- 4.7.0 (June 22, 2023)
- remove the Partial modifier from the socket.data type (#4740) (e5c62ca)
- https://w3c.github.io/webtransport/
- https://developer.chrome.com/articles/webtransport/
- engine.io@~6.5.0 (diff)
- ws@~8.11.0 (no change)
- properly report timeout error when connecting (5bc94b5)
- use same scope for setTimeout and clearTimeout calls (#1568) (f2892ab)
- https://w3c.github.io/webtransport/
- https://developer.chrome.com/articles/webtransport/
- engine.io-client@~6.5.0 (diff)
- ws@~8.11.0 (no change)
```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";import { Http3Server } from "@fails-components/webtransport";// WARNING: the total length of the validity period MUST NOT exceed two weeks (https://w3c.github.io/webtransport/#custom-certificate-requirements)const cert = readFileSync("/path/to/my/cert.pem");const key = readFileSync("/path/to/my/key.pem");const httpsServer = createServer({  key,  cert});httpsServer.listen(3000);const io = new Server(httpsServer, {  transports: ["polling", "websocket", "webtransport"] // WebTransport is not enabled by default});const h3Server = new Http3Server({  port: 3000,  host: "0.0.0.0",  secret: "changeit",  cert,  privKey: key,});(async () => {  const stream = await h3Server.sessionStream("/engine.io/");  const sessionReader = stream.getReader();  while (true) {    const { done, value } = await sessionReader.read();    if (done) {      break;    }    io.engine.onWebTransportSession(value);  }})();h3Server.startServer();
```

```js
import { WebTransport } from "@fails-components/webtransport";global.WebTransport = WebTransport;
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  withCredentials: true});
```

```js
import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'export default defineConfig({  plugins: [react()],  server: {    port: 4000  },  resolve: {    conditions: ["development"]  }})
```

```js
@fails-components/webtransport
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";import { Http3Server } from "@fails-components/webtransport";// WARNING: the total length of the validity period MUST NOT exceed two weeks (https://w3c.github.io/webtransport/#custom-certificate-requirements)const cert = readFileSync("/path/to/my/cert.pem");const key = readFileSync("/path/to/my/key.pem");const httpsServer = createServer({  key,  cert});httpsServer.listen(3000);const io = new Server(httpsServer, {  transports: ["polling", "websocket", "webtransport"] // WebTransport is not enabled by default});const h3Server = new Http3Server({  port: 3000,  host: "0.0.0.0",  secret: "changeit",  cert,  privKey: key,});(async () => {  const stream = await h3Server.sessionStream("/engine.io/");  const sessionReader = stream.getReader();  while (true) {    const { done, value } = await sessionReader.read();    if (done) {      break;    }    io.engine.onWebTransportSession(value);  }})();h3Server.startServer();
```

```js
Access-Control-Allow-xxx
```

```js
engine.io@~6.5.0
```

```js
ws@~8.11.0
```

```js
@fails-components/webtransport
```

```js
import { WebTransport } from "@fails-components/webtransport";global.WebTransport = WebTransport;
```

```js
withCredentials
```

```js
true
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  withCredentials: true});
```

```js
debug
```

```js
localStorage.debug = ...
```

```js
debug
```

```js
import { defineConfig } from 'vite'import react from '@vitejs/plugin-react'export default defineConfig({  plugins: [react()],  server: {    port: 4000  },  resolve: {    conditions: ["development"]  }})
```

```js
engine.io-client@~6.5.0
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.7.1

# Version 4.7.1

## Server​

## Client​

### Dependencies​

### Dependencies​

June 28, 2023

The client bundle contains a few fixes regarding the WebTransport support.

Some bug fixes are included from the engine.io-client package:

- 4.7.1 (June 28, 2023)
- engine.io@~6.5.0 (no change)
- ws@~8.11.0 (no change)
- make closeOnBeforeunload default to false (a63066b)
- webtransport: properly handle abruptly closed connections (cf6aa1f)
- engine.io-client@~6.5.1 (diff)
- ws@~8.11.0 (no change)
```js
engine.io@~6.5.0
```

```js
ws@~8.11.0
```

```js
engine.io-client
```

```js
engine.io-client@~6.5.1
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.7.2

# Version 4.7.2

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

August 2, 2023

Some bug fixes are included from the engine.io-client package:

- 4.7.2 (August 2, 2023)
- clean up child namespace when client is rejected in middleware (#4773) (0731c0d)
- webtransport: properly handle WebTransport-only connections (3468a19)
- webtransport: add proper framing (a306db0)
- engine.io@~6.5.2 (diff)
- ws@~8.11.0 (no change)
- webtransport: add proper framing (d55c39e)
- webtransport: honor the binaryType attribute (8270e00)
- engine.io-client@~6.5.2 (diff)
- ws@~8.11.0 (no change)
```js
engine.io@~6.5.2
```

```js
ws@~8.11.0
```

```js
engine.io-client
```

```js
engine.io-client@~6.5.2
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.7.3

# Version 4.7.3

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

January 3, 2024

- 4.7.3 (January 3, 2024)
- return the first response when broadcasting to a single socket (#4878) (df8e70f)
- typings: allow to bind to a non-secure Http2Server (#4853) (8c9ebc3)
- engine.io@~6.5.2 (no change)
- ws@~8.11.0 (no change)
- improve compatibility with node16 module resolution (#1595) (605de78)
- typings: accept string | undefined as init argument (5a3eafe)
- typings: fix the type of the socket#id attribute (f9c16f2)
- engine.io-client@~6.5.2 (no change)
- ws@~8.11.0 (no change)
```js
engine.io@~6.5.2
```

```js
ws@~8.11.0
```

```js
engine.io-client@~6.5.2
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.7.4

# Version 4.7.4

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Dependencies​

January 12, 2024

There were some minor bug fixes on the server side, which mandate a client bump.

- 4.7.4 (January 12, 2024)
- typings: calling io.emit with no arguments incorrectly errored (cb6d2e0), closes #4914
- engine.io@~6.5.2 (no change)
- ws@~8.11.0 (no change)
- engine.io-client@~6.5.2 (no change)
- ws@~8.11.0 (no change)
```js
engine.io@~6.5.2
```

```js
ws@~8.11.0
```

```js
engine.io-client@~6.5.2
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.7.5

# Version 4.7.5

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Bug Fixes​

### Dependencies​

March 14, 2024

- 4.7.5 (March 14, 2024)
- close the adapters when the server is closed (bf64870)
- remove duplicate pipeline when serving bundle (e426f3e)
- engine.io@~6.5.2 (no change)
- ws@~8.11.0 (no change)
- discard acknowledgements upon disconnection (34cbfbb)
- engine.io-client@~6.5.2 (no change)
- ws@~8.11.0 (no change)
```js
engine.io@~6.5.2
```

```js
ws@~8.11.0
```

```js
engine.io-client@~6.5.2
```

```js
ws@~8.11.0
```

# https://socket.io/docs/v4/changelog/4.8.0

# Version 4.8.0

## Server​

## Client​

### Bug Fixes​

### Dependencies​

### Features​

### Bug Fixes​

### Dependencies​

September 21, 2024

The transports option now accepts an array of transport implementations:

Here is the list of provided implementations:

Usage:

(1) since v18.0.0
(2) since v21.0.0

Added in f4d898e and b11763b.

When setting the tryAllTransports option to true, if the first transport (usually, HTTP long-polling) fails, then the other transports will be tested too:

This feature is useful in two cases:

The only potential downside is that the connection attempt could take more time in case of failure, as there have been reports of WebSocket connection errors taking several seconds before being detected (that's one reason for using HTTP long-polling first). That's why the option defaults to false for now.

Added in 579b243.

- 4.8.0 (September 21, 2024)
- allow to join a room in a middleware (uws) (b04fa64)
- correctly await async close on adapters (#4971) (e347a3c)
- expose type of default engine (132d05f)
- engine.io@~6.6.0 (diff and diff)
- ws@~8.17.1 (diff)
- when HTTP long-polling is disabled on the server, or if CORS fails
- when WebSocket is tested first (with transports: ["websocket", "polling"])
- accept string | undefined as init argument (bis) (60c757f)
- allow to manually stop the reconnection loop (13c6d2e)
- close the engine upon decoding exception (04c8dd9)
- do not send a packet on an expired connection (#5134) (8adcfbf)
- engine.io-client@~6.6.1 (diff and diff)
- ws@~8.17.1 (diff)
```js
import { io } from "socket.io-client";import { Fetch, WebSocket } from "engine.io-client";const socket = io({  transports: [Fetch, WebSocket]});
```

```js
import { io } from "socket.io-client";const socket = io({  tryAllTransports: true});
```

```js
engine.io@~6.6.0
```

```js
ws@~8.17.1
```

```js
transports
```

```js
import { io } from "socket.io-client";import { Fetch, WebSocket } from "engine.io-client";const socket = io({  transports: [Fetch, WebSocket]});
```

```js
Fetch
```

```js
fetch()
```

```js
NodeXHR
```

```js
XMLHttpRequest
```

```js
xmlhttprequest-ssl
```

```js
XHR
```

```js
XMLHttpRequest
```

```js
NodeWebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebTransport
```

```js
WebTransport
```

```js
Fetch
```

```js
NodeXHR
```

```js
XHR
```

```js
NodeWebSocket
```

```js
WebSocket
```

```js
WebTransport
```

```js
tryAllTransports
```

```js
true
```

```js
import { io } from "socket.io-client";const socket = io({  tryAllTransports: true});
```

```js
transports: ["websocket", "polling"]
```

```js
false
```

```js
engine.io-client@~6.6.1
```

```js
ws@~8.17.1
```

# https://socket.io/docs/v4/changelog/4.8.1

# Version 4.8.1

## Server​

## Client​

### Dependencies​

### Bug Fixes​

### Dependencies​

October 25, 2024

Due to a change in the bundler configuration, the production bundle (socket.io.min.js) did not support sending and receiving binary data in version 4.8.0. This is now fixed.

- 4.8.1 (October 25, 2024)
- engine.io@~6.6.0 (no change)
- ws@~8.17.1 (no change)
- bundle: do not mangle the "_placeholder" attribute (ca9e994)
- engine.io-client@~6.6.1 (no change)
- ws@~8.17.1 (no change)
```js
socket.io.min.js
```

```js
4.8.0
```

```js
engine.io@~6.6.0
```

```js
ws@~8.17.1
```

```js
engine.io-client@~6.6.1
```

```js
ws@~8.17.1
```

# https://socket.io/docs/v4/client-api

## IO​

## Manager​

## Socket​

### io.protocol​

### io([url][, options])​

### Constructor​

### Events​

### Methods​

### Events​

### Attributes​

### Methods​

### Flags​

The io method is bound to the global scope in the standalone build:

An ESM bundle is also available since version 4.3.0:

With an import map:

Else, in all other cases (with some build tools, in Node.js or React Native), it can be imported from the socket.io-client package:

The protocol revision number (currently: 5).

The protocol defines the format of the packets exchanged between the client and the server. Both the client and the server must use the same revision in order to understand each other.

You can find more information here.

Creates a new Manager for the given URL, and attempts to reuse an existing Manager for subsequent calls, unless the multiplex option is passed with false. Passing this option is the equivalent of passing "force new connection": true or forceNew: true.

A new Socket instance is returned for the namespace specified by the pathname in the URL, defaulting to /. For example, if the url is http://localhost/users, a transport connection will be established to http://localhost and a Socket.IO connection will be established to /users.

Query parameters can also be provided, either with the query option or directly in the url (example: http://localhost/users?token=abc).

To understand what happens under the hood, the following example:

is the short version of:

The complete list of available options can be found here.

The Manager manages the Engine.IO client instance, which is the low-level engine that establishes the connection to the server (by using transports like WebSocket or HTTP long-polling).

The Manager handles the reconnection logic.

A single Manager can be used by several Sockets. You can find more information about this multiplexing feature here.

Please note that, in most cases, you won't use the Manager directly but use the Socket instance instead.

The complete list of available options can be found here.

Fired upon a connection error.

Fired when a ping packet is received from the server.

Fired upon a successful reconnection.

Fired upon an attempt to reconnect.

Fired upon a reconnection attempt error.

Fired when couldn't reconnect within reconnectionAttempts.

Synonym of manager.open([callback]).

If the manager was initiated with autoConnect to false, launch a new connection attempt.

The callback argument is optional and will be called once the attempt fails/succeeds.

Sets the reconnection option, or returns it if no parameters are passed.

Sets the reconnectionAttempts option, or returns it if no parameters are passed.

Sets the reconnectionDelay option, or returns it if no parameters are passed.

Sets the reconnectionDelayMax option, or returns it if no parameters are passed.

Creates a new Socket for the given namespace. Only auth ({ auth: {key: "value"} }) is read from the options object. Other keys will be ignored and should be passed when instancing a new Manager(nsp, options).

Sets the timeout option, or returns it if no parameters are passed.

A Socket is the fundamental class for interacting with the server. A Socket belongs to a certain Namespace (by default /) and uses an underlying Manager to communicate.

A Socket is basically an EventEmitter which sends events to — and receive events from — the server over the network.

More information can be found here.

This event is fired by the Socket instance upon connection and reconnection.

Event handlers shouldn't be registered in the connect handler itself, as a new handler will be registered every time the socket instance reconnects:

BAD ⚠️

GOOD 👍

This event is fired upon connection failure.

The socket.active attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:

This event is fired upon disconnection.

Here is the list of possible reasons:

The socket.active attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:

Whether the socket will automatically try to reconnect.

This attribute can be used after a connection failure:

Or after a disconnection:

Whether the socket is currently connected to the server.

Whether the socket is currently disconnected from the server.

A unique identifier for the socket session. Set after the connect event is triggered, and updated after the reconnect event.

The id attribute is an ephemeral ID that is not meant to be used in your application (or only for debugging purposes) because:

Please use a regular session ID instead (either sent in a cookie, or stored in the localStorage and sent in the auth payload).

See also:

A reference to the underlying Manager.

Added in v4.6.0

Whether the connection state was successfully recovered during the last reconnection.

More information about this feature here.

Added in v1.0.0

Synonym of socket.disconnect().

Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method.

Added in v1.0.0

Manually connects the socket.

It can also be used to manually reconnect:

Added in v1.0.0

Manually disconnects the socket. In that case, the socket will not try to reconnect.

Associated disconnection reason:

If this is the last active Socket instance of the Manager, the low-level connection will be closed.

Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including Buffer.

The ack argument is optional and will be called with the server answer.

Client

Server

Added in v4.6.0

Promised-based version of emitting and expecting an acknowledgement from the server:

The example above is equivalent to:

And on the receiving side:

Environments that do not support Promises will need to add a polyfill in order to use this feature.

Inherited from the EventEmitter class.

Returns the array of listeners for the event named eventName.

Added in v3.0.0

Returns the list of registered catch-all listeners.

Added in v4.5.0

Returns the list of registered catch-all listeners for outgoing packets.

Inherited from the EventEmitter class.

Removes the specified listener from the listener array for the event named eventName.

The listener argument can also be omitted:

Added in v3.0.0

Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed.

Added in v4.5.0

Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed.

Inherited from the EventEmitter class.

Register a new handler for the given event.

Added in v3.0.0

Register a new catch-all listener.

Acknowledgements are not caught in the catch-all listener.

Added in v4.5.0

Register a new catch-all listener for outgoing packets.

Acknowledgements are not caught in the catch-all listener.

Inherited from the EventEmitter class.

Adds a one-time listener function for the event named eventName. The next time eventName is triggered, this listener is removed and then invoked.

Added in v1.0.0

Synonym of socket.connect().

Added in v3.0.0

Register a new catch-all listener. The listener is added to the beginning of the listeners array.

Added in v4.5.0

Register a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array.

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

Added in v4.4.0

Sets a modifier for a subsequent event emission that the callback will be called with an error when the
given number of milliseconds have elapsed without an acknowledgement from the server:

Added in v3.0.0

Sets a modifier for the subsequent event emission indicating that the packet may be dropped if:

- <number>
- url <string> (defaults to window.location.host)
- options <Object>forceNew <boolean> whether to create a new connection
- forceNew <boolean> whether to create a new connection
- Returns <Socket>
- url <string>
- options <Object>
- Returns <Manager>
- error <Error> error object
- attempt <number> reconnection attempt number
- attempt <number> reconnection attempt number
- error <Error> error object
- callback <Function>
- Returns <Manager>
- value <boolean>
- Returns <Manager> | <boolean>
- value <number>
- Returns <Manager> | <number>
- value <number>
- Returns <Manager> | <number>
- value <number>
- Returns <Manager> | <number>
- nsp <string>
- options <Object>
- Returns <Socket>
- value <number>
- Returns <Manager> | <number>
- error <Error>
- reason <string>
- details <DisconnectDetails>
- <boolean>
- <boolean>
- <boolean>
- <string>
- this ID is regenerated after each reconnection (for example when the WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if the client is disconnected, the messages sent from the server to this ID are lost)
- Part II of our private message guide
- How to deal with cookies
- <Manager>
- <boolean>
- value <boolean>
- Returns <Socket>
- Returns Socket
- Returns <Socket>
- client-side: "io client disconnect"
- server-side: "client namespace disconnect"
- eventName <string> | <symbol>
- args <any[]>
- ack <Function>
- Returns true
- eventName <string> | <symbol>
- args any[]
- Returns Promise<any>
- eventName <string> | <symbol>
- Returns <Function[]>
- Returns <Function[]>
- Returns <Function[]>
- eventName <string> | <symbol>
- listener <Function>
- Returns <Socket>
- listener <Function>
- listener <Function>
- eventName <string> | <symbol>
- listener <Function>
- Returns <Socket>
- callback <Function>
- callback <Function>
- eventName <string> | <symbol>
- listener <Function>
- Returns <Socket>
- callback <Function>
- callback <Function>
- args <any[]>
- ack <Function>
- Returns <Socket>
- value <number>
- Returns <Socket>
- the socket is not connected
- the low-level transport is not writable (for example, when a POST request is already running in HTTP long-polling mode)
```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
<script type="module">  import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";  const socket = io();</script>
```

```js
<script type="importmap">  {    "imports": {      "socket.io-client": "https://cdn.socket.io/4.8.1/socket.io.esm.min.js"    }  }</script><script type="module">  import { io } from "socket.io-client";  const socket = io();</script>
```

```js
// ES modulesimport { io } from "socket.io-client";// CommonJSconst { io } = require("socket.io-client");
```

```js
import { io } from "socket.io-client";const socket = io("ws://example.com/my-namespace", {  reconnectionDelayMax: 10000,  auth: {    token: "123"  },  query: {    "my-key": "my-value"  }});
```

```js
import { Manager } from "socket.io-client";const manager = new Manager("ws://example.com", {  reconnectionDelayMax: 10000,  query: {    "my-key": "my-value"  }});const socket = manager.socket("/my-namespace", {  auth: {    token: "123"  }});
```

```js
import { Manager } from "socket.io-client";const manager = new Manager("https://example.com");const socket = manager.socket("/"); // main namespaceconst adminSocket = manager.socket("/admin"); // admin namespace
```

```js
socket.io.on("error", (error) => {  // ...});
```

```js
socket.io.on("ping", () => {  // ...});
```

```js
socket.io.on("reconnect", (attempt) => {  // ...});
```

```js
socket.io.on("reconnect_attempt", (attempt) => {  // ...});
```

```js
socket.io.on("reconnect_error", (error) => {  // ...});
```

```js
socket.io.on("reconnect_failed", () => {  // ...});
```

```js
import { Manager } from "socket.io-client";const manager = new Manager("https://example.com", {  autoConnect: false});const socket = manager.socket("/");manager.open((err) => {  if (err) {    // an error has occurred  } else {    // the connection was successfully established  }});
```

```js
socket.emit("hello", { a: "b", c: [] });socket.on("hey", (...args) => {  // ...});
```

```js
socket.on("connect", () => {  // ...});
```

```js
socket.on("connect", () => {  socket.on("data", () => { /* ... */ });});
```

```js
socket.on("connect", () => {  // ...});socket.on("data", () => { /* ... */ });
```

```js
socket.on("connect_error", (error) => {  if (socket.active) {    // temporary failure, the socket will automatically try to reconnect  } else {    // the connection was denied by the server    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(error.message);  }});
```

```js
socket.on("disconnect", (reason, details) => {  // ...});
```

```js
socket.on("disconnect", (reason) => {  if (socket.active) {    // temporary disconnection, the socket will automatically try to reconnect  } else {    // the connection was forcefully closed by the server or the client itself    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(reason);  }});
```

```js
socket.on("connect_error", (error) => {  if (socket.active) {    // temporary failure, the socket will automatically try to reconnect  } else {    // the connection was denied by the server    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(error.message);  }});
```

```js
socket.on("disconnect", (reason) => {  if (socket.active) {    // temporary disconnection, the socket will automatically try to reconnect  } else {    // the connection was forcefully closed by the server or the client itself    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(reason);  }});
```

```js
const socket = io();console.log(socket.connected); // falsesocket.on("connect", () => {  console.log(socket.connected); // true});
```

```js
const socket = io();console.log(socket.disconnected); // truesocket.on("connect", () => {  console.log(socket.disconnected); // false});
```

```js
const socket = io();console.log(socket.id); // undefinedsocket.on("connect", () => {  console.log(socket.id); // "G5p5..."});
```

```js
socket.on("connect", () => {  const engine = socket.io.engine;  console.log(engine.transport.name); // in most cases, prints "polling"  engine.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log(engine.transport.name); // in most cases, prints "websocket"  });  engine.on("packet", ({ type, data }) => {    // called for each packet received  });  engine.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  engine.on("drain", () => {    // called when the write buffer is drained  });  engine.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
socket.on("connect", () => {  if (socket.recovered) {    // any event missed during the disconnection period will be received now  } else {    // new or unrecoverable session  }});
```

```js
socket.compress(false).emit("an event", { some: "data" });
```

```js
const socket = io({  autoConnect: false});// ...socket.connect();
```

```js
socket.on("disconnect", () => {  socket.connect();});
```

```js
socket.emit("hello", "world");socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6, 7, 8]) });
```

```js
socket.emit("hello", "world", (response) => {  console.log(response); // "got it"});
```

```js
io.on("connection", (socket) => {  socket.on("hello", (arg, callback) => {    console.log(arg); // "world"    callback("got it");  });});
```

```js
// without timeoutconst response = await socket.emitWithAck("hello", "world");// with a specific timeouttry {  const response = await socket.timeout(10000).emitWithAck("hello", "world");} catch (err) {  // the server did not acknowledge the event in the given delay}
```

```js
// without timeoutsocket.emit("hello", "world", (val) => {  // ...});// with a specific timeoutsocket.timeout(10000).emit("hello", "world", (err, val) => {  // ...});
```

```js
io.on("connection", (socket) => {  socket.on("hello", (arg1, callback) => {    callback("got it"); // only one argument is expected  });});
```

```js
socket.on("my-event", () => {  // ...});console.log(socket.listeners("my-event")); // prints [ [Function] ]
```

```js
const listeners = socket.listenersAny();
```

```js
const listeners = socket.listenersAnyOutgoing();
```

```js
const myListener = () => {  // ...}socket.on("my-event", myListener);// then latersocket.off("my-event", myListener);
```

```js
// remove all listeners for that eventsocket.off("my-event");// remove all listeners for all eventssocket.off();
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
const myListener = () => { /* ... */ };socket.onAnyOutgoing(myListener);// remove a single listenersocket.offAnyOutgoing(myListener);// remove all listenerssocket.offAnyOutgoing();
```

```js
socket.on("news", (data) => {  console.log(data);});// with multiple argumentssocket.on("news", (arg1, arg2, arg3, arg4) => {  // ...});// with callbacksocket.on("news", (cb) => {  cb(0);});
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.emit("foo", (value) => {  // ...});socket.onAnyOutgoing(() => {  // triggered when the event is sent});socket.onAny(() => {  // not triggered when the acknowledgement is received});
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.on("foo", (value, callback) => {  callback("OK");});socket.onAny(() => {  // triggered when the event is received});socket.onAnyOutgoing(() => {  // not triggered when the acknowledgement is sent});
```

```js
socket.once("my-event", () => {  // ...});
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.prependAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the server did not acknowledge the event in the given delay  }});
```

```js
socket.volatile.emit(/* ... */); // the server may or may not receive it
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
<script type="module">  import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";  const socket = io();</script>
```

```js
<script type="importmap">  {    "imports": {      "socket.io-client": "https://cdn.socket.io/4.8.1/socket.io.esm.min.js"    }  }</script><script type="module">  import { io } from "socket.io-client";  const socket = io();</script>
```

```js
socket.io-client
```

```js
// ES modulesimport { io } from "socket.io-client";// CommonJSconst { io } = require("socket.io-client");
```

```js
<number>
```

```js
url
```

```js
<string>
```

```js
window.location.host
```

```js
options
```

```js
<Object>
```

```js
forceNew
```

```js
<boolean>
```

```js
<Socket>
```

```js
Manager
```

```js
Manager
```

```js
multiplex
```

```js
false
```

```js
"force new connection": true
```

```js
forceNew: true
```

```js
Socket
```

```js
url
```

```js
http://localhost/users
```

```js
http://localhost
```

```js
/users
```

```js
query
```

```js
http://localhost/users?token=abc
```

```js
import { io } from "socket.io-client";const socket = io("ws://example.com/my-namespace", {  reconnectionDelayMax: 10000,  auth: {    token: "123"  },  query: {    "my-key": "my-value"  }});
```

```js
import { Manager } from "socket.io-client";const manager = new Manager("ws://example.com", {  reconnectionDelayMax: 10000,  query: {    "my-key": "my-value"  }});const socket = manager.socket("/my-namespace", {  auth: {    token: "123"  }});
```

```js
Manager
```

```js
Manager
```

```js
Manager
```

```js
url
```

```js
<string>
```

```js
options
```

```js
<Object>
```

```js
<Manager>
```

```js
import { Manager } from "socket.io-client";const manager = new Manager("https://example.com");const socket = manager.socket("/"); // main namespaceconst adminSocket = manager.socket("/admin"); // admin namespace
```

```js
error
```

```js
<Error>
```

```js
socket.io.on("error", (error) => {  // ...});
```

```js
socket.io.on("ping", () => {  // ...});
```

```js
attempt
```

```js
<number>
```

```js
socket.io.on("reconnect", (attempt) => {  // ...});
```

```js
attempt
```

```js
<number>
```

```js
socket.io.on("reconnect_attempt", (attempt) => {  // ...});
```

```js
error
```

```js
<Error>
```

```js
socket.io.on("reconnect_error", (error) => {  // ...});
```

```js
reconnectionAttempts
```

```js
socket.io.on("reconnect_failed", () => {  // ...});
```

```js
callback
```

```js
<Function>
```

```js
<Manager>
```

```js
autoConnect
```

```js
false
```

```js
callback
```

```js
import { Manager } from "socket.io-client";const manager = new Manager("https://example.com", {  autoConnect: false});const socket = manager.socket("/");manager.open((err) => {  if (err) {    // an error has occurred  } else {    // the connection was successfully established  }});
```

```js
value
```

```js
<boolean>
```

```js
<Manager>
```

```js
<boolean>
```

```js
reconnection
```

```js
value
```

```js
<number>
```

```js
<Manager>
```

```js
<number>
```

```js
reconnectionAttempts
```

```js
value
```

```js
<number>
```

```js
<Manager>
```

```js
<number>
```

```js
reconnectionDelay
```

```js
value
```

```js
<number>
```

```js
<Manager>
```

```js
<number>
```

```js
reconnectionDelayMax
```

```js
nsp
```

```js
<string>
```

```js
options
```

```js
<Object>
```

```js
<Socket>
```

```js
Socket
```

```js
auth
```

```js
{ auth: {key: "value"} }
```

```js
options
```

```js
new Manager(nsp, options)
```

```js
value
```

```js
<number>
```

```js
<Manager>
```

```js
<number>
```

```js
timeout
```

```js
Socket
```

```js
Socket
```

```js
Socket
```

```js
socket.emit("hello", { a: "b", c: [] });socket.on("hey", (...args) => {  // ...});
```

```js
socket.on("connect", () => {  // ...});
```

```js
connect
```

```js
socket.on("connect", () => {  socket.on("data", () => { /* ... */ });});
```

```js
socket.on("connect", () => {  // ...});socket.on("data", () => { /* ... */ });
```

```js
error
```

```js
<Error>
```

```js
socket.active
```

```js
socket.on("connect_error", (error) => {  if (socket.active) {    // temporary failure, the socket will automatically try to reconnect  } else {    // the connection was denied by the server    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(error.message);  }});
```

```js
reason
```

```js
<string>
```

```js
details
```

```js
<DisconnectDetails>
```

```js
socket.on("disconnect", (reason, details) => {  // ...});
```

```js
io server disconnect
```

```js
io client disconnect
```

```js
ping timeout
```

```js
pingInterval + pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
socket.active
```

```js
socket.on("disconnect", (reason) => {  if (socket.active) {    // temporary disconnection, the socket will automatically try to reconnect  } else {    // the connection was forcefully closed by the server or the client itself    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(reason);  }});
```

```js
<boolean>
```

```js
socket.on("connect_error", (error) => {  if (socket.active) {    // temporary failure, the socket will automatically try to reconnect  } else {    // the connection was denied by the server    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(error.message);  }});
```

```js
socket.on("disconnect", (reason) => {  if (socket.active) {    // temporary disconnection, the socket will automatically try to reconnect  } else {    // the connection was forcefully closed by the server or the client itself    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(reason);  }});
```

```js
<boolean>
```

```js
const socket = io();console.log(socket.connected); // falsesocket.on("connect", () => {  console.log(socket.connected); // true});
```

```js
<boolean>
```

```js
const socket = io();console.log(socket.disconnected); // truesocket.on("connect", () => {  console.log(socket.disconnected); // false});
```

```js
<string>
```

```js
connect
```

```js
reconnect
```

```js
const socket = io();console.log(socket.id); // undefinedsocket.on("connect", () => {  console.log(socket.id); // "G5p5..."});
```

```js
auth
```

```js
<Manager>
```

```js
socket.on("connect", () => {  const engine = socket.io.engine;  console.log(engine.transport.name); // in most cases, prints "polling"  engine.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log(engine.transport.name); // in most cases, prints "websocket"  });  engine.on("packet", ({ type, data }) => {    // called for each packet received  });  engine.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  engine.on("drain", () => {    // called when the write buffer is drained  });  engine.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
<boolean>
```

```js
socket.on("connect", () => {  if (socket.recovered) {    // any event missed during the disconnection period will be received now  } else {    // new or unrecoverable session  }});
```

```js
value
```

```js
<boolean>
```

```js
<Socket>
```

```js
true
```

```js
true
```

```js
socket.compress(false).emit("an event", { some: "data" });
```

```js
Socket
```

```js
const socket = io({  autoConnect: false});// ...socket.connect();
```

```js
socket.on("disconnect", () => {  socket.connect();});
```

```js
<Socket>
```

```js
"io client disconnect"
```

```js
"client namespace disconnect"
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
true
```

```js
Buffer
```

```js
socket.emit("hello", "world");socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6, 7, 8]) });
```

```js
ack
```

```js
socket.emit("hello", "world", (response) => {  console.log(response); // "got it"});
```

```js
io.on("connection", (socket) => {  socket.on("hello", (arg, callback) => {    console.log(arg); // "world"    callback("got it");  });});
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
any[]
```

```js
Promise<any>
```

```js
// without timeoutconst response = await socket.emitWithAck("hello", "world");// with a specific timeouttry {  const response = await socket.timeout(10000).emitWithAck("hello", "world");} catch (err) {  // the server did not acknowledge the event in the given delay}
```

```js
// without timeoutsocket.emit("hello", "world", (val) => {  // ...});// with a specific timeoutsocket.timeout(10000).emit("hello", "world", (err, val) => {  // ...});
```

```js
io.on("connection", (socket) => {  socket.on("hello", (arg1, callback) => {    callback("got it"); // only one argument is expected  });});
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
<Function[]>
```

```js
eventName
```

```js
socket.on("my-event", () => {  // ...});console.log(socket.listeners("my-event")); // prints [ [Function] ]
```

```js
<Function[]>
```

```js
const listeners = socket.listenersAny();
```

```js
<Function[]>
```

```js
const listeners = socket.listenersAnyOutgoing();
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
listener
```

```js
<Function>
```

```js
<Socket>
```

```js
listener
```

```js
eventName
```

```js
const myListener = () => {  // ...}socket.on("my-event", myListener);// then latersocket.off("my-event", myListener);
```

```js
listener
```

```js
// remove all listeners for that eventsocket.off("my-event");// remove all listeners for all eventssocket.off();
```

```js
listener
```

```js
<Function>
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
listener
```

```js
<Function>
```

```js
const myListener = () => { /* ... */ };socket.onAnyOutgoing(myListener);// remove a single listenersocket.offAnyOutgoing(myListener);// remove all listenerssocket.offAnyOutgoing();
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
listener
```

```js
<Function>
```

```js
<Socket>
```

```js
socket.on("news", (data) => {  console.log(data);});// with multiple argumentssocket.on("news", (arg1, arg2, arg3, arg4) => {  // ...});// with callbacksocket.on("news", (cb) => {  cb(0);});
```

```js
callback
```

```js
<Function>
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.emit("foo", (value) => {  // ...});socket.onAnyOutgoing(() => {  // triggered when the event is sent});socket.onAny(() => {  // not triggered when the acknowledgement is received});
```

```js
callback
```

```js
<Function>
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.on("foo", (value, callback) => {  callback("OK");});socket.onAny(() => {  // triggered when the event is received});socket.onAnyOutgoing(() => {  // not triggered when the acknowledgement is sent});
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
listener
```

```js
<Function>
```

```js
<Socket>
```

```js
listener
```

```js
eventName
```

```js
eventName
```

```js
socket.once("my-event", () => {  // ...});
```

```js
callback
```

```js
<Function>
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
callback
```

```js
<Function>
```

```js
socket.prependAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
<Socket>
```

```js
message
```

```js
value
```

```js
<number>
```

```js
<Socket>
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the server did not acknowledge the event in the given delay  }});
```

```js
POST
```

```js
socket.volatile.emit(/* ... */); // the server may or may not receive it
```

# https://socket.io/docs/v4/client-initialization

# Client Initialization

## From the same domain​

## From a different domain​

## Custom namespace​

## Options​

Once you have installed the Socket.IO client library, you can now init the client. The complete list of options can be found here.

For TypeScript users, it is possible to provide type hints for the events. Please check this.

In the examples below, the io object comes either from:

If your front is served on the same domain as your server, you can simply use:

The server URL will be deduced from the window.location object.

In case your front is not served from the same domain as your server, you have to pass the URL of your server.

In that case, please make sure to enable Cross-Origin Resource Sharing (CORS) on the server.

You can use either https or wss (respectively, http or ws).

In the examples above, the client will connect to the main namespace. Using only the main namespace should be sufficient for most use cases, but you can specify the namespace with:

You can find more details about namespaces here.

The complete list of available options can be found here.

- Client
- Initialization
- the <script> import
- an ESM import
- NPM
- CommonJS
- ES modules
- TypeScript
```js
<script src="/socket.io/socket.io.js"></script>
```

```js
<script type="module">  import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";</script>
```

```js
const { io } = require("socket.io-client");
```

```js
import { io } from "socket.io-client";
```

```js
import { io } from "socket.io-client";
```

```js
const socket = io();
```

```js
const socket = io("https://server-domain.com");
```

```js
// the following forms are similarconst socket = io("https://server-domain.com");const socket = io("wss://server-domain.com");const socket = io("server-domain.com"); // only in the browser when the page is served over https (will not work in Node.js)
```

```js
// same origin versionconst socket = io("/admin");// cross origin versionconst socket = io("https://server-domain.com/admin");
```

```js
<script>
```

```js
<script src="/socket.io/socket.io.js"></script>
```

```js
<script type="module">  import { io } from "https://cdn.socket.io/4.8.1/socket.io.esm.min.js";</script>
```

```js
const { io } = require("socket.io-client");
```

```js
import { io } from "socket.io-client";
```

```js
import { io } from "socket.io-client";
```

```js
const socket = io();
```

```js
const socket = io("https://server-domain.com");
```

```js
https
```

```js
wss
```

```js
http
```

```js
// the following forms are similarconst socket = io("https://server-domain.com");const socket = io("wss://server-domain.com");const socket = io("server-domain.com"); // only in the browser when the page is served over https (will not work in Node.js)
```

```js
// same origin versionconst socket = io("/admin");// cross origin versionconst socket = io("https://server-domain.com/admin");
```

# https://socket.io/docs/v4/client-installation

# Client Installation

## Version compatibility​

## Browser support​

## Installation​

## Miscellaneous​

### Standalone build​

### From a CDN​

### From NPM​

### Dependency tree​

### Transitive versions​

The latest release is currently 4.8.1, released in October 2024.

You can find the release notes here.

Here is the compatibility table between the server and the JS client:

[1] Yes, with allowEIO3: true

Please check the associated migration guides:

Socket.IO does support IE9 and above. IE 6/7/8 are not supported anymore.

Browser compatibility is tested thanks to the awesome Sauce Labs platform:

By default, the Socket.IO server exposes a client bundle at /socket.io/socket.io.js.

io will be registered as a global variable:

If you don't need this (see other options below), you can disable the functionality on the server side:

You can also include the client bundle from a CDN:

Socket.IO is also available from other CDN:

There are several bundles available:

The debug package allows to print debug information to the console. You can find more information here.

During development, we recommend using the socket.io.js bundle. By setting localStorage.debug = 'socket.io-client:socket', any event received by the client will be printed to the console.

For production, please use the socket.io.min.js bundle, which is an optimized build excluding the debug package.

The Socket.IO client is compatible with bundlers like webpack or browserify.

The client can also be run from Node.js.

Note: for the reasons cited above, you may want to exclude debug from your browser bundle. With webpack, you can use webpack-remove-debug.

Note for TypeScript users: the types are now included in the socket.io-client package and thus the types from @types/socket.io-client are not needed anymore and may in fact cause errors:

A basic installation of the client includes 9 packages, of which 5 are maintained by our team:

The engine.io-client package brings the engine that is responsible for managing the low-level connections (HTTP long-polling or WebSocket).  See also: How it works

- Client
- Installation
- v2 to v3
- v3 to v4
- cdnjs: https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.min.js
- jsDelivr: https://cdn.jsdelivr.net/npm/socket.io-client@4.8.1/dist/socket.io.min.js
- unpkg: https://unpkg.com/socket.io-client@4.8.1/dist/socket.io.min.js
- NPM
- Yarn
- pnpm
- Bun
```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
const { Server } = require("socket.io");const io = new Server({  serveClient: false});
```

```js
<script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+" crossorigin="anonymous"></script>
```

```js
npm install socket.io-client
```

```js
yarn add socket.io-client
```

```js
pnpm add socket.io-client
```

```js
bun add socket.io-client
```

```js
Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
```

```js
└─┬ socket.io-client@4.8.1  ├── @socket.io/component-emitter@3.1.2  ├─┬ debug@4.3.7  │ └── ms@2.1.3  ├─┬ engine.io-client@6.6.3  │ ├── @socket.io/component-emitter@3.1.2 deduped  │ ├── debug@4.3.7 deduped  │ ├── engine.io-parser@5.2.3  │ ├─┬ ws@8.17.1  │ │ ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1  │ │ └── UNMET OPTIONAL DEPENDENCY utf-8-validate@>=5.0.2  │ └── xmlhttprequest-ssl@2.1.2  └─┬ socket.io-parser@4.2.4    ├── @socket.io/component-emitter@3.1.2 deduped    └── debug@4.3.7 deduped
```

```js
4.8.1
```

```js
/socket.io/socket.io.js
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
const { Server } = require("socket.io");const io = new Server({  serveClient: false});
```

```js
<script src="https://cdn.socket.io/4.8.1/socket.io.min.js" integrity="sha384-mkQ3/7FUtcGyoppY6bz/PORYoGqOl7/aSUMn2ymDOJcapfS6PHqxhRTMh1RR0Q6+" crossorigin="anonymous"></script>
```

```js
socket.io.js
```

```js
localStorage.debug = 'socket.io-client:socket'
```

```js
socket.io.min.js
```

```js
npm install socket.io-client
```

```js
yarn add socket.io-client
```

```js
pnpm add socket.io-client
```

```js
bun add socket.io-client
```

```js
socket.io-client
```

```js
@types/socket.io-client
```

```js
Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
```

```js
└─┬ socket.io-client@4.8.1  ├── @socket.io/component-emitter@3.1.2  ├─┬ debug@4.3.7  │ └── ms@2.1.3  ├─┬ engine.io-client@6.6.3  │ ├── @socket.io/component-emitter@3.1.2 deduped  │ ├── debug@4.3.7 deduped  │ ├── engine.io-parser@5.2.3  │ ├─┬ ws@8.17.1  │ │ ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1  │ │ └── UNMET OPTIONAL DEPENDENCY utf-8-validate@>=5.0.2  │ └── xmlhttprequest-ssl@2.1.2  └─┬ socket.io-parser@4.2.4    ├── @socket.io/component-emitter@3.1.2 deduped    └── debug@4.3.7 deduped
```

```js
engine.io-client
```

```js
socket.io-client
```

```js
engine.io-client
```

```js
4.8.x
```

```js
6.6.x
```

```js
8.17.x
```

```js
4.7.x
```

```js
6.5.x
```

```js
8.17.x
```

```js
4.6.x
```

```js
6.4.x
```

```js
8.11.x
```

```js
4.5.x
```

```js
6.2.x
```

```js
8.2.x
```

```js
4.4.x
```

```js
6.1.x
```

```js
8.2.x
```

```js
4.3.x
```

```js
6.0.x
```

```js
8.2.x
```

```js
4.2.x
```

```js
5.2.x
```

```js
7.4.x
```

```js
4.1.x
```

```js
5.1.x
```

```js
7.4.x
```

```js
4.0.x
```

```js
5.0.x
```

```js
7.4.x
```

```js
3.1.x
```

```js
4.1.x
```

```js
7.4.x
```

```js
3.0.x
```

```js
4.0.x
```

```js
7.4.x
```

```js
2.5.x
```

```js
3.5.x
```

```js
7.5.x
```

```js
2.4.x
```

```js
3.5.x
```

```js
7.5.x
```

# https://socket.io/docs/v4/client-offline-behavior

# Offline behavior

## Buffered events​

By default, any event emitted while the Socket is not connected will be buffered until reconnection.

While useful in most cases (when the reconnection delay is short), it could result in a huge spike of events when the connection is restored.

There are several solutions to prevent this behavior, depending on your use case:

- Client
- Offline behavior
- use the connected attribute of the Socket instance
- use volatile events
```js
if (socket.connected) {  socket.emit( /* ... */ );} else {  // ...}
```

```js
socket.volatile.emit( /* ... */ );
```

```js
if (socket.connected) {  socket.emit( /* ... */ );} else {  // ...}
```

```js
socket.volatile.emit( /* ... */ );
```

# https://socket.io/docs/v4/client-options

# Client options

## IO factory options​

## Low-level engine options​

## Manager options​

## Socket options​

### forceNew​

### multiplex​

### addTrailingSlash​

### autoUnref​

### closeOnBeforeunload​

### extraHeaders​

### forceBase64​

### path​

### protocols​

### query​

### rememberUpgrade​

### timestampParam​

### timestampRequests​

### transportOptions​

### transports​

### tryAllTransports​

### upgrade​

### withCredentials​

### Node.js-specific options​

### autoConnect​

### parser​

### randomizationFactor​

### reconnection​

### reconnectionAttempts​

### reconnectionDelay​

### reconnectionDelayMax​

### timeout​

### ackTimeout​

### auth​

### retries​

Default value: false

Whether to create a new Manager instance.

A Manager instance is in charge of the low-level connection to the server (established with HTTP long-polling or WebSocket). It handles the reconnection logic.

A Socket instance is the interface which is used to sends events to — and receive events from — the server. It belongs to a given namespace.

A single Manager can be attached to several Socket instances.

The following example will reuse the same Manager instance for the 3 Socket instances (one single WebSocket connection):

The following example will create 3 different Manager instances (and thus 3 distinct WebSocket connections):

Reusing an existing namespace will also create a new Manager each time:

Default value: true

The opposite of forceNew: whether to reuse an existing Manager instance.

These settings will be shared by all Socket instances attached to the same Manager.

Added in v4.6.0

The trailing slash which was added by default can now be disabled:

In the example above, the request URL will be https://example.com/socket.io instead of https://example.com/socket.io/.

Added in v4.0.0

Default value: false

With autoUnref set to true, the Socket.IO client will allow the program to exit if there is no other active timer/TCP socket in the event system (even if the client is connected):

See also: https://nodejs.org/api/timers.html#timeoutunref

Default value: false

Whether to (silently) close the connection when the beforeunload event is emitted in the browser.

When this option is set to false (the default value), the Socket instance will emit a disconnect event when the user reloads the page on Firefox:

This behavior is specific to Firefox, on other browsers the Socket instance will not emit any disconnect event when the user reloads the page.

When this option is set to true, all browsers will have the same behavior (no disconnect event when reloading the page):

If you use the beforeunload event in your application ("are you sure that you want to leave this page?"), it is recommended to leave this option to false.

Please check this issue for more information.

Default value: -

Additional headers (then found in socket.handshake.headers object on the server-side).

Example:

Client

Server

This will work in Node.js or in React-Native though.

Default value: false

Whether to force base64 encoding for binary content sent over WebSocket (always enabled for HTTP long-polling).

Default value: /socket.io/

It is the name of the path that is captured on the server side.

The server and the client values must match (unless you are using a path-rewriting proxy in between).

Client

Server

Please note that this is different from the path in the URI, which represents the Namespace.

Example:

Added in v2.0.0

Default value: -

Either a single protocol string or an array of protocol strings. These strings are used to indicate sub-protocols, so that a single server can implement multiple WebSocket sub-protocols (for example, you might want one server to be able to handle different types of interactions depending on the specified protocol).

Server:

References:

Default value: -

Additional query parameters (then found in socket.handshake.query object on the server-side).

Example:

Client

Server

The query parameters cannot be updated for the duration of the session, so changing the query on the client-side will only be effective when the current session gets closed and a new one is created:

Note: the following query parameters are reserved and can't be used in your application:

Default value: false

If true and if the previous WebSocket connection to the server succeeded, the connection attempt will bypass the normal upgrade process and will initially try WebSocket. A connection attempt following a transport error will use the normal upgrade process. It is recommended you turn this on only when using SSL/TLS connections, or if you know that your network does not block websockets.

Default value: "t"

The name of the query parameter to use as our timestamp key.

Default value: true

Whether to add the timestamp query param to each request (for cache busting).

Added in v2.0.0

Default value: {}

Transport-specific options.

Example:

Default value: ["polling", "websocket", "webtransport"]

The low-level connection to the Socket.IO server can either be established with:

The following example disables the HTTP long-polling transport:

Note: in that case, sticky sessions are not required on the server side (more information here).

By default, the HTTP long-polling connection is established first, and then an upgrade to WebSocket is attempted (explanation here). You can use WebSocket first with:

One possible downside is that the validity of your CORS configuration will only be checked if the WebSocket connection fails to be established.

You can also pass an array of transport implementations:

Here is the list of provided implementations:

Usage:

(1) since v18.0.0
(2) since v21.0.0

Added in v4.8.0

Default value: false

When setting the tryAllTransports option to true, if the first transport (usually, HTTP long-polling) fails, then the other transports will be tested too:

This feature is useful in two cases:

The only potential downside is that the connection attempt could take more time in case of failure, as there have been reports of WebSocket connection errors taking several seconds before being detected (that's one reason for using HTTP long-polling first). That's why the option defaults to false for now.

Default value: true

Whether the client should try to upgrade the transport from HTTP long-polling to something better.

Default value: false

Whether the cross-site requests should be sent including credentials such as cookies, authorization headers or TLS client certificates. Setting withCredentials has no effect on same-site requests.

The server needs to send the right Access-Control-Allow-*  headers to allow the connection:

You cannot use origin: * when setting withCredentials to true. This will trigger the following error:

Documentation:

Starting with version 4.7.0, when setting the withCredentials option to true, the Node.js client will now include the cookies in the HTTP requests, making it easier to use it with cookie-based sticky sessions.

The following options are supported:

Please refer to the Node.js documentation:

Example with a self-signed certificate:

Client

Server

Example with client-certificate authentication:

Client

Server

rejectUnauthorized is a Node.js-only option, it will not bypass the security check in the browser:

These settings will be shared by all Socket instances attached to the same Manager.

Default value: true

Whether to automatically connect upon creation. If set to false, you need to manually connect:

Added in v2.2.0

Default value: require("socket.io-parser")

The parser used to marshall/unmarshall packets. Please see here for more information.

Default value: 0.5

The randomization factor used when reconnecting (so that the clients do not reconnect at the exact same time after a server crash, for example).

Example with the default values:

Default value: true

Whether reconnection is enabled or not. If set to false, you need to manually reconnect:

Default value: Infinity

The number of reconnection attempts before giving up.

Default value: 1000

The initial delay before reconnection in milliseconds (affected by the randomizationFactor value).

Default value: 5000

The maximum delay between two reconnection attempts. Each attempt increases the reconnection delay by 2x.

Default value: 20000

The timeout in milliseconds for each connection attempt.

These settings are specific to the given Socket instance.

Added in v4.6.0

Default value: -

The default timeout in milliseconds used when waiting for an acknowledgement (not to be mixed up with the already existing timeout option, which is used by the Manager during the connection).

Must be used in conjunction with retries.

Added in v3.0.0

Default value: -

Credentials that are sent when accessing a namespace (see also here).

Example:

Client

Server

You can update the auth map when the access to the Namespace is denied:

Or manually force the Socket instance to reconnect:

Added in v4.6.0

Default value: -

The maximum number of retries. Above the limit, the packet will be discarded.

The event must be acknowledged by the server (even with implicit ack):

Else, the client will keep trying to send the event (up to retries + 1 times).

- Options
- the Socket instance is attached to the "order" Namespace
- the HTTP requests will look like: GET https://example.com/my-custom-path/?EIO=4&transport=polling&t=ML4jUwU
- https://datatracker.ietf.org/doc/html/rfc6455#section-1.9
- EIO: the version of the protocol (currently, "4")
- transport: the transport name ("polling" or "websocket")
- sid: the session ID
- j: if the transport is polling but a JSONP response is required
- t: a hashed-timestamp used for cache-busting
- HTTP long-polling: successive HTTP requests (POST for writing, GET for reading)
- WebSocket
- WebTransport
- when HTTP long-polling is disabled on the server, or if CORS fails
- when WebSocket is tested first (with transports: ["websocket", "polling"])
- XMLHttpRequest.withCredentials
- Handling CORS
- agent
- pfx
- key
- passphrase
- cert
- ciphers
- rejectUnauthorized
- tls.connect(options[, callback])
- tls.createSecureContext([options])
- 1st reconnection attempt happens between 500 and 1500 ms (1000 * 2^0 * (<something between -0.5 and 1.5>))
- 2nd reconnection attempt happens between 1000 and 3000 ms (1000 * 2^1 * (<something between -0.5 and 1.5>))
- 3rd reconnection attempt happens between 2000 and 5000 ms (1000 * 2^2 * (<something between -0.5 and 1.5>))
- next reconnection attempts happen after 5000 ms
```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product"); // the "product" namespaceconst orderSocket = io("https://example.com/order"); // the "order" namespace
```

```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product", { forceNew: true }); // the "product" namespaceconst orderSocket = io("https://example.com/order", { forceNew: true }); // the "order" namespace
```

```js
const socket1 = io(); // 1st managerconst socket2 = io(); // 2nd managerconst socket3 = io("/admin"); // reuse the 1st managerconst socket4 = io("/admin"); // 3rd manager
```

```js
const socket = io(); // 1st managerconst adminSocket = io("/admin", { multiplex: false }); // 2nd manager
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  addTrailingSlash: false});
```

```js
import { io } from "socket.io-client";const socket = io({  autoUnref: true});
```

```js
import { io } from "socket.io-client";const socket = io({  extraHeaders: {    "my-custom-header": "1234"  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.headers); // an object containing "my-custom-header": "1234"});
```

```js
import { io } from "socket.io-client";const socket = io({  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234" // ignored  }});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com/order", {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io({  transports: ["websocket"],  protocols: ["my-protocol-v1"]});
```

```js
io.on("connection", (socket) => {  const transport = socket.conn.transport;  console.log(transport.socket.protocol); // prints "my-protocol-v1"});
```

```js
import { io } from "socket.io-client";const socket = io({  query: {    x: 42  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.query); // prints { x: "42", EIO: "4", transport: "polling" }});
```

```js
socket.io.on("reconnect_attempt", () => {  socket.io.opts.query.x++;});
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/path-for-http-long-polling/",  transportOptions: {    websocket: {      path: "/path-for-websocket/"    }  }});
```

```js
const socket = io("https://example.com", { transports: ["websocket"] });
```

```js
const socket = io("https://example.com", {  transports: ["websocket", "polling"] // use WebSocket first, if available});socket.on("connect_error", () => {  // revert to classic upgrade  socket.io.opts.transports = ["polling", "websocket"];});
```

```js
import { io } from "socket.io-client";import { Fetch, WebSocket } from "engine.io-client";const socket = io({  transports: [Fetch, WebSocket]});
```

```js
import { io } from "socket.io-client";const socket = io({  tryAllTransports: true});
```

```js
import { io } from "socket.io-client";const socket = io("https://my-backend.com", {  withCredentials: true});
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: "https://my-frontend.com",    credentials: true  }});
```

```js
import { readFileSync } from "fs";import { io } from "socket.io-client";const socket = io("https://example.com", {  ca: readFileSync("./cert.pem")});
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpServer = createServer({  cert: readFileSync("./cert.pem"),  key: readFileSync("./key.pem")});const io = new Server(httpServer);
```

```js
import { readFileSync } from "fs";import { io } from "socket.io-client";const socket = io("https://example.com", {  ca: readFileSync("./server-cert.pem"),  cert: readFileSync("./client-cert.pem"),  key: readFileSync("./client-key.pem"),});
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpServer = createServer({  cert: readFileSync("./server-cert.pem"),  key: readFileSync("./server-key.pem"),  requestCert: true,  ca: [    readFileSync("client-cert.pem")  ]});const io = new Server(httpServer);
```

```js
import { io } from "socket.io-client";const socket = io({  autoConnect: false});socket.connect();// orsocket.io.open();
```

```js
import { io } from "socket.io-client";const socket = io({  reconnection: false});const tryReconnect = () => {  setTimeout(() => {    socket.io.open((err) => {      if (err) {        tryReconnect();      }    });  }, 2000);}socket.io.on("close", tryReconnect);
```

```js
import { io } from "socket.io-client";const socket = io({  auth: {    token: "abcd"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({ token: localStorage.token })  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.auth); // prints { token: "abcd" }});
```

```js
socket.on("connect_error", (err) => {  if (err.message === "invalid credentials") {    socket.auth.token = "efgh";    socket.connect();  }});
```

```js
socket.auth.token = "efgh";socket.disconnect().connect();
```

```js
const socket = io({  retries: 3,  ackTimeout: 10000});// implicit acksocket.emit("my-event");// explicit acksocket.emit("my-event", (err, val) => { /* ... */ });// custom timeout (in that case the ackTimeout is optional)socket.timeout(5000).emit("my-event", (err, val) => { /* ... */ });
```

```js
io.on("connection", (socket) => {  socket.on("my-event", (cb) => {    cb("got it");  });});
```

```js
forceNew
```

```js
false
```

```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product"); // the "product" namespaceconst orderSocket = io("https://example.com/order"); // the "order" namespace
```

```js
const socket = io("https://example.com"); // the main namespaceconst productSocket = io("https://example.com/product", { forceNew: true }); // the "product" namespaceconst orderSocket = io("https://example.com/order", { forceNew: true }); // the "order" namespace
```

```js
const socket1 = io(); // 1st managerconst socket2 = io(); // 2nd managerconst socket3 = io("/admin"); // reuse the 1st managerconst socket4 = io("/admin"); // 3rd manager
```

```js
multiplex
```

```js
true
```

```js
forceNew
```

```js
const socket = io(); // 1st managerconst adminSocket = io("/admin", { multiplex: false }); // 2nd manager
```

```js
addTrailingSlash
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  addTrailingSlash: false});
```

```js
https://example.com/socket.io
```

```js
https://example.com/socket.io/
```

```js
autoUnref
```

```js
false
```

```js
autoUnref
```

```js
true
```

```js
import { io } from "socket.io-client";const socket = io({  autoUnref: true});
```

```js
closeOnBeforeunload
```

```js
false
```

```js
false
```

```js
beforeunload
```

```js
false
```

```js
disconnect
```

```js
disconnect
```

```js
true
```

```js
disconnect
```

```js
beforeunload
```

```js
false
```

```js
extraHeaders
```

```js
socket.handshake.headers
```

```js
import { io } from "socket.io-client";const socket = io({  extraHeaders: {    "my-custom-header": "1234"  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.headers); // an object containing "my-custom-header": "1234"});
```

```js
extraHeaders
```

```js
import { io } from "socket.io-client";const socket = io({  transports: ["websocket"],  extraHeaders: {    "my-custom-header": "1234" // ignored  }});
```

```js
forceBase64
```

```js
false
```

```js
path
```

```js
/socket.io/
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com/order", {  path: "/my-custom-path/"});
```

```js
GET https://example.com/my-custom-path/?EIO=4&transport=polling&t=ML4jUwU
```

```js
protocols
```

```js
import { io } from "socket.io-client";const socket = io({  transports: ["websocket"],  protocols: ["my-protocol-v1"]});
```

```js
io.on("connection", (socket) => {  const transport = socket.conn.transport;  console.log(transport.socket.protocol); // prints "my-protocol-v1"});
```

```js
query
```

```js
socket.handshake.query
```

```js
import { io } from "socket.io-client";const socket = io({  query: {    x: 42  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.query); // prints { x: "42", EIO: "4", transport: "polling" }});
```

```js
query
```

```js
socket.io.on("reconnect_attempt", () => {  socket.io.opts.query.x++;});
```

```js
EIO
```

```js
transport
```

```js
sid
```

```js
rememberUpgrade
```

```js
false
```

```js
timestampParam
```

```js
"t"
```

```js
timestampRequests
```

```js
true
```

```js
transportOptions
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/path-for-http-long-polling/",  transportOptions: {    websocket: {      path: "/path-for-websocket/"    }  }});
```

```js
transports
```

```js
webtransport
```

```js
["polling", "websocket", "webtransport"]
```

```js
POST
```

```js
GET
```

```js
const socket = io("https://example.com", { transports: ["websocket"] });
```

```js
const socket = io("https://example.com", {  transports: ["websocket", "polling"] // use WebSocket first, if available});socket.on("connect_error", () => {  // revert to classic upgrade  socket.io.opts.transports = ["polling", "websocket"];});
```

```js
import { io } from "socket.io-client";import { Fetch, WebSocket } from "engine.io-client";const socket = io({  transports: [Fetch, WebSocket]});
```

```js
Fetch
```

```js
fetch()
```

```js
NodeXHR
```

```js
XMLHttpRequest
```

```js
xmlhttprequest-ssl
```

```js
XHR
```

```js
XMLHttpRequest
```

```js
NodeWebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebSocket
```

```js
WebTransport
```

```js
WebTransport
```

```js
Fetch
```

```js
NodeXHR
```

```js
XHR
```

```js
NodeWebSocket
```

```js
WebSocket
```

```js
WebTransport
```

```js
tryAllTransports
```

```js
false
```

```js
tryAllTransports
```

```js
true
```

```js
import { io } from "socket.io-client";const socket = io({  tryAllTransports: true});
```

```js
transports: ["websocket", "polling"]
```

```js
false
```

```js
upgrade
```

```js
true
```

```js
withCredentials
```

```js
withCredentials
```

```js
withCredentials
```

```js
false
```

```js
false
```

```js
withCredentials
```

```js
import { io } from "socket.io-client";const socket = io("https://my-backend.com", {  withCredentials: true});
```

```js
Access-Control-Allow-*
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: "https://my-frontend.com",    credentials: true  }});
```

```js
origin: *
```

```js
withCredentials
```

```js
true
```

```js
4.7.0
```

```js
withCredentials
```

```js
true
```

```js
agent
```

```js
pfx
```

```js
key
```

```js
passphrase
```

```js
cert
```

```js
ciphers
```

```js
rejectUnauthorized
```

```js
import { readFileSync } from "fs";import { io } from "socket.io-client";const socket = io("https://example.com", {  ca: readFileSync("./cert.pem")});
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpServer = createServer({  cert: readFileSync("./cert.pem"),  key: readFileSync("./key.pem")});const io = new Server(httpServer);
```

```js
import { readFileSync } from "fs";import { io } from "socket.io-client";const socket = io("https://example.com", {  ca: readFileSync("./server-cert.pem"),  cert: readFileSync("./client-cert.pem"),  key: readFileSync("./client-key.pem"),});
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpServer = createServer({  cert: readFileSync("./server-cert.pem"),  key: readFileSync("./server-key.pem"),  requestCert: true,  ca: [    readFileSync("client-cert.pem")  ]});const io = new Server(httpServer);
```

```js
rejectUnauthorized
```

```js
autoConnect
```

```js
true
```

```js
false
```

```js
import { io } from "socket.io-client";const socket = io({  autoConnect: false});socket.connect();// orsocket.io.open();
```

```js
parser
```

```js
require("socket.io-parser")
```

```js
randomizationFactor
```

```js
0.5
```

```js
1000 * 2^0 * (<something between -0.5 and 1.5>)
```

```js
1000 * 2^1 * (<something between -0.5 and 1.5>)
```

```js
1000 * 2^2 * (<something between -0.5 and 1.5>)
```

```js
reconnection
```

```js
true
```

```js
false
```

```js
import { io } from "socket.io-client";const socket = io({  reconnection: false});const tryReconnect = () => {  setTimeout(() => {    socket.io.open((err) => {      if (err) {        tryReconnect();      }    });  }, 2000);}socket.io.on("close", tryReconnect);
```

```js
reconnectionAttempts
```

```js
Infinity
```

```js
reconnectionDelay
```

```js
1000
```

```js
reconnectionDelayMax
```

```js
5000
```

```js
timeout
```

```js
20000
```

```js
ackTimeout
```

```js
retries
```

```js
auth
```

```js
import { io } from "socket.io-client";const socket = io({  auth: {    token: "abcd"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({ token: localStorage.token })  }});
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.auth); // prints { token: "abcd" }});
```

```js
auth
```

```js
socket.on("connect_error", (err) => {  if (err.message === "invalid credentials") {    socket.auth.token = "efgh";    socket.connect();  }});
```

```js
socket.auth.token = "efgh";socket.disconnect().connect();
```

```js
retries
```

```js
const socket = io({  retries: 3,  ackTimeout: 10000});// implicit acksocket.emit("my-event");// explicit acksocket.emit("my-event", (err, val) => { /* ... */ });// custom timeout (in that case the ackTimeout is optional)socket.timeout(5000).emit("my-event", (err, val) => { /* ... */ });
```

```js
io.on("connection", (socket) => {  socket.on("my-event", (cb) => {    cb("got it");  });});
```

```js
retries + 1
```

# https://socket.io/docs/v4/client-socket-instance

# The Socket instance (client-side)

## Socket#id​

## Socket#connected​

## Socket#io​

## Lifecycle​

## Events​

### connect​

### connect_error​

### disconnect​

A Socket is the fundamental class for interacting with the server. It inherits most of the methods of the Node.js EventEmitter, like emit, on, once or off.

Besides emitting and listening to events, the Socket instance has a few attributes that may be of use in your application:

Each new connection is assigned a random 20-characters identifier.

This identifier is synced with the value on the server-side.

Please note that, unless connection state recovery is enabled, the id attribute is an ephemeral ID that is not meant to be used in your application (or only for debugging purposes) because:

Please use a regular session ID instead (either sent in a cookie, or stored in the localStorage and sent in the auth payload).

See also:

This attribute describes whether the socket is currently connected to the server.

A reference to the underlying Manager.

The Socket instance emits three special events:

Since Socket.IO v3, the Socket instance does not emit any event related to the reconnection logic anymore. You can listen to the events on the Manager instance directly:

More information can be found in the migration guide.

This event is fired by the Socket instance upon connection and reconnection.

Event handlers shouldn't be registered in the connect handler itself, as a new handler will be registered every time the socket instance reconnects:

BAD ⚠️

GOOD 👍

This event is fired upon connection failure.

The socket.active attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:

This event is fired upon disconnection.

Here is the list of possible reasons:

The socket.active attribute indicates whether the socket will automatically try to reconnect after a small randomized delay:

The following event names are reserved and must not be used in your application:

- Client
- The Socket instance
- this ID is regenerated after each reconnection (for example when the WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if the client is disconnected, the messages sent from the server to this ID are lost)
- Part II of our private message guide
- How to deal with cookies
- connect
- connect_error
- disconnect
- error <Error>
- reason <string>
- details <DisconnectDetails>
- connect
- connect_error
- disconnect
- disconnecting
- newListener
- removeListener
```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});// client-sidesocket.on("connect", () => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});socket.on("disconnect", () => {  console.log(socket.id); // undefined});
```

```js
socket.on("connect", () => {  console.log(socket.connected); // true});socket.on("disconnect", () => {  console.log(socket.connected); // false});
```

```js
socket.on("connect", () => {  const engine = socket.io.engine;  console.log(engine.transport.name); // in most cases, prints "polling"  engine.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log(engine.transport.name); // in most cases, prints "websocket"  });  engine.on("packet", ({ type, data }) => {    // called for each packet received  });  engine.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  engine.on("drain", () => {    // called when the write buffer is drained  });  engine.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
socket.io.on("reconnect_attempt", () => {  // ...});socket.io.on("reconnect", () => {  // ...});
```

```js
socket.on("connect", () => {  // ...});
```

```js
socket.on("connect", () => {  socket.on("data", () => { /* ... */ });});
```

```js
socket.on("connect", () => {  // ...});socket.on("data", () => { /* ... */ });
```

```js
socket.on("connect_error", (error) => {  if (socket.active) {    // temporary failure, the socket will automatically try to reconnect  } else {    // the connection was denied by the server    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(error.message);  }});
```

```js
socket.on("disconnect", (reason, details) => {  // ...});
```

```js
socket.on("disconnect", (reason) => {  if (socket.active) {    // temporary disconnection, the socket will automatically try to reconnect  } else {    // the connection was forcefully closed by the server or the client itself    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(reason);  }});
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
Socket
```

```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});// client-sidesocket.on("connect", () => {  console.log(socket.id); // x8WIv7-mJelg7on_ALbx});socket.on("disconnect", () => {  console.log(socket.id); // undefined});
```

```js
auth
```

```js
socket.on("connect", () => {  console.log(socket.connected); // true});socket.on("disconnect", () => {  console.log(socket.connected); // false});
```

```js
socket.on("connect", () => {  const engine = socket.io.engine;  console.log(engine.transport.name); // in most cases, prints "polling"  engine.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log(engine.transport.name); // in most cases, prints "websocket"  });  engine.on("packet", ({ type, data }) => {    // called for each packet received  });  engine.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  engine.on("drain", () => {    // called when the write buffer is drained  });  engine.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
connect
```

```js
connect_error
```

```js
disconnect
```

```js
socket.io.on("reconnect_attempt", () => {  // ...});socket.io.on("reconnect", () => {  // ...});
```

```js
connect
```

```js
socket.on("connect", () => {  // ...});
```

```js
connect
```

```js
socket.on("connect", () => {  socket.on("data", () => { /* ... */ });});
```

```js
socket.on("connect", () => {  // ...});socket.on("data", () => { /* ... */ });
```

```js
connect_error
```

```js
error
```

```js
<Error>
```

```js
socket.active
```

```js
socket.on("connect_error", (error) => {  if (socket.active) {    // temporary failure, the socket will automatically try to reconnect  } else {    // the connection was denied by the server    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(error.message);  }});
```

```js
disconnect
```

```js
reason
```

```js
<string>
```

```js
details
```

```js
<DisconnectDetails>
```

```js
socket.on("disconnect", (reason, details) => {  // ...});
```

```js
io server disconnect
```

```js
io client disconnect
```

```js
ping timeout
```

```js
pingInterval + pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
socket.active
```

```js
socket.on("disconnect", (reason) => {  if (socket.active) {    // temporary disconnection, the socket will automatically try to reconnect  } else {    // the connection was forcefully closed by the server or the client itself    // in that case, `socket.connect()` must be manually called in order to reconnect    console.log(reason);  }});
```

```js
connect
```

```js
connect_error
```

```js
disconnect
```

```js
disconnecting
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

# https://socket.io/docs/v4/client-with-bundlers

# Client usage with bundlers

## Webpack 5​

## Rollup.js​

### Browser​

### Node.js​

### Browser​

### Node.js​

You will find below the configuration for bundling the client library with different bundlers:

Documentation: https://webpack.js.org/concepts/

Installation:

webpack.config.js

For reference, here is the output of the webpack-bundle-analyzer package:

To use the client in a Node.js environment (server to server connection), here is the configuration:

Installation:

webpack.config.js

Note: without setting target: "node", you will likely encounter the following error:

Documentation: https://rollupjs.org/guide/en/

Installation:

rollup.config.js

Installation:

rollup.config.js

- Client
- Usage with bundlers
- Webpack 5BrowserNode.js
- Browser
- Node.js
- Rollup.jsBrowserNode.js
- Browser
- Node.js
```js
npm i -D socket.io-client webpack webpack-cli babel-loader @babel/core @babel/preset-env \    @babel/plugin-transform-object-assign webpack-remove-debug
```

```js
module.exports = {  entry: "./index.js",  output: {    filename: "bundle.js",  },  mode: "production",  node: false,  module: {    rules: [      {        test: /\.m?js$/,        use: {          loader: "babel-loader",          options: {            presets: ["@babel/preset-env"], // ensure compatibility with older browsers            plugins: ["@babel/plugin-transform-object-assign"], // ensure compatibility with IE 11          },        },      },      {        test: /\.js$/,        loader: "webpack-remove-debug", // remove "debug" package      },    ],  },};
```

```js
npm i -D socket.io-client webpack webpack-cli
```

```js
module.exports = {  entry: "./index.js",  output: {    filename: "bundle.js",  },  mode: "production",  target: "node",  externals: {    bufferutil: "bufferutil",    "utf-8-validate": "utf-8-validate",  },};
```

```js
ReferenceError: document is not defined
```

```js
npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-commonjs \  @rollup/plugin-babel rollup-plugin-uglify babel @babel/core @babel/preset-env
```

```js
import resolve from "@rollup/plugin-node-resolve";import commonjs from "@rollup/plugin-commonjs";import babel from "@rollup/plugin-babel";import { uglify } from "rollup-plugin-uglify";export default {  input: "index.js",  output: {    file: "bundle.js",    format: "cjs",  },  plugins: [    resolve({      browser: true,    }),    commonjs(),    babel({      include: ["**.js", "node_modules/**"],      babelHelpers: "bundled",      presets: ["@babel/preset-env"],    }),    uglify(),  ],};
```

```js
npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs rollup-plugin-uglify
```

```js
import resolve from "@rollup/plugin-node-resolve";import commonjs from "@rollup/plugin-commonjs";import { uglify } from "rollup-plugin-uglify";export default {  input: "index.js",  output: {    file: "bundle.js",    format: "cjs",  },  plugins: [    resolve({      preferBuiltins: true,    }),    commonjs(),    uglify(),  ],};
```

```js
npm i -D socket.io-client webpack webpack-cli babel-loader @babel/core @babel/preset-env \    @babel/plugin-transform-object-assign webpack-remove-debug
```

```js
webpack.config.js
```

```js
module.exports = {  entry: "./index.js",  output: {    filename: "bundle.js",  },  mode: "production",  node: false,  module: {    rules: [      {        test: /\.m?js$/,        use: {          loader: "babel-loader",          options: {            presets: ["@babel/preset-env"], // ensure compatibility with older browsers            plugins: ["@babel/plugin-transform-object-assign"], // ensure compatibility with IE 11          },        },      },      {        test: /\.js$/,        loader: "webpack-remove-debug", // remove "debug" package      },    ],  },};
```

```js
webpack-bundle-analyzer
```

```js
npm i -D socket.io-client webpack webpack-cli
```

```js
webpack.config.js
```

```js
module.exports = {  entry: "./index.js",  output: {    filename: "bundle.js",  },  mode: "production",  target: "node",  externals: {    bufferutil: "bufferutil",    "utf-8-validate": "utf-8-validate",  },};
```

```js
target: "node"
```

```js
ReferenceError: document is not defined
```

```js
npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs @rollup/plugin-commonjs \  @rollup/plugin-babel rollup-plugin-uglify babel @babel/core @babel/preset-env
```

```js
rollup.config.js
```

```js
import resolve from "@rollup/plugin-node-resolve";import commonjs from "@rollup/plugin-commonjs";import babel from "@rollup/plugin-babel";import { uglify } from "rollup-plugin-uglify";export default {  input: "index.js",  output: {    file: "bundle.js",    format: "cjs",  },  plugins: [    resolve({      browser: true,    }),    commonjs(),    babel({      include: ["**.js", "node_modules/**"],      babelHelpers: "bundled",      presets: ["@babel/preset-env"],    }),    uglify(),  ],};
```

```js
npm i -D socket.io-client rollup @rollup/plugin-node-resolve @rollup/plugin-commonjs rollup-plugin-uglify
```

```js
rollup.config.js
```

```js
import resolve from "@rollup/plugin-node-resolve";import commonjs from "@rollup/plugin-commonjs";import { uglify } from "rollup-plugin-uglify";export default {  input: "index.js",  output: {    file: "bundle.js",    format: "cjs",  },  plugins: [    resolve({      preferBuiltins: true,    }),    commonjs(),    uglify(),  ],};
```

# https://socket.io/docs/v4/cluster-adapter

# Cluster adapter

## How it works​

## Supported features​

## Installation​

## Usage​

## Options​

## Latest releases​

### With Node.js cluster​

### With PM2​

### With recluster​

The Cluster adapter allows to use Socket.IO within a Node.js cluster.

Every packet that is sent to multiple clients (e.g. io.to("room1").emit() or socket.broadcast.emit()) is also sent to other workers via the IPC channel.

The source code of this adapter can be found here.

See the associated documentation.

cluster.js

worker.js

Complete changelog

- Adapters
- Cluster adapter
```js
npm install @socket.io/cluster-adapter
```

```js
const cluster = require("cluster");const http = require("http");const { Server } = require("socket.io");const numCPUs = require("os").cpus().length;const { setupMaster, setupWorker } = require("@socket.io/sticky");const { createAdapter, setupPrimary } = require("@socket.io/cluster-adapter");if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  const httpServer = http.createServer();  // setup sticky sessions  setupMaster(httpServer, {    loadBalancingMethod: "least-connection",  });  // setup connections between the workers  setupPrimary();  // needed for packets containing buffers (you can ignore it if you only send plaintext objects)  // Node.js < 16.0.0  cluster.setupMaster({    serialization: "advanced",  });  // Node.js > 16.0.0  // cluster.setupPrimary({  //   serialization: "advanced",  // });  httpServer.listen(3000);  for (let i = 0; i < numCPUs; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });} else {  console.log(`Worker ${process.pid} started`);  const httpServer = http.createServer();  const io = new Server(httpServer);  // use the cluster adapter  io.adapter(createAdapter());  // setup connection with the primary process  setupWorker(io);  io.on("connection", (socket) => {    /* ... */  });}
```

```js
const cluster = require("cluster");const http = require("http");const { setupMaster } = require("@socket.io/sticky");const { setupPrimary } = require("@socket.io/cluster-adapter");const recluster = require("recluster");const path = require("path");const httpServer = http.createServer();// setup sticky sessionssetupMaster(httpServer, {  loadBalancingMethod: "least-connection",});// setup connections between the workerssetupPrimary();// needed for packets containing buffers (you can ignore it if you only send plaintext objects)// Node.js < 16.0.0cluster.setupMaster({  serialization: "advanced",});// Node.js > 16.0.0// cluster.setupPrimary({//   serialization: "advanced",// });httpServer.listen(3000);const balancer = recluster(path.join(__dirname, "worker.js"));balancer.run();
```

```js
const http = require("http");const { Server } = require("socket.io");const { setupWorker } = require("@socket.io/sticky");const { createAdapter } = require("@socket.io/cluster-adapter");const httpServer = http.createServer();const io = new Server(httpServer);// use the cluster adapterio.adapter(createAdapter());// setup connection with the primary processsetupWorker(io);io.on("connection", (socket) => {  /* ... */});
```

```js
io.to("room1").emit()
```

```js
socket.broadcast.emit()
```

```js
socket.io
```

```js
4.0.0
```

```js
0.1.0
```

```js
4.1.0
```

```js
0.1.0
```

```js
4.5.0
```

```js
0.2.0
```

```js
4.6.0
```

```js
npm install @socket.io/cluster-adapter
```

```js
const cluster = require("cluster");const http = require("http");const { Server } = require("socket.io");const numCPUs = require("os").cpus().length;const { setupMaster, setupWorker } = require("@socket.io/sticky");const { createAdapter, setupPrimary } = require("@socket.io/cluster-adapter");if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  const httpServer = http.createServer();  // setup sticky sessions  setupMaster(httpServer, {    loadBalancingMethod: "least-connection",  });  // setup connections between the workers  setupPrimary();  // needed for packets containing buffers (you can ignore it if you only send plaintext objects)  // Node.js < 16.0.0  cluster.setupMaster({    serialization: "advanced",  });  // Node.js > 16.0.0  // cluster.setupPrimary({  //   serialization: "advanced",  // });  httpServer.listen(3000);  for (let i = 0; i < numCPUs; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });} else {  console.log(`Worker ${process.pid} started`);  const httpServer = http.createServer();  const io = new Server(httpServer);  // use the cluster adapter  io.adapter(createAdapter());  // setup connection with the primary process  setupWorker(io);  io.on("connection", (socket) => {    /* ... */  });}
```

```js
recluster
```

```js
cluster.js
```

```js
const cluster = require("cluster");const http = require("http");const { setupMaster } = require("@socket.io/sticky");const { setupPrimary } = require("@socket.io/cluster-adapter");const recluster = require("recluster");const path = require("path");const httpServer = http.createServer();// setup sticky sessionssetupMaster(httpServer, {  loadBalancingMethod: "least-connection",});// setup connections between the workerssetupPrimary();// needed for packets containing buffers (you can ignore it if you only send plaintext objects)// Node.js < 16.0.0cluster.setupMaster({  serialization: "advanced",});// Node.js > 16.0.0// cluster.setupPrimary({//   serialization: "advanced",// });httpServer.listen(3000);const balancer = recluster(path.join(__dirname, "worker.js"));balancer.run();
```

```js
worker.js
```

```js
const http = require("http");const { Server } = require("socket.io");const { setupWorker } = require("@socket.io/sticky");const { createAdapter } = require("@socket.io/cluster-adapter");const httpServer = http.createServer();const io = new Server(httpServer);// use the cluster adapterio.adapter(createAdapter());// setup connection with the primary processsetupWorker(io);io.on("connection", (socket) => {  /* ... */});
```

```js
requestsTimeout
```

```js
fetchSockets()
```

```js
serverSideEmit()
```

```js
5000
```

```js
0.2.2
```

```js
0.2.1...0.2.2
```

```js
0.2.1
```

```js
0.2.0...0.2.1
```

```js
0.2.0
```

```js
0.1.0...0.2.0
```

```js
0.1.0
```

# https://socket.io/docs/v4/connection-state-recovery

# Connection state recovery

## Disclaimer​

## Usage​

## Compatibility with existing adapters​

## How it works under the hood​

Connection state recovery is a feature which allows restoring a client's state after a temporary disconnection, including any missed packets.

This feature was added in version 4.6.0, released in February 2023.

The release notes can be found here.

Under real conditions, a Socket.IO client will inevitably experience temporary disconnections, regardless of the quality of the connection.

This feature will help you cope with such disconnections, but unless you want to store the packets and the sessions forever (by setting maxDisconnectionDuration to Infinity), you can't be assured that the recovery will always be successful.

That's why you will still need to handle the case where the states of the client and the server must be synchronized.

Connection state recovery must be enabled by the server:

Upon an unexpected disconnection (i.e. no manual disconnection with socket.disconnect()), the server will store the id, the rooms and the data attribute of the socket.

Then upon reconnection, the server will try to restore the state of the client. The recovered attribute indicates whether this recovery was successful:

Server

Client

You can check that the recovery is working by forcefully closing the underlying engine:

You can also run this example directly in your browser on:

[1] Persisting the packets is not compatible with the Redis PUB/SUB mechanism.

Example:

Example:

For the recovery to succeed, the server must send at least one event, in order to initialize the offset on the client side.

upon temporary disconnection, the server stores the client state for a given delay (implemented at the adapter level)

upon reconnection, the client sends both the session ID and the last offset it has processed, and the server tries to restore the state

Example:

- Documentation
- Connection state recovery
- CodeSandbox
- StackBlitz
- the server sends a session ID during the handshake (which is different from the current id attribute, which is public and can be freely shared)
- the server also includes an offset in each packet (added at the end of the data array, for backward compatibility)
- upon temporary disconnection, the server stores the client state for a given delay (implemented at the adapter level)
- upon reconnection, the client sends both the session ID and the last offset it has processed, and the server tries to restore the state
```js
const io = new Server(httpServer, {  connectionStateRecovery: {    // the backup duration of the sessions and the packets    maxDisconnectionDuration: 2 * 60 * 1000,    // whether to skip middlewares upon successful recovery    skipMiddlewares: true,  }});
```

```js
io.on("connection", (socket) => {  if (socket.recovered) {    // recovery was successful: socket.id, socket.rooms and socket.data were restored  } else {    // new or unrecoverable session  }});
```

```js
socket.on("connect", () => {  if (socket.recovered) {    // any event missed during the disconnection period will be received now  } else {    // new or unrecoverable session  }});
```

```js
import { io } from "socket.io-client";const socket = io({  reconnectionDelay: 10000, // defaults to 1000  reconnectionDelayMax: 10000 // defaults to 5000});socket.on("connect", () => {  console.log("recovered?", socket.recovered);  setTimeout(() => {    if (socket.io.engine) {      // close the low-level connection and trigger a reconnection      socket.io.engine.close();    }  }, 10000);});
```

```js
40{"sid":"GNpWD7LbGCBNCr8GAAAB","pid":"YHcX2sdAF1z452-HAAAW"}where4         => the Engine.IO message type0         => the Socket.IO CONNECT typeGN...AB   => the public id of the sessionYH...AW   => the private id of the session
```

```js
42["foo","MzUPkW0"]where4         => the Engine.IO message type2         => the Socket.IO EVENT typefoo       => the event name (socket.emit("foo"))MzUPkW0   => the offset
```

```js
40{"pid":"YHcX2sdAF1z452-HAAAW","offset":"MzUPkW0"}where4         => the Engine.IO message type0         => the Socket.IO CONNECT typeYH...AW   => the private id of the sessionMzUPkW0   => the last processed offset
```

```js
4.6.0
```

```js
maxDisconnectionDuration
```

```js
Infinity
```

```js
const io = new Server(httpServer, {  connectionStateRecovery: {    // the backup duration of the sessions and the packets    maxDisconnectionDuration: 2 * 60 * 1000,    // whether to skip middlewares upon successful recovery    skipMiddlewares: true,  }});
```

```js
socket.disconnect()
```

```js
data
```

```js
recovered
```

```js
io.on("connection", (socket) => {  if (socket.recovered) {    // recovery was successful: socket.id, socket.rooms and socket.data were restored  } else {    // new or unrecoverable session  }});
```

```js
socket.on("connect", () => {  if (socket.recovered) {    // any event missed during the disconnection period will be received now  } else {    // new or unrecoverable session  }});
```

```js
import { io } from "socket.io-client";const socket = io({  reconnectionDelay: 10000, // defaults to 1000  reconnectionDelayMax: 10000 // defaults to 5000});socket.on("connect", () => {  console.log("recovered?", socket.recovered);  setTimeout(() => {    if (socket.io.engine) {      // close the low-level connection and trigger a reconnection      socket.io.engine.close();    }  }, 10000);});
```

```js
0.3.0
```

```js
40{"sid":"GNpWD7LbGCBNCr8GAAAB","pid":"YHcX2sdAF1z452-HAAAW"}where4         => the Engine.IO message type0         => the Socket.IO CONNECT typeGN...AB   => the public id of the sessionYH...AW   => the private id of the session
```

```js
42["foo","MzUPkW0"]where4         => the Engine.IO message type2         => the Socket.IO EVENT typefoo       => the event name (socket.emit("foo"))MzUPkW0   => the offset
```

```js
40{"pid":"YHcX2sdAF1z452-HAAAW","offset":"MzUPkW0"}where4         => the Engine.IO message type0         => the Socket.IO CONNECT typeYH...AW   => the private id of the sessionMzUPkW0   => the last processed offset
```

# https://socket.io/docs/v4/custom-parser

# Custom parser

## Available parsers​

## Implementing your own parser​

## The default parser​

## The msgpack parser​

Since Socket.IO v2.0.0, it is now possible to provide your own parser, in order to control the marshalling / unmarshalling of packets.

Server

Client

Besides the default parser, here is the list of available parsers:

Here is a basic example with a parser that uses the JSON.stringify() and JSON.parse() methods:

The source code of the default parser (the socket.io-parser package) can be found here: https://github.com/socketio/socket.io-parser

Example of output:

will be encoded as:

will be encoded as:

Pros:

Cons:

This parser uses the MessagePack serialization format.

The source code of this parser can be found here: https://github.com/socketio/socket.io-msgpack-parser

Sample usage:

Server

Client (Node.js)

In the browser, there is now an official bundle which includes this parser:

In that case, you don't need to specify the parser option.

Pros:

Cons:

Please note that socket.io-msgpack-parser relies on the notepack.io MessagePack implementation. This implementation mainly focuses on performance and minimal bundle size, and thus does not support features like extension types. For a parser based on the official JavaScript implementation, please check this package.

- Advanced
- Custom parser
- basic emit
- emit with binary, acknowledgement and custom namespace
- the binary attachments is then base64-encoded, so this parser is compatible with browsers that do not support Arraybuffers, like IE9
- packets with binary content are sent as two distinct WebSocket frames (if the WebSocket connection is established)
- https://cdn.socket.io/4.8.1/socket.io.msgpack.min.js
- cdnjs: https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.msgpack.min.js
- jsDelivr: https://cdn.jsdelivr.net/npm/socket.io-client@4.8.1/dist/socket.io.msgpack.min.js
- unpkg: https://unpkg.com/socket.io-client@4.8.1/dist/socket.io.msgpack.min.js
- packets with binary content are sent as one single WebSocket frame (if the WebSocket connection is established)
- may result in smaller payloads (especially when using a lot of numbers)
- incompatible with browsers that do not support Arraybuffers, like IE9
- harder to debug in the Network tab of the browser
```js
import { Server } from "socket.io";const io = new Server({  parser: myParser});
```

```js
import { io } from "socket.io-client";const socket = io({  parser: myParser});
```

```js
import { Emitter } from "@socket.io/component-emitter"; // polyfill of Node.js EventEmitter in the browserclass Encoder {  /**   * Encode a packet into a list of strings/buffers   */  encode(packet) {    return [JSON.stringify(packet)];  }}function isObject(value) {  return Object.prototype.toString.call(value) === "[object Object]";}class Decoder extends Emitter {  /**   * Receive a chunk (string or buffer) and optionally emit a "decoded" event with the reconstructed packet   */  add(chunk) {    const packet = JSON.parse(chunk);    if (this.isPacketValid(packet)) {      this.emit("decoded", packet);    } else {      throw new Error("invalid format");    }  }  isPacketValid({ type, data, nsp, id }) {    const isNamespaceValid = typeof nsp === "string";    const isAckIdValid = id === undefined || Number.isInteger(id);    if (!isNamespaceValid || !isAckIdValid) {      return false;    }    switch (type) {      case 0: // CONNECT        return data === undefined || isObject(data);      case 1: // DISCONNECT        return data === undefined;      case 2: // EVENT        return Array.isArray(data) && typeof data[0] === "string";      case 3: // ACK        return Array.isArray(data);      case 4: // CONNECT_ERROR        return isObject(data);      default:        return false;    }  }  /**   * Clean up internal buffers   */  destroy() {}}export const parser = { Encoder, Decoder };
```

```js
socket.emit("test", 42);
```

```js
2["test",42]|||└─ JSON-encoded payload└─ packet type (2 => EVENT)
```

```js
socket.emit("test", Uint8Array.from([42]), () => {  console.log("ack received");});
```

```js
51-/admin,13["test",{"_placeholder":true,"num":0}]||||     || └─ JSON-encoded payload with placeholders for binary attachments||||     |└─ acknowledgement id||||     └─ separator|||└─ namespace (not included when it's the main namespace)||└─ separator|└─ number of binary attachments└─ packet type (5 => BINARY EVENT)and an additional attachment (the extracted Uint8Array)
```

```js
import { Server } from "socket.io";import customParser from "socket.io-msgpack-parser";const io = new Server({  parser: customParser});
```

```js
import { io } from "socket.io-client";import customParser from "socket.io-msgpack-parser";const socket = io("https://example.com", {  parser: customParser});
```

```js
import { Server } from "socket.io";const io = new Server({  parser: myParser});
```

```js
import { io } from "socket.io-client";const socket = io({  parser: myParser});
```

```js
socket.io-circular-parser
```

```js
socket.io-msgpack-parser
```

```js
notepack.io
```

```js
@skgdev/socket.io-msgpack-javascript
```

```js
@msgpack/msgpack
```

```js
socket.io-json-parser
```

```js
JSON.stringify()
```

```js
JSON.parse()
```

```js
socket.io-cbor-x-parser
```

```js
@socket.io/devalue-parser
```

```js
JSON.stringify()
```

```js
JSON.parse()
```

```js
import { Emitter } from "@socket.io/component-emitter"; // polyfill of Node.js EventEmitter in the browserclass Encoder {  /**   * Encode a packet into a list of strings/buffers   */  encode(packet) {    return [JSON.stringify(packet)];  }}function isObject(value) {  return Object.prototype.toString.call(value) === "[object Object]";}class Decoder extends Emitter {  /**   * Receive a chunk (string or buffer) and optionally emit a "decoded" event with the reconstructed packet   */  add(chunk) {    const packet = JSON.parse(chunk);    if (this.isPacketValid(packet)) {      this.emit("decoded", packet);    } else {      throw new Error("invalid format");    }  }  isPacketValid({ type, data, nsp, id }) {    const isNamespaceValid = typeof nsp === "string";    const isAckIdValid = id === undefined || Number.isInteger(id);    if (!isNamespaceValid || !isAckIdValid) {      return false;    }    switch (type) {      case 0: // CONNECT        return data === undefined || isObject(data);      case 1: // DISCONNECT        return data === undefined;      case 2: // EVENT        return Array.isArray(data) && typeof data[0] === "string";      case 3: // ACK        return Array.isArray(data);      case 4: // CONNECT_ERROR        return isObject(data);      default:        return false;    }  }  /**   * Clean up internal buffers   */  destroy() {}}export const parser = { Encoder, Decoder };
```

```js
socket.io-parser
```

```js
socket.emit("test", 42);
```

```js
2["test",42]|||└─ JSON-encoded payload└─ packet type (2 => EVENT)
```

```js
socket.emit("test", Uint8Array.from([42]), () => {  console.log("ack received");});
```

```js
51-/admin,13["test",{"_placeholder":true,"num":0}]||||     || └─ JSON-encoded payload with placeholders for binary attachments||||     |└─ acknowledgement id||||     └─ separator|||└─ namespace (not included when it's the main namespace)||└─ separator|└─ number of binary attachments└─ packet type (5 => BINARY EVENT)and an additional attachment (the extracted Uint8Array)
```

```js
import { Server } from "socket.io";import customParser from "socket.io-msgpack-parser";const io = new Server({  parser: customParser});
```

```js
import { io } from "socket.io-client";import customParser from "socket.io-msgpack-parser";const socket = io("https://example.com", {  parser: customParser});
```

```js
parser
```

```js
socket.io-msgpack-parser
```

```js
notepack.io
```

# https://socket.io/docs/v4/delivery-guarantees

# Delivery guarantees

## Message ordering​

## Message arrival​

### At most once​

### At least once​

Socket.IO does guarantee message ordering, no matter which low-level transport is used (even during an upgrade from HTTP long-polling to WebSocket).

This is achieved thanks to:

Example:

In the example above, the events will always be received in the same order by the other side (provided that they actually arrive, see below).

By default, Socket.IO provides an at most once guarantee of delivery:

As of now, additional delivery guarantees must be implemented in your application.

From the client side, you can achieve an at least once guarantee with the retries option:

The client will try to send the event (up to retries + 1 times), until it gets an acknowledgement from the server.

Even in that case, any pending event will be lost if the user refreshes its tab.

For events sent by the server, additional delivery guarantees can be implemented by:

Example:

Client

Server

Implementing the missing methods (fetchMissedEventsFromDatabase(), generateUniqueId() and persistEventToDatabase()) is database-specific and is left as an exercise for the reader.

References:

- Documentation
- Delivery guarantees
- the guarantees provided by the underlying TCP connection
- the careful design of the upgrade mechanism
- if the connection is broken while an event is being sent, then there is no guarantee that the other side has received it and there will be no retry upon reconnection
- a disconnected client will buffer events until reconnection (though the previous point still applies)
- there is no such buffer on the server, which means that any event that was missed by a disconnected client will not be transmitted to that client upon reconnection
- assigning a unique ID to each event
- persisting the events in a database
- storing the offset of the last received event on the client side, and send it upon reconnection
- socket.auth (client)
- socket.handshake (server)
```js
socket.emit("event1");socket.emit("event2");socket.emit("event3");
```

```js
const socket = io({  retries: 3,  ackTimeout: 10000});
```

```js
const socket = io({  auth: {    offset: undefined  }});socket.on("my-event", ({ id, data }) => {  // do something with the data, and then update the offset  socket.auth.offset = id;});
```

```js
io.on("connection", async (socket) => {  const offset = socket.handshake.auth.offset;  if (offset) {    // this is a reconnection    for (const event of await fetchMissedEventsFromDatabase(offset)) {      socket.emit("my-event", event);    }  } else {    // this is a first connection  }});setInterval(async () => {  const event = {    id: generateUniqueId(),    data: new Date().toISOString()  }  await persistEventToDatabase(event);  io.emit("my-event", event);}, 1000);
```

```js
socket.emit("event1");socket.emit("event2");socket.emit("event3");
```

```js
retries
```

```js
const socket = io({  retries: 3,  ackTimeout: 10000});
```

```js
retries + 1
```

```js
const socket = io({  auth: {    offset: undefined  }});socket.on("my-event", ({ id, data }) => {  // do something with the data, and then update the offset  socket.auth.offset = id;});
```

```js
io.on("connection", async (socket) => {  const offset = socket.handshake.auth.offset;  if (offset) {    // this is a reconnection    for (const event of await fetchMissedEventsFromDatabase(offset)) {      socket.emit("my-event", event);    }  } else {    // this is a first connection  }});setInterval(async () => {  const event = {    id: generateUniqueId(),    data: new Date().toISOString()  }  await persistEventToDatabase(event);  io.emit("my-event", event);}, 1000);
```

```js
fetchMissedEventsFromDatabase()
```

```js
generateUniqueId()
```

```js
persistEventToDatabase()
```

```js
socket.auth
```

```js
socket.handshake
```

# https://socket.io/docs/v4/emit-cheatsheet

# Emit cheatsheet

## Server​

## Client​

### Single client​

### Broadcasting​

### Between servers​

### Basic emit​

### Acknowledgement​

### Acknowledgement and timeout​

The following event names are reserved and must not be used in your application:

The modifiers can absolutely be chained:

This will emit a "hello" event to all connected clients:

And expect an acknowledgement in the next 5 seconds.

Receiving side:

Receiving side:

- connect
- connect_error
- disconnect
- disconnecting
- newListener
- removeListener
- Callback
- Promise
- Callback
- Promise
- Callback
- Promise
- to all connected clients in the room named "my room"
- to all connected clients except the ones in the room named "my room"
- with multiple clauses
- in the namespace named my-namespace
- in at least one of the rooms named room1, room2 and room3, but not in room4
- except the sender
- Callback
- Promise
- Callback
- Promise
- Callback
- Promise
```js
// BAD, will throw an errorsocket.emit("disconnecting");
```

```js
io.on("connection", (socket) => {  socket.emit("hello", 1, "2", { 3: "4", 5: Buffer.from([6]) });});
```

```js
io.on("connection", (socket) => {  socket.emit("hello", "world", (arg1, arg2, arg3) => {    // ...  });});
```

```js
io.on("connection", async (socket) => {  const response = await socket.emitWithAck("hello", "world");});
```

```js
io.on("connection", (socket) => {  socket.timeout(5000).emit("hello", "world", (err, arg1, arg2, arg3) => {    if (err) {      // the client did not acknowledge the event in the given delay    } else {      // ...    }  });});
```

```js
io.on("connection", async (socket) => {  try {    const response = await socket.timeout(5000).emitWithAck("hello", "world");  } catch (e) {    // the client did not acknowledge the event in the given delay  }});
```

```js
io.emit("hello");
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("hello");});
```

```js
io.timeout(5000).emit("hello", "world", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
try {  const responses = await io.timeout(5000).emitWithAck("hello", "world");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}
```

```js
io.to("my room").emit("hello");
```

```js
io.except("my room").emit("hello");
```

```js
io.to("room1").to(["room2", "room3"]).except("room4").emit("hello");
```

```js
io.of("/my-namespace").emit("hello");
```

```js
io.of("/my-namespace").on("connection", (socket) => {  socket    .timeout(5000)    .to("room1")    .to(["room2", "room3"])    .except("room4")    .emit("hello", (err, responses) => {      // ...    });});
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (value) => {  console.log(value); // "world"});
```

```js
io.serverSideEmit("hello", "world", (err, responses) => {  if (err) {    // some servers did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per server (except the current one)  }});
```

```js
try {  const responses = await io.serverSideEmitWithAck("hello", "world");  console.log(responses); // one response per server (except the current one)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
io.on("hello", (value, callback) => {  console.log(value); // "world"  callback("hi");});
```

```js
socket.emit("hello", 1, "2", { 3: "4", 5: Uint8Array.from([6]) });
```

```js
socket.emit("hello", "world", (arg1, arg2, arg3) => {  // ...});
```

```js
const response = await socket.emitWithAck("hello", "world");
```

```js
socket.timeout(5000).emit("hello", "world", (err, arg1, arg2, arg3) => {  if (err) {    // the server did not acknowledge the event in the given delay  } else {    // ...  }});
```

```js
try {  const response = await socket.timeout(5000).emitWithAck("hello", "world");} catch (e) {  // the server did not acknowledge the event in the given delay}
```

```js
connect
```

```js
connect_error
```

```js
disconnect
```

```js
disconnecting
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnecting");
```

```js
io.on("connection", (socket) => {  socket.emit("hello", 1, "2", { 3: "4", 5: Buffer.from([6]) });});
```

```js
io.on("connection", (socket) => {  socket.emit("hello", "world", (arg1, arg2, arg3) => {    // ...  });});
```

```js
io.on("connection", async (socket) => {  const response = await socket.emitWithAck("hello", "world");});
```

```js
io.on("connection", (socket) => {  socket.timeout(5000).emit("hello", "world", (err, arg1, arg2, arg3) => {    if (err) {      // the client did not acknowledge the event in the given delay    } else {      // ...    }  });});
```

```js
io.on("connection", async (socket) => {  try {    const response = await socket.timeout(5000).emitWithAck("hello", "world");  } catch (e) {    // the client did not acknowledge the event in the given delay  }});
```

```js
io.emit("hello");
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("hello");});
```

```js
io.timeout(5000).emit("hello", "world", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
try {  const responses = await io.timeout(5000).emitWithAck("hello", "world");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}
```

```js
io.to("my room").emit("hello");
```

```js
io.except("my room").emit("hello");
```

```js
io.to("room1").to(["room2", "room3"]).except("room4").emit("hello");
```

```js
io.of("/my-namespace").emit("hello");
```

```js
io.of("/my-namespace").on("connection", (socket) => {  socket    .timeout(5000)    .to("room1")    .to(["room2", "room3"])    .except("room4")    .emit("hello", (err, responses) => {      // ...    });});
```

```js
my-namespace
```

```js
room1
```

```js
room2
```

```js
room3
```

```js
room4
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (value) => {  console.log(value); // "world"});
```

```js
io.serverSideEmit("hello", "world", (err, responses) => {  if (err) {    // some servers did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per server (except the current one)  }});
```

```js
try {  const responses = await io.serverSideEmitWithAck("hello", "world");  console.log(responses); // one response per server (except the current one)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
io.on("hello", (value, callback) => {  console.log(value); // "world"  callback("hi");});
```

```js
socket.emit("hello", 1, "2", { 3: "4", 5: Uint8Array.from([6]) });
```

```js
socket.emit("hello", "world", (arg1, arg2, arg3) => {  // ...});
```

```js
const response = await socket.emitWithAck("hello", "world");
```

```js
socket.timeout(5000).emit("hello", "world", (err, arg1, arg2, arg3) => {  if (err) {    // the server did not acknowledge the event in the given delay  } else {    // ...  }});
```

```js
try {  const response = await socket.timeout(5000).emitWithAck("hello", "world");} catch (e) {  // the server did not acknowledge the event in the given delay}
```

# https://socket.io/docs/v4/emitting-events

# Emitting events

## Basic emit​

## Acknowledgements​

## With timeout​

## Volatile events​

There are several ways to send events between the server and the client.

For TypeScript users, it is possible to provide type hints for the events. Please check this.

Server

Client

This also works in the other direction:

Server

Client

You can send any number of arguments, and all serializable data structures are supported, including binary objects like Buffer or TypedArray.

Server

Client

There is no need to run JSON.stringify() on objects as it will be done for you.

Notes:

Date objects will be converted to (and received as) their string representation, e.g. 1970-01-01T00:00:00.000Z

Map and Set must be manually serialized:

Example with a class:

You can add a callback as the last argument of the emit(), and this callback will be called once the other side acknowledges the event:

Server

Client

Starting with Socket.IO v4.4.0, you can now assign a timeout to each emit:

You can also use both a timeout and an acknowledgement:

Volatile events are events that will not be sent if the underlying connection is not ready (a bit like UDP, in terms of reliability).

This can be interesting for example if you need to send the position of the characters in an online game (as only the latest values are useful).

Another use case is to discard events when the client is not connected (by default, the events are buffered until reconnection).

Example:

Server

Client

If you restart the server, you will see in the console:

Without the volatile flag, you would see:

- Events
- Emitting events
- Date objects will be converted to (and received as) their string representation, e.g. 1970-01-01T00:00:00.000Z
- Map and Set must be manually serialized:
- you can use the toJSON() method to customize the serialization of an object
```js
io.on("connection", (socket) => {  socket.emit("hello", "world");});
```

```js
socket.on("hello", (arg) => {  console.log(arg); // world});
```

```js
io.on("connection", (socket) => {  socket.on("hello", (arg) => {    console.log(arg); // world  });});
```

```js
socket.emit("hello", "world");
```

```js
io.on("connection", (socket) => {  socket.emit("hello", 1, "2", { 3: '4', 5: Buffer.from([6]) });});
```

```js
// client-sidesocket.on("hello", (arg1, arg2, arg3) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] }});
```

```js
// BADsocket.emit("hello", JSON.stringify({ name: "John" }));// GOODsocket.emit("hello", { name: "John" });
```

```js
const serializedMap = [...myMap.entries()];const serializedSet = [...mySet.keys()];
```

```js
class Hero {  #hp;  constructor() {    this.#hp = 42;  }  toJSON() {    return { hp: this.#hp };  }}socket.emit("here's a hero", new Hero());
```

```js
io.on("connection", (socket) => {  socket.on("update item", (arg1, arg2, callback) => {    console.log(arg1); // 1    console.log(arg2); // { name: "updated" }    callback({      status: "ok"    });  });});
```

```js
socket.emit("update item", "1", { name: "updated" }, (response) => {  console.log(response.status); // ok});
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the other side did not acknowledge the event in the given delay  }});
```

```js
socket.timeout(5000).emit("my-event", (err, response) => {  if (err) {    // the other side did not acknowledge the event in the given delay  } else {    console.log(response);  }});
```

```js
socket.volatile.emit("hello", "might or might not be received");
```

```js
io.on("connection", (socket) => {  console.log("connect");  socket.on("ping", (count) => {    console.log(count);  });});
```

```js
let count = 0;setInterval(() => {  socket.volatile.emit("ping", ++count);}, 1000);
```

```js
connect1234# the server is restarted, the client automatically reconnectsconnect91011
```

```js
connect1234# the server is restarted, the client automatically reconnects and sends its buffered eventsconnect567891011
```

```js
io.on("connection", (socket) => {  socket.emit("hello", "world");});
```

```js
socket.on("hello", (arg) => {  console.log(arg); // world});
```

```js
io.on("connection", (socket) => {  socket.on("hello", (arg) => {    console.log(arg); // world  });});
```

```js
socket.emit("hello", "world");
```

```js
io.on("connection", (socket) => {  socket.emit("hello", 1, "2", { 3: '4', 5: Buffer.from([6]) });});
```

```js
// client-sidesocket.on("hello", (arg1, arg2, arg3) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] }});
```

```js
JSON.stringify()
```

```js
// BADsocket.emit("hello", JSON.stringify({ name: "John" }));// GOODsocket.emit("hello", { name: "John" });
```

```js
1970-01-01T00:00:00.000Z
```

```js
const serializedMap = [...myMap.entries()];const serializedSet = [...mySet.keys()];
```

```js
toJSON()
```

```js
class Hero {  #hp;  constructor() {    this.#hp = 42;  }  toJSON() {    return { hp: this.#hp };  }}socket.emit("here's a hero", new Hero());
```

```js
emit()
```

```js
io.on("connection", (socket) => {  socket.on("update item", (arg1, arg2, callback) => {    console.log(arg1); // 1    console.log(arg2); // { name: "updated" }    callback({      status: "ok"    });  });});
```

```js
socket.emit("update item", "1", { name: "updated" }, (response) => {  console.log(response.status); // ok});
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the other side did not acknowledge the event in the given delay  }});
```

```js
socket.timeout(5000).emit("my-event", (err, response) => {  if (err) {    // the other side did not acknowledge the event in the given delay  } else {    console.log(response);  }});
```

```js
socket.volatile.emit("hello", "might or might not be received");
```

```js
io.on("connection", (socket) => {  console.log("connect");  socket.on("ping", (count) => {    console.log(count);  });});
```

```js
let count = 0;setInterval(() => {  socket.volatile.emit("ping", ++count);}, 1000);
```

```js
connect1234# the server is restarted, the client automatically reconnectsconnect91011
```

```js
volatile
```

```js
connect1234# the server is restarted, the client automatically reconnects and sends its buffered eventsconnect567891011
```

# https://socket.io/docs/v4/engine-io-protocol

# The Engine.IO protocol

## Introduction​

## Transports​

## Protocol​

## Packet encoding​

## History​

## Test suite​

### HTTP long-polling​

### WebSocket​

### Handshake​

### Heartbeat​

### Upgrade​

### Message​

### HTTP long-polling​

### WebSocket​

### From v2 to v3​

### From v3 to v4​

This document describes the 4th version of the Engine.IO protocol.

The source of this document can be found here.

Table of content

The Engine.IO protocol enables full-duplex and low-overhead communication between a client and a server.

It is based on the WebSocket protocol and uses HTTP long-polling as fallback if the WebSocket connection can't be established.

The reference implementation is written in TypeScript:

The Socket.IO protocol is built on top of these foundations, bringing additional features over the communication channel provided by the Engine.IO protocol.

The connection between an Engine.IO client and an Engine.IO server can be established with:

The HTTP long-polling transport (also simply referred as "polling") consists of successive HTTP requests:

The path of the HTTP requests is /engine.io/ by default.

It might be updated by libraries built on top of the protocol (for example, the Socket.IO protocol uses /socket.io/).

The following query parameters are used:

If a mandatory query parameter is missing, then the server MUST respond with an HTTP 400 error status.

When sending binary data, the sender (client or server) MUST include a Content-Type: application/octet-stream header.

Without an explicit Content-Type header, the receiver SHOULD infer that the data is plaintext.

Reference: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type

To send some packets, a client MUST create an HTTP POST request with the packets encoded in the request body:

The server MUST return an HTTP 400 response if the session ID (from the sid query parameter) is not known.

To indicate success, the server MUST return an HTTP 200 response, with the string ok in the response body.

To ensure packet ordering, a client MUST NOT have more than one active POST request. Should it happen, the server MUST return an HTTP 400 error status and close the session.

To receive some packets, a client MUST create an HTTP GET request:

The server MUST return an HTTP 400 response if the session ID (from the sid query parameter) is not known.

The server MAY not respond right away if there are no packets buffered for the given session. Once there are some packets to be sent, the server SHOULD encode them (see Packet encoding) and send them in the response body of the HTTP request.

To ensure packet ordering, a client MUST NOT have more than one active GET request. Should it happen, the server MUST return an HTTP 400 error status and close the session.

The WebSocket transport consists of a WebSocket connection, which provides a bidirectional and low-latency communication channel between the server and the client.

The following query parameters are used:

If a mandatory query parameter is missing, then the server MUST close the WebSocket connection.

Each packet (read or write) is sent its own WebSocket frame.

A client MUST NOT open more than one WebSocket connection per session. Should it happen, the server MUST close the WebSocket connection.

An Engine.IO packet consists of:

Here is the list of available packet types:

To establish a connection, the client MUST send an HTTP GET request to the server:

If the server accepts the connection, then it MUST respond with an open packet with the following JSON-encoded payload:

Example:

The client MUST send the sid value in the query parameters of all subsequent requests.

Once the handshake is completed, a heartbeat mechanism is started to check the liveness of the connection:

At a given interval (the pingInterval value sent in the handshake) the server sends a ping packet and the client has a few seconds (the pingTimeout value) to send a pong packet back.

If the server does not receive a pong packet back, then it SHOULD consider that the connection is closed.

Conversely, if the client does not receive a ping packet within pingInterval + pingTimeout, then it SHOULD consider that the connection is closed.

By default, the client SHOULD create an HTTP long-polling connection, and then upgrade to better transports if available.

To upgrade to WebSocket, the client MUST:

The server MUST:

Finally, the client MUST send a upgrade packet to complete the upgrade:

Once the handshake is completed, the client and the server can exchange data by including it in a message packet.

The serialization of an Engine.IO packet depends on the type of the payload (plaintext or binary) and on the transport.

Due to the nature of the HTTP long-polling transport, multiple packets might be concatenated in a single payload in order to increase throughput.

Format:

Example:

The packets are separated by the record separator character: \x1e

Binary payloads MUST be base64-encoded and prefixed with a b character:

Example:

The client SHOULD use the maxPayload value sent during the handshake to decide how many packets should be concatenated.

Each Engine.IO packet is sent in its own WebSocket frame.

Format:

Example:

Binary payloads are sent as is, without modification.

The 2nd version of the protocol is used in Socket.IO v0.9 and below.

The 3rd version of the protocol is used in Socket.IO v1 and v2.

The ping packets are now sent by the server, because the timers set in the browsers are not reliable enough. We
suspect that a lot of timeout problems came from timers being delayed on the client-side.

This change allows to treat all payloads (with or without binary) the same way, without having to take in account
whether the client or the current transport supports binary data or not.

Please note that this only applies to HTTP long-polling. Binary data is sent in WebSocket frames with no additional transformation.

Counting characters prevented (or at least makes harder) to implement the protocol in other languages, which may not use
the UTF-16 encoding.

For example, € was encoded to 2:4€, though Buffer.byteLength('€') === 3.

Note: this assumes the record separator is not used in the data.

The 4th version (current) is included in Socket.IO v3 and above.

The test suite in the test-suite/ directory lets you check the compliance of a server implementation.

Usage:

For reference, here is expected configuration for the JavaScript server to pass all tests:

- Miscellaneous
- The Engine.IO protocol
- Introduction
- TransportsHTTP long-pollingRequest pathQuery parametersHeadersSending and receiving dataSending dataReceiving dataWebSocket
- HTTP long-pollingRequest pathQuery parametersHeadersSending and receiving dataSending dataReceiving data
- Request path
- Query parameters
- Headers
- Sending and receiving dataSending dataReceiving data
- Sending data
- Receiving data
- WebSocket
- ProtocolHandshakeHeartbeatUpgradeMessage
- Handshake
- Heartbeat
- Upgrade
- Message
- Packet encodingHTTP long-pollingWebSocket
- HTTP long-polling
- WebSocket
- HistoryFrom v2 to v3From v3 to v4
- From v2 to v3
- From v3 to v4
- Test suite
- server: https://github.com/socketio/engine.io
- client: https://github.com/socketio/engine.io-client
- HTTP long-polling
- WebSocket
- long-running GET requests, for receiving data from the server
- short-running POST requests, for sending data to the server
- a packet type
- an optional packet payload
- HTTP long-polling first (by default)
- WebSocket-only session
- pause the HTTP long-polling transport (no more HTTP request gets sent), to ensure that no packet gets lost
- open a WebSocket connection with the same session ID
- send a ping packet with the string probe in the payload
- send a noop packet to any pending GET request (if applicable) to cleanly close HTTP long-polling transport
- respond with a pong packet with the string probe in the payload
- add support for binary data
- reverse ping/pong mechanism
- always use base64 when encoding a payload with binary data
- use a record separator (\x1e) instead of counting of characters
- in Node.js: npm ci && npm test
- in a browser: simply open the index.html file in your browser
```js
CLIENT                                                 SERVER  │                                                      │  │   POST /engine.io/?EIO=4&transport=polling&sid=...   │  │ ───────────────────────────────────────────────────► │  │ ◄──────────────────────────────────────────────────┘ │  │                        HTTP 200                      │  │                                                      │
```

```js
CLIENT                                                SERVER  │   GET /engine.io/?EIO=4&transport=polling&sid=...   │  │ ──────────────────────────────────────────────────► │  │                                                   . │  │                                                   . │  │                                                   . │  │                                                   . │  │ ◄─────────────────────────────────────────────────┘ │  │                       HTTP 200                      │
```

```js
CLIENT                                                    SERVER  │                                                          │  │        GET /engine.io/?EIO=4&transport=polling           │  │ ───────────────────────────────────────────────────────► │  │ ◄──────────────────────────────────────────────────────┘ │  │                        HTTP 200                          │  │                                                          │
```

```js
CLIENT                                                    SERVER  │                                                          │  │        GET /engine.io/?EIO=4&transport=websocket         │  │ ───────────────────────────────────────────────────────► │  │ ◄──────────────────────────────────────────────────────┘ │  │                        HTTP 101                          │  │                                                          │
```

```js
{  "sid": "lv_VI97HAXpY6yYWAAAC",  "upgrades": ["websocket"],  "pingInterval": 25000,  "pingTimeout": 20000,  "maxPayload": 1000000}
```

```js
CLIENT                                                 SERVER  │                   *** Handshake ***                  │  │                                                      │  │  ◄─────────────────────────────────────────────────  │  │                           2                          │  (ping packet)  │  ─────────────────────────────────────────────────►  │  │                           3                          │  (pong packet)
```

```js
CLIENT                                                 SERVER  │                                                      │  │   GET /engine.io/?EIO=4&transport=websocket&sid=...  │  │ ───────────────────────────────────────────────────► │  │  ◄─────────────────────────────────────────────────┘ │  │            HTTP 101 (WebSocket handshake)            │  │                                                      │  │            -----  WebSocket frames -----             │  │  ─────────────────────────────────────────────────►  │  │                         2probe                       │ (ping packet)  │  ◄─────────────────────────────────────────────────  │  │                         3probe                       │ (pong packet)  │  ─────────────────────────────────────────────────►  │  │                         5                            │ (upgrade packet)  │                                                      │
```

```js
<packet type>[<data>]<separator><packet type>[<data>]<separator><packet type>[<data>][...]
```

```js
4hello\x1e2\x1e4worldwith:4      => message packet typehello  => message payload\x1e   => separator2      => ping packet type\x1e   => separator4      => message packet typeworld  => message payload
```

```js
4hello\x1ebAQIDBA==with:4         => message packet typehello     => message payload\x1e      => separatorb         => binary prefixAQIDBA==  => buffer <01 02 03 04> encoded as base64
```

```js
<packet type>[<data>]
```

```js
4hellowith:4      => message packet typehello  => message payload (UTF-8 encoded)
```

```js
import { listen } from "engine.io";const server = listen(3000, {  pingInterval: 300,  pingTimeout: 200,  maxPayload: 1e6,  cors: {    origin: "*"  }});server.on("connection", socket => {  socket.on("data", (...args) => {    socket.send(...args);  });});
```

```js
GET
```

```js
POST
```

```js
/engine.io/
```

```js
/socket.io/
```

```js
EIO
```

```js
transport
```

```js
polling
```

```js
sid
```

```js
<sid>
```

```js
Content-Type: application/octet-stream
```

```js
Content-Type
```

```js
POST
```

```js
CLIENT                                                 SERVER  │                                                      │  │   POST /engine.io/?EIO=4&transport=polling&sid=...   │  │ ───────────────────────────────────────────────────► │  │ ◄──────────────────────────────────────────────────┘ │  │                        HTTP 200                      │  │                                                      │
```

```js
sid
```

```js
POST
```

```js
GET
```

```js
CLIENT                                                SERVER  │   GET /engine.io/?EIO=4&transport=polling&sid=...   │  │ ──────────────────────────────────────────────────► │  │                                                   . │  │                                                   . │  │                                                   . │  │                                                   . │  │ ◄─────────────────────────────────────────────────┘ │  │                       HTTP 200                      │
```

```js
sid
```

```js
GET
```

```js
EIO
```

```js
transport
```

```js
websocket
```

```js
sid
```

```js
<sid>
```

```js
GET
```

```js
CLIENT                                                    SERVER  │                                                          │  │        GET /engine.io/?EIO=4&transport=polling           │  │ ───────────────────────────────────────────────────────► │  │ ◄──────────────────────────────────────────────────────┘ │  │                        HTTP 200                          │  │                                                          │
```

```js
CLIENT                                                    SERVER  │                                                          │  │        GET /engine.io/?EIO=4&transport=websocket         │  │ ───────────────────────────────────────────────────────► │  │ ◄──────────────────────────────────────────────────────┘ │  │                        HTTP 101                          │  │                                                          │
```

```js
open
```

```js
sid
```

```js
string
```

```js
upgrades
```

```js
string[]
```

```js
pingInterval
```

```js
number
```

```js
pingTimeout
```

```js
number
```

```js
maxPayload
```

```js
number
```

```js
{  "sid": "lv_VI97HAXpY6yYWAAAC",  "upgrades": ["websocket"],  "pingInterval": 25000,  "pingTimeout": 20000,  "maxPayload": 1000000}
```

```js
sid
```

```js
CLIENT                                                 SERVER  │                   *** Handshake ***                  │  │                                                      │  │  ◄─────────────────────────────────────────────────  │  │                           2                          │  (ping packet)  │  ─────────────────────────────────────────────────►  │  │                           3                          │  (pong packet)
```

```js
pingInterval
```

```js
ping
```

```js
pingTimeout
```

```js
pong
```

```js
pong
```

```js
ping
```

```js
pingInterval + pingTimeout
```

```js
ping
```

```js
probe
```

```js
noop
```

```js
GET
```

```js
pong
```

```js
probe
```

```js
upgrade
```

```js
CLIENT                                                 SERVER  │                                                      │  │   GET /engine.io/?EIO=4&transport=websocket&sid=...  │  │ ───────────────────────────────────────────────────► │  │  ◄─────────────────────────────────────────────────┘ │  │            HTTP 101 (WebSocket handshake)            │  │                                                      │  │            -----  WebSocket frames -----             │  │  ─────────────────────────────────────────────────►  │  │                         2probe                       │ (ping packet)  │  ◄─────────────────────────────────────────────────  │  │                         3probe                       │ (pong packet)  │  ─────────────────────────────────────────────────►  │  │                         5                            │ (upgrade packet)  │                                                      │
```

```js
message
```

```js
<packet type>[<data>]<separator><packet type>[<data>]<separator><packet type>[<data>][...]
```

```js
4hello\x1e2\x1e4worldwith:4      => message packet typehello  => message payload\x1e   => separator2      => ping packet type\x1e   => separator4      => message packet typeworld  => message payload
```

```js
\x1e
```

```js
4hello\x1ebAQIDBA==with:4         => message packet typehello     => message payload\x1e      => separatorb         => binary prefixAQIDBA==  => buffer <01 02 03 04> encoded as base64
```

```js
maxPayload
```

```js
<packet type>[<data>]
```

```js
4hellowith:4      => message packet typehello  => message payload (UTF-8 encoded)
```

```js
v0.9
```

```js
\x1e
```

```js
2:4€
```

```js
Buffer.byteLength('€') === 3
```

```js
test-suite/
```

```js
npm ci && npm test
```

```js
index.html
```

```js
import { listen } from "engine.io";const server = listen(3000, {  pingInterval: 300,  pingTimeout: 200,  maxPayload: 1e6,  cors: {    origin: "*"  }});server.on("connection", socket => {  socket.on("data", (...args) => {    socket.send(...args);  });});
```

# https://socket.io/docs/v4/faq

# FAQ

## Something does not work properly, please help?​

## How does it work under the hood?​

## What are the features provided by Socket.IO over plain WebSocket?​

## What is WebTransport?​

## Does Socket.IO store the messages?​

## What are the delivery guarantees of Socket.IO?​

## How to identify a given user?​

## Where can I find the changelog?​

Here is a list of common questions about Socket.IO:

Please check the Troubleshooting guide.

The Socket.IO connection can be established with different low-level transports:

Socket.IO will automatically pick the best available option, depending on:

You can find more detail about that in the "How it works" section.

WebSockets are awesome! No, really. They provide an efficient way for transferring data between a client and a server. Among the advantages:

Which make them perfect for low-latency and data-intensive applications like games, chats, collaborative solutions...

That being said, WebSockets are also pretty low-level and developing a realtime applications with WebSockets often requires an additional layer over them:

As you might have guessed, this additional layer is implemented by the Socket.IO library.

In short, WebTransport is an alternative to WebSocket which fixes several performance issues that plague WebSockets like head-of-line blocking.

Support for WebTransport is not enabled by default in Socket.IO, as it requires a secure context (HTTPS). Please check the dedicated tutorial if you want to play with WebTransport.

The Socket.IO server does not store any message.

It is the duty of your application to persist those messages somewhere for the clients that are not currently connected.

That being said, Socket.IO will store the messages for a brief period of time if you enable the Connection state recovery feature.

Socket.IO does guarantee message ordering, no matter which low-level transport is used (even when switching between two transports).

Moreover, by default Socket.IO provides an at most once guarantee of delivery (also known as "fire and forget"), which means that under certain circumstances a message might get lost and no retry will be attempted.

More information about this here.

There is no concept of user in Socket.IO.

It is the duty of your application to link a given Socket.IO connection to a user account.

For Node.js applications, you can for example:

Please see here.

- Miscellaneous
- FAQ
- Something does not work properly, please help?
- How does it work under the hood?
- What are the features provided by Socket.IO over plain WebSocket?
- What is WebTransport?
- Does Socket.IO store the messages?
- What are the delivery guarantees of Socket.IO?
- How to identify a given user?
- Where can I find the changelog?
- HTTP long-polling
- WebSocket
- WebTransport
- the capabilities of the browser (see here and here)
- the network (some networks block WebSocket and/or WebTransport connections)
- you don't need to rely on periodic polling to fetch data from the server
- you don't need to repeatedly send all the HTTP headers when sending data to the server
- fallback to HTTP long-polling, in case the WebSocket connection can't be established
- automatic reconnection, in case the WebSocket connection gets closed
- acknowledgements, to send some data and expect a response from the other side
- broadcast to all or to a subset of connected clients
- scale up to multiple instances of the server
- connection recovery, for short periods of disconnection
- https://w3c.github.io/webtransport/
- https://developer.chrome.com/articles/webtransport/
- reuse the user context provided by Passport (check this tutorial)
- or use the auth option on the client side to send the user credentials and validate them in a middleware
```js
auth
```

# https://socket.io/docs/v4/gcp-pubsub-adapter

# Google Cloud Pub/Sub adapter

## How it works​

## Supported features​

## Installation​

## Usage​

## Options​

## Latest releases​

This adapter uses Google Cloud Pub/Sub service to forward messages between the nodes of a Socket.IO cluster.

The source code of this adapter can be found here.

Complete changelog

- Adapters
- Google Cloud Pub/Sub adapter
```js
npm install @socket.io/gcp-pubsub-adapter
```

```js
import { PubSub } from "@google-cloud/pubsub";import { Server } from "socket.io";import { createAdapter } from "@socket.io/gcp-pubsub-adapter";const pubsub = new PubSub({  projectId: "your-project-id"});const topic = pubsub.topic(topicNameOrId);const io = new Server({  adapter: createAdapter(topic)});// wait for the creation of the pub/sub subscriptionawait io.of("/").adapter.init();io.listen(3000);
```

```js
socket.io
```

```js
4.0.0
```

```js
0.1.0
```

```js
4.1.0
```

```js
0.1.0
```

```js
4.5.0
```

```js
0.1.0
```

```js
4.6.0
```

```js
npm install @socket.io/gcp-pubsub-adapter
```

```js
import { PubSub } from "@google-cloud/pubsub";import { Server } from "socket.io";import { createAdapter } from "@socket.io/gcp-pubsub-adapter";const pubsub = new PubSub({  projectId: "your-project-id"});const topic = pubsub.topic(topicNameOrId);const io = new Server({  adapter: createAdapter(topic)});// wait for the creation of the pub/sub subscriptionawait io.of("/").adapter.init();io.listen(3000);
```

```js
subscriptionPrefix
```

```js
socket.io
```

```js
subscriptionOptions
```

```js
heartbeatInterval
```

```js
5_000
```

```js
heartbeatTimeout
```

```js
10_000
```

```js
0.1.0
```

# https://socket.io/docs/v4/glossary

# Glossary

## Adapter​

## Engine.IO​

## Namespace​

## Room​

## Transport​

We will list here the terms that are related to the Socket.IO ecosystem:

An Adapter is a server-side component which is responsible for:

Besides the in-memory adapter which is included by default with the Socket.IO server, there are currently 5 official adapters:

The in-memory adapter can be extended to add support for other messaging systems, like RabbitMQ or Google Pub/Sub for example.

Please see the documentation here.

Engine.IO is an internal component of Socket.IO, which is responsible for establishing the low-level connection between the server and the client.

You will find more information here.

A Namespace is a concept that allows splitting the application logic on the server-side.

Please see the documentation here.

A Room is a server-side concept that allows broadcasting data to a subset of clients.

Please see the documentation here.

A Transport represents the low-level way of establishing a connection between the server and the client.

There are currently two implemented transports:

Please see the documentation here.

- Miscellaneous
- Glossary
- Adapter
- Engine.IO
- Namespace
- Room
- Transport
- storing the relationships between the Socket instances and the rooms
- broadcasting events to all (or a subset of) clients
- the Redis adapter
- the Redis Streams adapter
- the MongoDB adapter
- the Postgres adapter
- the Cluster adapter
- HTTP long-polling
- WebSocket
- WebTransport
# https://socket.io/docs/v4/handling-cors

# Handling CORS

## Configuration​

## Troubleshooting​

### CORS header ‘Access-Control-Allow-Origin’ missing​

### Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’​

### Expected ‘true’ in CORS header ‘Access-Control-Allow-Credentials’​

Since Socket.IO v3, you need to explicitly enable Cross-Origin Resource Sharing (CORS).

All options will be forwarded to the cors package. The complete list of options can be found here.

Example with cookies (withCredentials) and additional headers:

Note: this also applies to localhost if your web application and your server are not served from the same port

You can disallow all cross-origin requests with the allowRequest option:

Full error message:

If you have properly configured your server (see above), this could mean that your browser wasn't able to reach the Socket.IO server.

The following command:

should return something like:

If that's not the case, please check that your server is listening and is actually reachable on the given port.

Full error message:

You can't set withCredentials to true with origin: *, you need to use a specific origin:

Full error message:

In that case, withCredentials is set to true on the client, but the server is missing the credentials attribute in the cors option. See the example above.

- Server
- Handling CORS
```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: "https://example.com"  }});
```

```js
// server-sideconst io = new Server(httpServer, {  cors: {    origin: "https://example.com",    allowedHeaders: ["my-custom-header"],    credentials: true  }});// client-sideimport { io } from "socket.io-client";const socket = io("https://api.example.com", {  withCredentials: true,  extraHeaders: {    "my-custom-header": "abcd"  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: "http://localhost:8080"  }});httpServer.listen(3000);
```

```js
const io = new Server(httpServer, {  allowRequest: (req, callback) => {    const noOriginHeader = req.headers.origin === undefined;    callback(null, noOriginHeader); // only allow requests without 'origin' header  }});
```

```js
curl "https://api.example.com/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: "https://my-frontend.com",    // or with an array of origins    // origin: ["https://my-frontend.com", "https://my-other-frontend.com", "http://localhost:3000"],    credentials: true  }});
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: "https://example.com"  }});
```

```js
// server-sideconst io = new Server(httpServer, {  cors: {    origin: "https://example.com",    allowedHeaders: ["my-custom-header"],    credentials: true  }});// client-sideimport { io } from "socket.io-client";const socket = io("https://api.example.com", {  withCredentials: true,  extraHeaders: {    "my-custom-header": "abcd"  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: "http://localhost:8080"  }});httpServer.listen(3000);
```

```js
allowRequest
```

```js
const io = new Server(httpServer, {  allowRequest: (req, callback) => {    const noOriginHeader = req.headers.origin === undefined;    callback(null, noOriginHeader); // only allow requests without 'origin' header  }});
```

```js
curl "https://api.example.com/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}
```

```js
withCredentials
```

```js
true
```

```js
origin: *
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  cors: {    origin: "https://my-frontend.com",    // or with an array of origins    // origin: ["https://my-frontend.com", "https://my-other-frontend.com", "http://localhost:3000"],    credentials: true  }});
```

```js
withCredentials
```

```js
true
```

```js
credentials
```

```js
cors
```

# https://socket.io/docs/v4/how-it-works

# How it works

## Engine.IO​

## Socket.IO​

### Transports​

### Handshake​

### Upgrade mechanism​

### Disconnection detection​

The bidirectional channel between the Socket.IO server (Node.js) and the Socket.IO client (browser, Node.js, or another programming language) is established with a WebSocket connection whenever possible, and will use HTTP long-polling as fallback.

The Socket.IO codebase is split into two distinct layers:

Engine.IO is responsible for establishing the low-level connection between the server and the client. It handles:

A detailed version of the Engine.IO protocol can be found here.

The source code of the reference implementation (written in TypeScript) can be found here:

There are currently two implemented transports:

The HTTP long-polling transport (also simply referred as "polling") consists of successive HTTP requests:

Due to the nature of the transport, successive emits may be concatenated and sent within the same HTTP request.

The WebSocket transport consists, well, of a WebSocket connection, which provides a bidirectional and low-latency communication channel between the server and the client.

Due to the nature of the transport, each emit is sent in its own WebSocket frame (some emits may even result in two distinct WebSocket frames, more information here).

At the beginning of the Engine.IO connection, the server sends some information:

By default, the client establishes the connection with the HTTP long-polling transport.

But, why?

While WebSocket is clearly the best way to establish a bidirectional communication, experience has shown that it is not always possible to establish a WebSocket connection, due to corporate proxies, personal firewall, antivirus software...

From the user perspective, an unsuccessful WebSocket connection can translate in up to 10 seconds of waiting for the realtime application to begin exchanging data. This perceptively hurts user experience.

To summarize, Engine.IO focuses on reliability and user experience first, marginal potential UX improvements and increased server performance second.

To upgrade, the client will:

You can check in the Network Monitor of your browser:

The Engine.IO connection is considered as closed when:

There is also a heartbeat mechanism which checks that the connection between the server and the client is still up and running:

At a given interval (the pingInterval value sent in the handshake) the server sends a PING packet and the client has a few seconds (the pingTimeout value) to send a PONG packet back. If the server does not receive a PONG packet back, it will consider that the connection is closed. Conversely, if the client does not receive a PING packet within pingInterval + pingTimeout, it will consider that the connection is closed.

The disconnection reasons are listed here (server-side) and here (client-side).

Socket.IO provides some additional features over the Engine.IO connection:

A detailed version of the Socket.IO protocol can be found here.

The source code of the reference implementation (written in TypeScript) can be found here:

- Documentation
- How it works
- the low-level plumbing: what we call Engine.IO, the engine inside Socket.IO
- the various transports and the upgrade mechanism
- the disconnection detection
- server: https://github.com/socketio/engine.io
- client: https://github.com/socketio/engine.io-client
- parser: https://github.com/socketio/engine.io-parser
- HTTP long-polling
- WebSocket
- long-running GET requests, for receiving data from the server
- short-running POST requests, for sending data to the server
- the sid is the ID of the session, it must be included in the sid query parameter in all subsequent HTTP requests
- the upgrades array contains the list of all "better" transports that are supported by the server
- the pingInterval and pingTimeout values are used in the heartbeat mechanism
- ensure its outgoing buffer is empty
- put the current transport in read-only mode
- try to establish a connection with the other transport
- if successful, close the first transport
- handshake (contains the session ID — here, zBjrh...AAAK — that is used in subsequent requests)
- send data (HTTP long-polling)
- receive data (HTTP long-polling)
- upgrade (WebSocket)
- receive data (HTTP long-polling, closed once the WebSocket connection in 4. is successfully established)
- one HTTP request (either GET or POST) fails (for example, when the server is shutdown)
- the WebSocket connection is closed (for example, when the user closes the tab in its browser)
- socket.disconnect() is called on the server-side or on the client-side
- automatic reconnection
- packet buffering
- acknowledgments
- broadcasting to all clients or to a subset of clients (what we call "Room")
- multiplexing (what we call "Namespace")
- server: https://github.com/socketio/socket.io
- client: https://github.com/socketio/socket.io-client
- parser: https://github.com/socketio/socket.io-parser
```js
{  "sid": "FSDjX-WRwSA4zTZMALqx",  "upgrades": ["websocket"],  "pingInterval": 25000,  "pingTimeout": 20000}
```

```js
GET
```

```js
POST
```

```js
{  "sid": "FSDjX-WRwSA4zTZMALqx",  "upgrades": ["websocket"],  "pingInterval": 25000,  "pingTimeout": 20000}
```

```js
sid
```

```js
sid
```

```js
upgrades
```

```js
pingInterval
```

```js
pingTimeout
```

```js
zBjrh...AAAK
```

```js
socket.disconnect()
```

```js
pingInterval
```

```js
pingTimeout
```

```js
pingInterval + pingTimeout
```

# https://socket.io/docs/v4/listening-to-events

# Listening to events

## EventEmitter methods​

## Catch-all listeners​

## Validation​

## Error handling​

### socket.on(eventName, listener)​

### socket.once(eventName, listener)​

### socket.off(eventName, listener)​

### socket.removeAllListeners([eventName])​

### socket.onAny(listener)​

### socket.prependAny(listener)​

### socket.offAny([listener])​

### socket.onAnyOutgoing(listener)​

### socket.prependAnyOutgoing(listener)​

### socket.offAnyOutgoing([listener])​

There are several ways to handle events that are transmitted between the server and the client.

On the server-side, the Socket instance extends the Node.js EventEmitter class.

On the client-side, the Socket instance uses the event emitter provided by the component-emitter library, which exposes a subset of the EventEmitter methods.

Adds the listener function to the end of the listeners array for the event named eventName.

Adds a one-time listener function for the event named eventName

Removes the specified listener from the listener array for the event named eventName.

Removes all listeners, or those of the specified eventName.

This feature is available on both the client and the server.

Adds a listener that will be fired when any event is emitted.

Acknowledgements are not caught in the catch-all listener.

Adds a listener that will be fired when any event is emitted. The listener is added to the beginning of the listeners array.

Removes all catch-all listeners, or the given listener.

Register a new catch-all listener for outgoing packets.

Acknowledgements are not caught in the catch-all listener.

Register a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array.

Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed.

The validation of the event arguments is out of the scope of the Socket.IO library.

There are many packages in the JS ecosystem which cover this use case, among them:

Example with joi and acknowledgements:

There is currently no built-in error handling in the Socket.IO library, which means you must catch any error that could be thrown in a listener.

This can be refactored into:

- Events
- Listening to events
- zod
- joi
- ajv
- validatorjs
```js
socket.on("details", (...args) => {  // ...});
```

```js
socket.once("details", (...args) => {  // ...});
```

```js
const listener = (...args) => {  console.log(args);}socket.on("details", listener);// and then later...socket.off("details", listener);
```

```js
// for a specific eventsocket.removeAllListeners("details");// for all eventssocket.removeAllListeners();
```

```js
socket.onAny((eventName, ...args) => {  // ...});
```

```js
socket.emit("foo", (value) => {  // ...});socket.onAnyOutgoing(() => {  // triggered when the event is sent});socket.onAny(() => {  // not triggered when the acknowledgement is received});
```

```js
socket.prependAny((eventName, ...args) => {  // ...});
```

```js
const listener = (eventName, ...args) => {  console.log(eventName, args);}socket.onAny(listener);// and then later...socket.offAny(listener);// or all listenerssocket.offAny();
```

```js
socket.onAnyOutgoing((event, ...args) => {  // ...});
```

```js
socket.on("foo", (value, callback) => {  callback("OK");});socket.onAny(() => {  // triggered when the event is received});socket.onAnyOutgoing(() => {  // not triggered when the acknowledgement is sent});
```

```js
socket.prependAnyOutgoing((event, ...args) => {  // ...});
```

```js
const listener = (eventName, ...args) => {  console.log(eventName, args);}socket.onAnyOutgoing(listener);// remove a single listenersocket.offAnyOutgoing(listener);// remove all listenerssocket.offAnyOutgoing();
```

```js
const Joi = require("joi");const userSchema = Joi.object({  username: Joi.string().max(30).required(),  email: Joi.string().email().required()});io.on("connection", (socket) => {  socket.on("create user", (payload, callback) => {    if (typeof callback !== "function") {      // not an acknowledgement      return socket.disconnect();    }    const { error, value } = userSchema.validate(payload);    if (error) {      return callback({        status: "Bad Request",        error      });    }    // do something with the value, and then    callback({      status: "OK"    });  });});
```

```js
io.on("connection", (socket) => {  socket.on("list items", async (callback) => {    try {      const items = await findItems();      callback({        status: "OK",        items      });    } catch (e) {      callback({        status: "NOK"      });    }  });});
```

```js
const errorHandler = (handler) => {  const handleError = (err) => {    console.error("please handle me", err);  };  return (...args) => {    try {      const ret = handler.apply(this, args);      if (ret && typeof ret.catch === "function") {        // async handler        ret.catch(handleError);      }    } catch (e) {      // sync handler      handleError(e);    }  };};// server or client sidesocket.on("hello", errorHandler(() => {  throw new Error("let's panic");}));
```

```js
socket.on("details", (...args) => {  // ...});
```

```js
socket.once("details", (...args) => {  // ...});
```

```js
const listener = (...args) => {  console.log(args);}socket.on("details", listener);// and then later...socket.off("details", listener);
```

```js
// for a specific eventsocket.removeAllListeners("details");// for all eventssocket.removeAllListeners();
```

```js
socket.onAny((eventName, ...args) => {  // ...});
```

```js
socket.emit("foo", (value) => {  // ...});socket.onAnyOutgoing(() => {  // triggered when the event is sent});socket.onAny(() => {  // not triggered when the acknowledgement is received});
```

```js
socket.prependAny((eventName, ...args) => {  // ...});
```

```js
const listener = (eventName, ...args) => {  console.log(eventName, args);}socket.onAny(listener);// and then later...socket.offAny(listener);// or all listenerssocket.offAny();
```

```js
socket.onAnyOutgoing((event, ...args) => {  // ...});
```

```js
socket.on("foo", (value, callback) => {  callback("OK");});socket.onAny(() => {  // triggered when the event is received});socket.onAnyOutgoing(() => {  // not triggered when the acknowledgement is sent});
```

```js
socket.prependAnyOutgoing((event, ...args) => {  // ...});
```

```js
const listener = (eventName, ...args) => {  console.log(eventName, args);}socket.onAnyOutgoing(listener);// remove a single listenersocket.offAnyOutgoing(listener);// remove all listenerssocket.offAnyOutgoing();
```

```js
const Joi = require("joi");const userSchema = Joi.object({  username: Joi.string().max(30).required(),  email: Joi.string().email().required()});io.on("connection", (socket) => {  socket.on("create user", (payload, callback) => {    if (typeof callback !== "function") {      // not an acknowledgement      return socket.disconnect();    }    const { error, value } = userSchema.validate(payload);    if (error) {      return callback({        status: "Bad Request",        error      });    }    // do something with the value, and then    callback({      status: "OK"    });  });});
```

```js
io.on("connection", (socket) => {  socket.on("list items", async (callback) => {    try {      const items = await findItems();      callback({        status: "OK",        items      });    } catch (e) {      callback({        status: "NOK"      });    }  });});
```

```js
const errorHandler = (handler) => {  const handleError = (err) => {    console.error("please handle me", err);  };  return (...args) => {    try {      const ret = handler.apply(this, args);      if (ret && typeof ret.catch === "function") {        // async handler        ret.catch(handleError);      }    } catch (e) {      // sync handler      handleError(e);    }  };};// server or client sidesocket.on("hello", errorHandler(() => {  throw new Error("let's panic");}));
```

# https://socket.io/docs/v4/load-testing

# Load testing

## Artillery​

## Manual client creation​

Since Socket.IO has its own protocol, including handshake, heartbeats and custom packet encoding, the easiest way to load test your Socket.IO server is to use the Socket.IO client library and create a lot of clients.

There are two classic solutions to do this:

Artillery is a great tool for load testing your application. It allows creating connections, sending events and checking acknowledgments.

The documentation can be found here.

Important note: the default installation comes with a v2 client, which is not compatible with a v3/v4 server. You need to install a custom engine for this: https://github.com/ptejada/artillery-engine-socketio-v3

Installation:

Sample scenario:

To run this scenario:

Artillery also comes with a lot of awesome features, like the ability to publish the metrics to various endpoints or run the tests from AWS.

Its only limitation is that you cannot easily test server-to-client events, as the Artillery DSL is more suited for classic client-to-server communication. Which brings us to our next section.

Here's a basic script to create a thousand Socket.IO clients and monitor the number of packets received per second:

You can use it as a starting point for load testing your own application.

- Advanced
- Load testing
- using Artillery
- or manually manage the clients
```js
$ npm install artillery artillery-engine-socketio-v3
```

```js
# my-scenario.ymlconfig:  target: "http://localhost:3000"  phases:    - duration: 60      arrivalRate: 10  engines:   socketio-v3: {}scenarios:  - name: My sample scenario    engine: socketio-v3    flow:      # wait for the WebSocket upgrade (optional)      - think: 1      # basic emit      - emit:          channel: "hello"          data: "world"      # emit an object      - emit:          channel: "hello"          data:            id: 42            status: "in progress"            tags:              - "tag1"              - "tag2"      # emit in a custom namespace      - namespace: "/my-namespace"        emit:          channel: "hello"          data: "world"      # emit with acknowledgement      - emit:          channel: "ping"        acknowledge:          match:            value: "pong"      # do nothing for 30 seconds then disconnect      - think: 30
```

```js
$ npx artillery run my-scenario.yml
```

```js
const { io } = require("socket.io-client");const URL = process.env.URL || "http://localhost:3000";const MAX_CLIENTS = 1000;const POLLING_PERCENTAGE = 0.05;const CLIENT_CREATION_INTERVAL_IN_MS = 10;const EMIT_INTERVAL_IN_MS = 1000;let clientCount = 0;let lastReport = new Date().getTime();let packetsSinceLastReport = 0;const createClient = () => {  // for demonstration purposes, some clients stay stuck in HTTP long-polling  const transports =    Math.random() < POLLING_PERCENTAGE ? ["polling"] : ["polling", "websocket"];  const socket = io(URL, {    transports,  });  setInterval(() => {    socket.emit("client to server event");  }, EMIT_INTERVAL_IN_MS);  socket.on("server to client event", () => {    packetsSinceLastReport++;  });  socket.on("disconnect", (reason) => {    console.log(`disconnect due to ${reason}`);  });  if (++clientCount < MAX_CLIENTS) {    setTimeout(createClient, CLIENT_CREATION_INTERVAL_IN_MS);  }};createClient();const printReport = () => {  const now = new Date().getTime();  const durationSinceLastReport = (now - lastReport) / 1000;  const packetsPerSeconds = (    packetsSinceLastReport / durationSinceLastReport  ).toFixed(2);  console.log(    `client count: ${clientCount} ; average packets received per second: ${packetsPerSeconds}`  );  packetsSinceLastReport = 0;  lastReport = now;};setInterval(printReport, 5000);
```

```js
$ npm install artillery artillery-engine-socketio-v3
```

```js
# my-scenario.ymlconfig:  target: "http://localhost:3000"  phases:    - duration: 60      arrivalRate: 10  engines:   socketio-v3: {}scenarios:  - name: My sample scenario    engine: socketio-v3    flow:      # wait for the WebSocket upgrade (optional)      - think: 1      # basic emit      - emit:          channel: "hello"          data: "world"      # emit an object      - emit:          channel: "hello"          data:            id: 42            status: "in progress"            tags:              - "tag1"              - "tag2"      # emit in a custom namespace      - namespace: "/my-namespace"        emit:          channel: "hello"          data: "world"      # emit with acknowledgement      - emit:          channel: "ping"        acknowledge:          match:            value: "pong"      # do nothing for 30 seconds then disconnect      - think: 30
```

```js
$ npx artillery run my-scenario.yml
```

```js
const { io } = require("socket.io-client");const URL = process.env.URL || "http://localhost:3000";const MAX_CLIENTS = 1000;const POLLING_PERCENTAGE = 0.05;const CLIENT_CREATION_INTERVAL_IN_MS = 10;const EMIT_INTERVAL_IN_MS = 1000;let clientCount = 0;let lastReport = new Date().getTime();let packetsSinceLastReport = 0;const createClient = () => {  // for demonstration purposes, some clients stay stuck in HTTP long-polling  const transports =    Math.random() < POLLING_PERCENTAGE ? ["polling"] : ["polling", "websocket"];  const socket = io(URL, {    transports,  });  setInterval(() => {    socket.emit("client to server event");  }, EMIT_INTERVAL_IN_MS);  socket.on("server to client event", () => {    packetsSinceLastReport++;  });  socket.on("disconnect", (reason) => {    console.log(`disconnect due to ${reason}`);  });  if (++clientCount < MAX_CLIENTS) {    setTimeout(createClient, CLIENT_CREATION_INTERVAL_IN_MS);  }};createClient();const printReport = () => {  const now = new Date().getTime();  const durationSinceLastReport = (now - lastReport) / 1000;  const packetsPerSeconds = (    packetsSinceLastReport / durationSinceLastReport  ).toFixed(2);  console.log(    `client count: ${clientCount} ; average packets received per second: ${packetsPerSeconds}`  );  packetsSinceLastReport = 0;  lastReport = now;};setInterval(printReport, 5000);
```

# https://socket.io/docs/v4/logging-and-debugging

# Logging and debugging

## Available debugging scopes​

## Error logs in the browser console​

### Removing debug from your browser bundle​

Socket.IO is now completely instrumented by a minimalistic yet tremendously powerful utility called debug by TJ Holowaychuk.

Before 1.0, the Socket.IO server would default to logging everything out to the console. This turned out to be annoyingly verbose for many users (although extremely useful for others), so now we default to being completely silent by default.

The basic idea is that each module used by Socket.IO provides different debugging scopes that give you insight into the internals. By default, all output is suppressed, and you can opt into seeing messages by supplying the DEBUG env variable (Node.JS) or the localStorage.debug property (Browsers).

You can see it in action for example on our homepage:

The best way to see what information is available is to use the *:

or in the browser:

And then filter by the scopes you’re interested in. You can prefix the * with scopes, separated by comma if there is more than one. For example, to only see debug statements from the socket.io client on Node.js try this:

To see all debug messages from the engine and socket.io:

While useful during development, the debug package adds an extra weight to the final bundle (about 4KB minified and gzipped), that's why it is excluded from the slim bundle (more details about the various browser bundles can be found here).

If you are using webpack, you can remove it with webpack-remove-debug:

Please note that error logs such as:

are not emitted by the Socket.IO library but by the browser itself, and are therefore out of our control.

- Documentation
- Logging and debugging
- net::ERR_INTERNET_DISCONNECTED
- net::ERR_CONNECTION_REFUSED
- WebSocket is already in CLOSING or CLOSED state
- Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
- The connection to xxx was interrupted while the page was loading
```js
DEBUG=* node yourfile.js
```

```js
localStorage.debug = '*';
```

```js
DEBUG=socket.io:client* node yourfile.js
```

```js
DEBUG=engine,socket.io* node yourfile.js
```

```js
{  module: {    rules: [      {        test: /\.js$/,        loader: 'webpack-remove-debug'      }    ]  }}
```

```js
DEBUG
```

```js
localStorage.debug
```

```js
DEBUG=* node yourfile.js
```

```js
localStorage.debug = '*';
```

```js
DEBUG=socket.io:client* node yourfile.js
```

```js
DEBUG=engine,socket.io* node yourfile.js
```

```js
{  module: {    rules: [      {        test: /\.js$/,        loader: 'webpack-remove-debug'      }    ]  }}
```

```js
net::ERR_INTERNET_DISCONNECTED
```

```js
net::ERR_CONNECTION_REFUSED
```

```js
WebSocket is already in CLOSING or CLOSED state
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
The connection to xxx was interrupted while the page was loading
```

# https://socket.io/docs/v4/memory-usage

# Memory usage

## Memory usage per WebSocket server implementation​

## Memory usage over time​

The resources consumed by your Socket.IO server will mainly depend on:

The memory usage of the Socket.IO server should scale linearly with the number of connected clients.

By default, a reference to the first HTTP request of each session is kept in memory. This reference is needed when working with express-session for example (see here), but can be discarded to save memory:

The source code to reproduce the results presented in this page can be found there.

See also:

The memory usage of the Socket.IO server heavily depends on the memory usage of the underlying WebSocket server implementation.

The chart below displays the memory usage of the Socket.IO server, from 0 up to 10 000 connected clients, with:

Tested on Ubuntu 22.04 LTS with Node.js v20.3.0, with the following package versions:

The chart below displays the memory usage of the Socket.IO server over time, from 0 up to 10 000 connected clients.

For demonstration purposes, we manually call the garbage collector at the end of each wave of clients:

Which explains the clean drop in memory usage when the last client disconnects. This is not needed in your application, the garbage collection will be automatically triggered when necessary.

- Documentation
- Memory usage
- the number of connected clients
- the number of messages (basic emit, emit with acknowledgement and broadcast) received and sent per second
- Load testing
- Performance tuning
- a Socket.IO server based on the ws package (used by default)
- a Socket.IO server based on the eiows package, a C++ WebSocket server implementation (see installation steps)
- a Socket.IO server based on the µWebSockets.js package, a C++ alternative to the Node.js native HTTP server (see installation steps)
- a plain WebSocket server based on the ws package
- socket.io@4.7.2
- eiows@6.7.2
- uWebSockets.js@20.33.0
- ws@8.11.0
```js
io.engine.on("connection", (rawSocket) => {  rawSocket.request = null;});
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", () => {    const lastToDisconnect = io.of("/").sockets.size === 0;    if (lastToDisconnect) {      gc();    }  });});
```

```js
express-session
```

```js
io.engine.on("connection", (rawSocket) => {  rawSocket.request = null;});
```

```js
eiows
```

```js
µWebSockets.js
```

```js
Ubuntu 22.04 LTS
```

```js
v20.3.0
```

```js
socket.io@4.7.2
```

```js
eiows@6.7.2
```

```js
uWebSockets.js@20.33.0
```

```js
ws@8.11.0
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", () => {    const lastToDisconnect = io.of("/").sockets.size === 0;    if (lastToDisconnect) {      gc();    }  });});
```

# https://socket.io/docs/v4/middlewares

# Middlewares

## Registering a middleware​

## Sending credentials​

## Handling middleware error​

## Compatibility with Express middleware​

A middleware function is a function that gets executed for every incoming connection.

Middleware functions can be useful for:

Note: this function will be executed only once per connection (even if the connection consists in multiple HTTP requests).

If you are looking for Express middlewares, please check this section.

A middleware function has access to the Socket instance and to the next registered middleware function.

You can register several middleware functions, and they will be executed sequentially:

Please make sure to call next() in any case. Otherwise, the connection will be left hanging until it is closed after a given timeout.

Important note: the Socket instance is not actually connected when the middleware gets executed, which means that no disconnect event will be emitted if the connection eventually fails.

For example, if the client manually closes the connection:

The client can send credentials with the auth option:

Those credentials can be accessed in the handshake object on the server-side:

If the next method is called with an Error object, the connection will be refused and the client will receive an connect_error event.

You can attach additional details to the Error object:

Since they are not bound to a usual HTTP request/response cycle, Socket.IO middlewares are not really compatible with Express middlewares.

That being said, starting with version 4.6.0, Express middlewares are now supported by the underlying engine:

The middlewares will be called for each incoming HTTP requests, including upgrade requests.

Example with express-session:

Example with helmet:

If the middleware must be only applied to the handshake request (and not for each HTTP request), you can check for the existence of the sid query parameter.

Example with passport-jwt:

- Server
- Middlewares
- logging
- authentication / authorization
- rate limiting
```js
io.use((socket, next) => {  if (isValid(socket.request)) {    next();  } else {    next(new Error("invalid"));  }});
```

```js
io.use((socket, next) => {  next();});io.use((socket, next) => {  next(new Error("thou shall not pass"));});io.use((socket, next) => {  // not executed, since the previous middleware has returned an error  next();});
```

```js
// server-sideio.use((socket, next) => {  setTimeout(() => {    // next is called after the client disconnection    next();  }, 1000);  socket.on("disconnect", () => {    // not triggered  });});io.on("connection", (socket) => {  // not triggered});// client-sideconst socket = io();setTimeout(() => {  socket.disconnect();}, 500);
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});
```

```js
io.use((socket, next) => {  const token = socket.handshake.auth.token;  // ...});
```

```js
// client-sidesocket.on("connect_error", (err) => {  console.log(err.message); // prints the message associated with the error});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", (err) => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
io.engine.use((req, res, next) => {  // do something  next();});
```

```js
import session from "express-session";io.engine.use(session({  secret: "keyboard cat",  resave: false,  saveUninitialized: true,  cookie: { secure: true }}));
```

```js
import helmet from "helmet";io.engine.use(helmet());
```

```js
io.engine.use((req, res, next) => {  const isHandshake = req._query.sid === undefined;  if (isHandshake) {    passport.authenticate("jwt", { session: false })(req, res, next);  } else {    next();  }});
```

```js
io.use((socket, next) => {  if (isValid(socket.request)) {    next();  } else {    next(new Error("invalid"));  }});
```

```js
io.use((socket, next) => {  next();});io.use((socket, next) => {  next(new Error("thou shall not pass"));});io.use((socket, next) => {  // not executed, since the previous middleware has returned an error  next();});
```

```js
next()
```

```js
disconnect
```

```js
// server-sideio.use((socket, next) => {  setTimeout(() => {    // next is called after the client disconnection    next();  }, 1000);  socket.on("disconnect", () => {    // not triggered  });});io.on("connection", (socket) => {  // not triggered});// client-sideconst socket = io();setTimeout(() => {  socket.disconnect();}, 500);
```

```js
auth
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});
```

```js
io.use((socket, next) => {  const token = socket.handshake.auth.token;  // ...});
```

```js
next
```

```js
connect_error
```

```js
// client-sidesocket.on("connect_error", (err) => {  console.log(err.message); // prints the message associated with the error});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", (err) => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
4.6.0
```

```js
io.engine.use((req, res, next) => {  // do something  next();});
```

```js
express-session
```

```js
import session from "express-session";io.engine.use(session({  secret: "keyboard cat",  resave: false,  saveUninitialized: true,  cookie: { secure: true }}));
```

```js
helmet
```

```js
import helmet from "helmet";io.engine.use(helmet());
```

```js
sid
```

```js
passport-jwt
```

```js
io.engine.use((req, res, next) => {  const isHandshake = req._query.sid === undefined;  if (isHandshake) {    passport.authenticate("jwt", { session: false })(req, res, next);  } else {    next();  }});
```

# https://socket.io/docs/v4/migrating-from-2-x-to-3-0

# Migrating from 2.x to 3.0

### Configuration​

### New features​

### Miscellaneous​

### How to upgrade an existing production deployment​

### Known migration issues​

This release should fix most of the inconsistencies of the Socket.IO library and provide a more intuitive behavior for
the end users. It is the result of the feedback of the community over the years. A big thanks to everyone involved!

TL;DR: due to several breaking changes, a v2 client will not be able to connect to a v3 server (and vice versa)

Update: As of Socket.IO 3.1.0, the v3 server is now able to communicate with v2 clients. More information below. A v3 client is still not be able to connect to a v2 server though.

For the low-level details, please see:

Here is the complete list of changes:

Configuration

New features

Miscellaneous

How to upgrade an existing production deployment

Known migration issues

In v2, the Socket.IO server automatically added the necessary headers to allow Cross-Origin Resource Sharing (CORS).

This behavior, while convenient, was not great in terms of security, because it meant that all domains were allowed to reach your Socket.IO server, unless otherwise specified with the origins option.

That's why, as of Socket.IO v3:

The complete list of options can be found here.

Before:

After:

In previous versions, an io cookie was sent by default. This cookie can be used to enable sticky-session, which is still required when you have several servers and HTTP long-polling enabled (more information here).

However, this cookie is not needed in some cases (i.e. single server deployment, sticky-session based on IP) so it must now be explicitly enabled.

Before:

After:

All other options (domain, maxAge, sameSite, ...) are now supported. Please see here for the complete list of options.

Below are listed the non backward-compatible changes.

This method was deprecated in the 1.0 release and kept for backward-compatibility. It is now removed.

It was replaced by middlewares.

Before:

After:

This change impacts the users of the multiplexing feature (what we call Namespace in Socket.IO).

In previous versions, a client would always connect to the default namespace (/), even if it requested access to another namespace. This meant that the middlewares registered for the default namespace were triggered, which may be quite surprising.

Besides, we will now refer to the "main" namespace instead of the "default" namespace.

The connected object (used to store all the Socket connected to the given Namespace) could be used to retrieve a Socket object from its id. It is now an ES6 Map.

Before:

After:

The rooms property contains the list of rooms the Socket is currently in. It was an object, it is now an ES6 Set.

Before:

After:

The binary  method could be used to indicate that a given event did not contain any binary data (in order to skip the lookup done by the library and improve performance in certain conditions).

It was replaced by the ability to provide your own parser, which was added in Socket.IO 2.0.

Before:

After:

Please see socket.io-msgpack-parser for example.

The asynchronicity was needed for the first versions of the Redis adapter, but this is not the case anymore.

For reference, an Adapter is an object that stores the relationships between Sockets and Rooms. There are two official adapters: the in-memory adapter (built-in) and the Redis adapter based on Redis pub-sub mechanism.

Before:

After:

Note: custom adapters may return a Promise, so the previous example becomes:

UPDATE: the Socket.use() method was restored in socket.io@3.0.5.

Before:

After:

The error event is renamed to connect_error and the object emitted is now an actual Error:

Before:

After:

In previous versions, the query option was used in two distinct places:

Let's take the following example:

Under the hood, here's what happened in the io() method:

This behavior could lead to weird behaviors, for example when the Manager was reused for another namespace (multiplexing):

That's why the query option of the Socket instance is renamed to auth in Socket.IO v3:

Note: the query option of the Manager can still be used in order to add a specific query parameter to the HTTP requests.

In previous versions, the Socket instance emitted the events related to the state of the underlying connection. This will not be the case anymore.

You can still have access to those events on the Manager instance (the io property of the socket) :

Before:

After:

Here is the updated list of events emitted by the Manager:

Here is the updated list of events emitted by the Socket:

And finally, here's the updated list of reserved events that you cannot use in your application:

This function returns the list of socket IDs that are connected to this namespace.

Before:

After:

Note: this function was (and still is) supported by the Redis adapter, which means that it will return the list of socket IDs across all the Socket.IO servers.

There are now 3 distinct bundles:

By default, all of them are served by the server, at /socket.io/<name>.

Before:

After:

In Socket.IO v2, you could listen to the pong event on the client-side, which included the duration of the last health check round-trip.

Due to the reversal of the heartbeat mechanism (more information here), this event has been removed.

Before:

After:

The ECMAScript modules syntax is now similar to the Typescript one (see below).

Before (using default import):

After (with named import):

The emit() method now matches the EventEmitter.emit() method signature, and returns true instead of the current object.

Before:

After:

We are now using Maps and Sets internally instead of plain objects, so the room names are not implicitly coerced to string anymore.

Before:

After:

Some of those new features may be backported to the 2.4.x branch, depending on the feedback of the users.

This feature is inspired from the EventEmitter2 library (which is not used directly in order not to increase the browser bundle size).

It is available for both the server and the client sides:

A volatile event is an event that is allowed to be dropped if the low-level transport is not ready yet (for example when an HTTP POST request is already pending).

This feature was already available on the server-side. It might be useful on the client-side as well, for example when the socket is not connected (by default, packets are buffered until reconnection).

A bundle with the socket.io-msgpack-parser will now be provided (either on the CDN or served by the server at /socket.io/socket.io.msgpack.min.js).

Pros:

Cons:

No additional configuration is needed on the client-side.

Which means npm i -D @types/socket.io should not be needed anymore.

Server:

Client:

Plain javascript is obviously still fully supported.

IE8 is no longer testable on the Sauce Labs platform, and requires a lot of efforts for very few users (if any?), so we are dropping support for it.

Besides, Node.js 8 is now EOL. Please upgrade as soon as possible!

Note: If you are using the Redis adapter to broadcast packets between nodes, you must use socket.io-redis@5 with socket.io@2 and socket.io-redis@6 with socket.io@3. Please note that both versions are compatible, so you can update each server one by one (no big bang is needed).

This step may actually take some time, as some clients may still have a v2 client in cache.

You can check the version of the connection with:

This matches the value of the EIO query parameter in the HTTP requests.

With allowEIO3 set to false, v2 clients will now receive an HTTP 400 error (Unsupported protocol version) when connecting.

This error is probably due to your version of Node.js. The pipeline method was introduced in Node.js 10.0.0.

The signature of the emit() method was fixed in version 3.0.1 (commit).

This is probably due to the fact that the default value of maxHttpBufferSize is now 1MB. When receiving a packet that is larger than this, the server disconnects the client, in order to prevent malicious clients from overloading the server.

You can adjust the value when creating the server:

Since Socket.IO v3, you need to explicitly enable Cross-Origin Resource Sharing (CORS). The documentation can be found here.

It seems that you are using a v3 client to connect to a v2 server, which is not possible. Please see the following section.

Since the codebase has been rewritten to TypeScript (more information here), @types/socket.io-client is no longer needed and will actually conflict with the typings coming from the socket.io-client package.

You now need to explicitly enable cookies if the front is not served from the same domain as the backend:

Server

Client

Reference:

- Migrations
- Migrating from 2.x to 3.0
- Engine.IO protocol v4
- Socket.IO protocol v5
- ConfigurationSaner default valuesCORS handlingNo more cookie by default
- Saner default values
- CORS handling
- No more cookie by default
- io.set() is removed
- No more implicit connection to the default namespace
- Namespace.connected is renamed to Namespace.sockets and is now a Map
- Socket.rooms is now a Set
- Socket.binary() is removed
- Socket.join() and Socket.leave() are now synchronous
- Socket.use() is removed
- A middleware error will now emit an Error object
- Add a clear distinction between the Manager query option and the Socket query option
- The Socket instance will no longer forward the events emitted by its Manager
- Namespace.clients() is renamed to Namespace.allSockets() and now returns a Promise
- Client bundles
- No more "pong" event for retrieving latency
- ES modules syntax
- emit() chains are not possible anymore
- Room names are not coerced to string anymore
- New featuresCatch-all listenersVolatile events (client)Official bundle with the msgpack parser
- Catch-all listeners
- Volatile events (client)
- Official bundle with the msgpack parser
- MiscellaneousThe Socket.IO codebase has been rewritten to TypeScriptSupport for IE8 and Node.js 8 is officially dropped
- The Socket.IO codebase has been rewritten to TypeScript
- Support for IE8 and Node.js 8 is officially dropped
- How to upgrade an existing production deployment
- Known migration issues
- the default value of maxHttpBufferSize was decreased from 100MB to 1MB.
- the WebSocket permessage-deflate extension is now disabled by default
- you must now explicitly list the domains that are allowed (for CORS, see below)
- the withCredentials option now defaults to false on the client side
- CORS is now disabled by default
- the origins option (used to provide a list of authorized domains) and the handlePreflightRequest option (used to edit the Access-Control-Allow-xxx headers) are replaced by the cors option, which will be forwarded to the cors package.
- in the query parameters of the HTTP requests (GET /socket.io/?EIO=3&abc=def)
- in the CONNECT packet
- connect (used on the client-side)
- connect_error (used on the client-side)
- disconnect (used on both sides)
- disconnecting (used on the server-side)
- newListener and removeListener (EventEmitter reserved events)
- events with binary content are sent as 1 WebSocket frame (instead of 2+ with the default parser)
- payloads with lots of numbers should be smaller
- no IE9 support (https://caniuse.com/mdn-javascript_builtins_arraybuffer)
- a slightly bigger bundle size
- first, update the servers with allowEIO3 set to true (added in socket.io@3.1.0)
- then, update the clients
- and finally, once every client was updated, set allowEIO3 to false (which is the default value)
- stream_1.pipeline is not a function
- error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.
- the client is disconnected when sending a big payload (> 1MB)
- Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=4&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
- Uncaught TypeError: packet.data is undefined
- Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
- missing cookie in a cross-origin context
- Handling CORS
- cors option
- withCredentials option
```js
const io = require("socket.io")(httpServer, {  origins: ["https://example.com"],  // optional, useful for custom headers  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": "https://example.com",      "Access-Control-Allow-Methods": "GET,POST",      "Access-Control-Allow-Headers": "my-custom-header",      "Access-Control-Allow-Credentials": true    });    res.end();  }});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
const io = require("socket.io")(httpServer, {  cookieName: "io",  cookieHttpOnly: false,  cookiePath: "/custom"});
```

```js
const io = require("socket.io")(httpServer, {  cookie: {    name: "test",    httpOnly: false,    path: "/custom"  }});
```

```js
io.set("authorization", (handshakeData, callback) => {  // make sure the handshake data looks good  callback(null, true); // error first, "authorized" boolean second });
```

```js
io.use((socket, next) => {  var handshakeData = socket.request;  // make sure the handshake data looks good as before  // if error do this:    // next(new Error("not authorized"));  // else just call next  next();});
```

```js
// client-sideconst socket = io("/admin");// server-sideio.use((socket, next) => {  // not triggered anymore});io.on("connection", socket => {  // not triggered anymore})io.of("/admin").use((socket, next) => {  // triggered});
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").connected[socketId];// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").connected[socketId];// loop through all socketsconst sockets = io.of("/").connected;for (const id in sockets) {  if (sockets.hasOwnProperty(id)) {    const socket = sockets[id];    // ...  }}// get the number of connected socketsconst count = Object.keys(io.of("/").connected).length;
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").sockets.get(socketId);// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").sockets.get(socketId);// loop through all socketsfor (const [_, socket] of io.of("/").sockets) {  // ...}// get the number of connected socketsconst count = io.of("/").sockets.size;
```

```js
io.on("connection", (socket) => {  console.log(Object.keys(socket.rooms)); // [ <socket.id> ]  socket.join("room1");  console.log(Object.keys(socket.rooms)); // [ <socket.id>, "room1" ]});
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
socket.binary(false).emit("hello", "no binary");
```

```js
const io = require("socket.io")(httpServer, {  parser: myCustomParser});
```

```js
socket.join("room1", () => { io.to("room1").emit("hello");});socket.leave("room2", () => {  io.to("room2").emit("bye");});
```

```js
socket.join("room1");io.to("room1").emit("hello");socket.leave("room2");io.to("room2").emit("bye");
```

```js
await socket.join("room1");io.to("room1").emit("hello");
```

```js
socket.use((packet, next) => {  console.log(packet.data);  next();});
```

```js
socket.onAny((event, ...args) => {  console.log(event);});
```

```js
// server-sideio.use((socket, next) => {  next(new Error("not authorized"));});// client-sidesocket.on("error", err => {  console.log(err); // not authorized});// or with an object// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("error", err => {  console.log(err); // { content: "Please retry later" }});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
const socket = io({  query: {    token: "abc"  }});
```

```js
const { Manager } = require("socket.io-client");// a new Manager is created (which will manage the low-level connection)const manager = new Manager({  query: { // sent in the query parameters    token: "abc"  }});// and then a Socket instance is created for the namespace (here, the main namespace, "/")const socket = manager.socket("/", {  query: { // sent in the CONNECT packet    token: "abc"  }});
```

```js
// client-sideconst socket1 = io({  query: {    token: "abc"  }});const socket2 = io("/my-namespace", {  query: {    token: "def"  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (ok!)});io.of("/my-namespace").on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (what?)});
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.auth.token); // abc});
```

```js
socket.on("reconnect_attempt", () => {});
```

```js
socket.io.on("reconnect_attempt", () => {});
```

```js
socket.emit("connect_error"); // will now throw an Error
```

```js
// all sockets in default namespaceio.clients((error, clients) => {  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]});// all sockets in the "chat" namespaceio.of("/chat").clients((error, clients) => {  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]});// all sockets in the "chat" namespace and in the "general" roomio.of("/chat").in("general").clients((error, clients) => {  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]});
```

```js
// all sockets in default namespaceconst ids = await io.allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
<!-- note: this bundle was actually minified but included the debug package --><script src="/socket.io/socket.io.js"></script>
```

```js
<!-- during development --><script src="/socket.io/socket.io.js"></script><!-- for production --><script src="/socket.io/socket.io.min.js"></script>
```

```js
socket.on("pong", (latency) => {  console.log(latency);});
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("ping", (cb) => {    if (typeof cb === "function")      cb();  });});// client-sidesetInterval(() => {  const start = Date.now();  // volatile, so the packet will be discarded if the socket is not connected  socket.volatile.emit("ping", () => {    const latency = Date.now() - start;    // ...  });}, 5000);
```

```js
// server-sideimport Server from "socket.io";const io = new Server(8080);// client-sideimport io from 'socket.io-client';const socket = io();
```

```js
// server-sideimport { Server } from "socket.io";const io = new Server(8080);// client-sideimport { io } from 'socket.io-client';const socket = io();
```

```js
socket.emit("event1").emit("event2");
```

```js
socket.emit("event1");socket.emit("event2");
```

```js
// mixed types were possiblesocket.join(42);io.to("42").emit("hello");// also workedsocket.join("42");io.to(42).emit("hello");
```

```js
// one waysocket.join("42");io.to("42").emit("hello");// or anothersocket.join(42);io.to(42).emit("hello");
```

```js
// serverio.on("connection", (socket) => {  socket.onAny((event, ...args) => {});  socket.prependAny((event, ...args) => {});  socket.offAny(); // remove all listeners  socket.offAny(listener);  const listeners = socket.listenersAny();});// clientconst socket = io();socket.onAny((event, ...args) => {});socket.prependAny((event, ...args) => {});socket.offAny(); // remove all listenerssocket.offAny(listener);const listeners = socket.listenersAny();
```

```js
socket.volatile.emit("volatile event", "might or might not be sent");
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  parser: require("socket.io-msgpack-parser")});
```

```js
import { Server, Socket } from "socket.io";const io = new Server(8080);io.on("connection", (socket: Socket) => {    console.log(`connect ${socket.id}`);    socket.on("disconnect", () => {        console.log(`disconnect ${socket.id}`);    });});
```

```js
import { io } from "socket.io-client";const socket = io("/");socket.on("connect", () => {    console.log(`connect ${socket.id}`);});
```

```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
io.on("connection", (socket) => {  const version = socket.conn.protocol; // either 3 or 4});
```

```js
const io = require("socket.io")({  allowEIO3: false});
```

```js
TypeError: stream_1.pipeline is not a function    at Function.sendFile (.../node_modules/socket.io/dist/index.js:249:26)    at Server.serve (.../node_modules/socket.io/dist/index.js:225:16)    at Server.srv.on (.../node_modules/socket.io/dist/index.js:186:22)    at emitTwo (events.js:126:13)    at Server.emit (events.js:214:7)    at parserOnIncoming (_http_server.js:602:12)    at HTTPParser.parserOnHeadersComplete (_http_common.js:116:23)
```

```js
node_modules/socket.io/dist/namespace.d.ts(89,5): error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => Namespace' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'Namespace' is not assignable to type 'boolean'.node_modules/socket.io/dist/socket.d.ts(84,5): error TS2416: Property 'emit' in type 'Socket' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => this' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'this' is not assignable to type 'boolean'.      Type 'Socket' is not assignable to type 'boolean'.
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
import { Server } from "socket.io";const io = new Server({  cors: {    origin: ["https://front.domain.com"],    credentials: true  }});
```

```js
import { io } from "socket.io-client";const socket = io("https://backend.domain.com", {  withCredentials: true});
```

```js
emit()
```

```js
maxHttpBufferSize
```

```js
100MB
```

```js
1MB
```

```js
withCredentials
```

```js
false
```

```js
origins
```

```js
origins
```

```js
handlePreflightRequest
```

```js
Access-Control-Allow-xxx
```

```js
cors
```

```js
const io = require("socket.io")(httpServer, {  origins: ["https://example.com"],  // optional, useful for custom headers  handlePreflightRequest: (req, res) => {    res.writeHead(200, {      "Access-Control-Allow-Origin": "https://example.com",      "Access-Control-Allow-Methods": "GET,POST",      "Access-Control-Allow-Headers": "my-custom-header",      "Access-Control-Allow-Credentials": true    });    res.end();  }});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://example.com",    methods: ["GET", "POST"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
const io = require("socket.io")(httpServer, {  cookieName: "io",  cookieHttpOnly: false,  cookiePath: "/custom"});
```

```js
const io = require("socket.io")(httpServer, {  cookie: {    name: "test",    httpOnly: false,    path: "/custom"  }});
```

```js
io.set("authorization", (handshakeData, callback) => {  // make sure the handshake data looks good  callback(null, true); // error first, "authorized" boolean second });
```

```js
io.use((socket, next) => {  var handshakeData = socket.request;  // make sure the handshake data looks good as before  // if error do this:    // next(new Error("not authorized"));  // else just call next  next();});
```

```js
// client-sideconst socket = io("/admin");// server-sideio.use((socket, next) => {  // not triggered anymore});io.on("connection", socket => {  // not triggered anymore})io.of("/admin").use((socket, next) => {  // triggered});
```

```js
connected
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").connected[socketId];// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").connected[socketId];// loop through all socketsconst sockets = io.of("/").connected;for (const id in sockets) {  if (sockets.hasOwnProperty(id)) {    const socket = sockets[id];    // ...  }}// get the number of connected socketsconst count = Object.keys(io.of("/").connected).length;
```

```js
// get a socket by ID in the main namespaceconst socket = io.of("/").sockets.get(socketId);// get a socket by ID in the "admin" namespaceconst socket = io.of("/admin").sockets.get(socketId);// loop through all socketsfor (const [_, socket] of io.of("/").sockets) {  // ...}// get the number of connected socketsconst count = io.of("/").sockets.size;
```

```js
rooms
```

```js
io.on("connection", (socket) => {  console.log(Object.keys(socket.rooms)); // [ <socket.id> ]  socket.join("room1");  console.log(Object.keys(socket.rooms)); // [ <socket.id>, "room1" ]});
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
binary
```

```js
socket.binary(false).emit("hello", "no binary");
```

```js
const io = require("socket.io")(httpServer, {  parser: myCustomParser});
```

```js
socket.join("room1", () => { io.to("room1").emit("hello");});socket.leave("room2", () => {  io.to("room2").emit("bye");});
```

```js
socket.join("room1");io.to("room1").emit("hello");socket.leave("room2");io.to("room2").emit("bye");
```

```js
await socket.join("room1");io.to("room1").emit("hello");
```

```js
socket.use()
```

```js
Socket.use()
```

```js
socket.io@3.0.5
```

```js
socket.use((packet, next) => {  console.log(packet.data);  next();});
```

```js
socket.onAny((event, ...args) => {  console.log(event);});
```

```js
error
```

```js
connect_error
```

```js
// server-sideio.use((socket, next) => {  next(new Error("not authorized"));});// client-sidesocket.on("error", err => {  console.log(err); // not authorized});// or with an object// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("error", err => {  console.log(err); // { content: "Please retry later" }});
```

```js
// server-sideio.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});// client-sidesocket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
query
```

```js
GET /socket.io/?EIO=3&abc=def
```

```js
CONNECT
```

```js
const socket = io({  query: {    token: "abc"  }});
```

```js
io()
```

```js
const { Manager } = require("socket.io-client");// a new Manager is created (which will manage the low-level connection)const manager = new Manager({  query: { // sent in the query parameters    token: "abc"  }});// and then a Socket instance is created for the namespace (here, the main namespace, "/")const socket = manager.socket("/", {  query: { // sent in the CONNECT packet    token: "abc"  }});
```

```js
// client-sideconst socket1 = io({  query: {    token: "abc"  }});const socket2 = io("/my-namespace", {  query: {    token: "def"  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (ok!)});io.of("/my-namespace").on("connection", (socket) => {  console.log(socket.handshake.query.token); // abc (what?)});
```

```js
query
```

```js
auth
```

```js
// plain objectconst socket = io({  auth: {    token: "abc"  }});// or with a functionconst socket = io({  auth: (cb) => {    cb({      token: "abc"    });  }});// server-sideio.on("connection", (socket) => {  console.log(socket.handshake.auth.token); // abc});
```

```js
query
```

```js
socket.on("reconnect_attempt", () => {});
```

```js
socket.io.on("reconnect_attempt", () => {});
```

```js
connect
```

```js
connect_error
```

```js
disconnect
```

```js
disconnecting
```

```js
newListener
```

```js
removeListener
```

```js
socket.emit("connect_error"); // will now throw an Error
```

```js
// all sockets in default namespaceio.clients((error, clients) => {  console.log(clients); // => [6em3d4TJP8Et9EMNAAAA, G5p55dHhGgUnLUctAAAB]});// all sockets in the "chat" namespaceio.of("/chat").clients((error, clients) => {  console.log(clients); // => [PZDoMHjiu8PYfRiKAAAF, Anw2LatarvGVVXEIAAAD]});// all sockets in the "chat" namespace and in the "general" roomio.of("/chat").in("general").clients((error, clients) => {  console.log(clients); // => [Anw2LatarvGVVXEIAAAD]});
```

```js
// all sockets in default namespaceconst ids = await io.allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
/socket.io/<name>
```

```js
<!-- note: this bundle was actually minified but included the debug package --><script src="/socket.io/socket.io.js"></script>
```

```js
<!-- during development --><script src="/socket.io/socket.io.js"></script><!-- for production --><script src="/socket.io/socket.io.min.js"></script>
```

```js
pong
```

```js
socket.on("pong", (latency) => {  console.log(latency);});
```

```js
// server-sideio.on("connection", (socket) => {  socket.on("ping", (cb) => {    if (typeof cb === "function")      cb();  });});// client-sidesetInterval(() => {  const start = Date.now();  // volatile, so the packet will be discarded if the socket is not connected  socket.volatile.emit("ping", () => {    const latency = Date.now() - start;    // ...  });}, 5000);
```

```js
// server-sideimport Server from "socket.io";const io = new Server(8080);// client-sideimport io from 'socket.io-client';const socket = io();
```

```js
// server-sideimport { Server } from "socket.io";const io = new Server(8080);// client-sideimport { io } from 'socket.io-client';const socket = io();
```

```js
emit()
```

```js
emit()
```

```js
EventEmitter.emit()
```

```js
true
```

```js
socket.emit("event1").emit("event2");
```

```js
socket.emit("event1");socket.emit("event2");
```

```js
// mixed types were possiblesocket.join(42);io.to("42").emit("hello");// also workedsocket.join("42");io.to(42).emit("hello");
```

```js
// one waysocket.join("42");io.to("42").emit("hello");// or anothersocket.join(42);io.to(42).emit("hello");
```

```js
2.4.x
```

```js
// serverio.on("connection", (socket) => {  socket.onAny((event, ...args) => {});  socket.prependAny((event, ...args) => {});  socket.offAny(); // remove all listeners  socket.offAny(listener);  const listeners = socket.listenersAny();});// clientconst socket = io();socket.onAny((event, ...args) => {});socket.prependAny((event, ...args) => {});socket.offAny(); // remove all listenerssocket.offAny(listener);const listeners = socket.listenersAny();
```

```js
socket.volatile.emit("volatile event", "might or might not be sent");
```

```js
/socket.io/socket.io.msgpack.min.js
```

```js
// server-sideconst io = require("socket.io")(httpServer, {  parser: require("socket.io-msgpack-parser")});
```

```js
npm i -D @types/socket.io
```

```js
import { Server, Socket } from "socket.io";const io = new Server(8080);io.on("connection", (socket: Socket) => {    console.log(`connect ${socket.id}`);    socket.on("disconnect", () => {        console.log(`disconnect ${socket.id}`);    });});
```

```js
import { io } from "socket.io-client";const socket = io("/");socket.on("connect", () => {    console.log(`connect ${socket.id}`);});
```

```js
allowEIO3
```

```js
true
```

```js
socket.io@3.1.0
```

```js
const io = require("socket.io")({  allowEIO3: true // false by default});
```

```js
socket.io-redis@5
```

```js
socket.io@2
```

```js
socket.io-redis@6
```

```js
socket.io@3
```

```js
io.on("connection", (socket) => {  const version = socket.conn.protocol; // either 3 or 4});
```

```js
EIO
```

```js
allowEIO3
```

```js
false
```

```js
const io = require("socket.io")({  allowEIO3: false});
```

```js
allowEIO3
```

```js
false
```

```js
Unsupported protocol version
```

```js
stream_1.pipeline is not a function
```

```js
TypeError: stream_1.pipeline is not a function    at Function.sendFile (.../node_modules/socket.io/dist/index.js:249:26)    at Server.serve (.../node_modules/socket.io/dist/index.js:225:16)    at Server.srv.on (.../node_modules/socket.io/dist/index.js:186:22)    at emitTwo (events.js:126:13)    at Server.emit (events.js:214:7)    at parserOnIncoming (_http_server.js:602:12)    at HTTPParser.parserOnHeadersComplete (_http_common.js:116:23)
```

```js
error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.
```

```js
node_modules/socket.io/dist/namespace.d.ts(89,5): error TS2416: Property 'emit' in type 'Namespace' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => Namespace' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'Namespace' is not assignable to type 'boolean'.node_modules/socket.io/dist/socket.d.ts(84,5): error TS2416: Property 'emit' in type 'Socket' is not assignable to the same property in base type 'EventEmitter'.  Type '(ev: string, ...args: any[]) => this' is not assignable to type '(event: string | symbol, ...args: any[]) => boolean'.    Type 'this' is not assignable to type 'boolean'.      Type 'Socket' is not assignable to type 'boolean'.
```

```js
emit()
```

```js
3.0.1
```

```js
maxHttpBufferSize
```

```js
1MB
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at xxx/socket.io/?EIO=4&transport=polling&t=NMnp2WI. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing).
```

```js
Uncaught TypeError: packet.data is undefined
```

```js
Object literal may only specify known properties, and 'extraHeaders' does not exist in type 'ConnectOpts'
```

```js
@types/socket.io-client
```

```js
socket.io-client
```

```js
import { Server } from "socket.io";const io = new Server({  cors: {    origin: ["https://front.domain.com"],    credentials: true  }});
```

```js
import { io } from "socket.io-client";const socket = io("https://backend.domain.com", {  withCredentials: true});
```

```js
cors
```

```js
withCredentials
```

# https://socket.io/docs/v4/migrating-from-3-x-to-4-0

# Migrating from 3.x to 4.0

### Breaking changes​

### Configuration​

### New features​

### Known migration issues​

Here is the complete list of changes:

Previously, broadcasting to a given room (by calling io.to()) would mutate the io instance, which could lead to surprising behaviors, like:

Calling io.to() (or any other broadcast modifier) will now return an immutable instance.

Examples:

The format of the wsEngine option was updated in order to get rid of the following error:

Critical dependency: the request of a dependency is an expression

when bundling the server with webpack.

Before:

After:

Before version 16.0.0, the Swift client would not include the EIO query parameter in the HTTP requests, and the Socket.IO v3 server would infer EIO=4 by default.

That's why a Swift client v15 was not able to connect to the server, even when the compatibility mode was enabled (allowEIO3: true), unless you explicitly specified the query param:

The Socket.IO v4 server will now infer EIO=3 if the EIO query param is not included.

The default value of pingTimeout (used in the heartbeat mechanism) value was updated from 60000 to 5000 in socket.io@2.1.0 (March 2018).

The reasoning back then:

Some users experienced long delays between disconnection on the server-side and on the client-side. The "disconnect" event would take a long time to fire in the browser, probably due to a timer being delayed. Hence the change.

That being said, the current value (5s) caused unexpected disconnections when a big payload was sent over a slow network, because it prevents the ping-pong packets from being exchanged between the client and the server. This can also happen when a synchronous task blocks the server for more than 5 seconds.

The new value (20s) thus seems like a good balance between quick disconnection detection and tolerance to various delays.

Thanks to the awesome work of Sebastiaan Marynissen, you can now exclude a specific room when broadcasting:

The to() method now accepts an array of rooms.

Before:

After:

Some (long-awaited) methods were added:

The sockets variable in the example above is an array of objects exposing a subset of the usual Socket class:

Those methods share the same semantics as broadcasting, and the same filters apply:

Which makes all Socket instances of the "admin" namespace

disconnect.

Thanks to the awesome work of Maxime Kjaer, TypeScript users can now type the events sent between the client and the server.

First, you declare the signature of each event:

And you can now use them on the client side:

Your IDE should now properly infer the type of each argument:

Similarly on the server side (the ServerToClientEvents and ClientToServerEvents are reversed):

By default, the events are untyped and the arguments will be inferred as any.

And finally, thanks to the awesome work of KC Erb, the autoUnref option was added.

With autoUnref set to true (default: false), the Socket.IO client will allow the program to exit if there is no other active timer/TCP socket in the event system (even if the client is connected):

Note: this option only applies to Node.js clients.

The following expression:

was working in Socket.IO v3 but is now considered invalid, as the broadcast flag is useless because the to("room1") method already puts the Socket instance in broadcasting mode.

- Migrations
- Migrating from 3.x to 4.0
- Breaking changesio.to() is now immutablewsEngine option
- io.to() is now immutable
- wsEngine option
- ConfigurationEnsure compatibility with Swift v15 clientsThe default value of pingTimeout was increased
- Ensure compatibility with Swift v15 clients
- The default value of pingTimeout was increased
- New featuresAllow excluding specific rooms when broadcastingAllow to pass an array to io.to()Additional utility methodsTyped eventsautoUnref option
- Allow excluding specific rooms when broadcasting
- Allow to pass an array to io.to()
- Additional utility methods
- Typed events
- autoUnref option
- Known migration issues
- socketsJoin: makes the matching socket instances join the specified rooms
- socketsLeave: makes the matching socket instances leave the specified rooms
- disconnectSockets: makes the matching socket instances disconnect
- fetchSockets: returns the matching socket instances
- in the "room1" room (in("room1") or to("room1"))
- except the ones in "room2" (except("room2"))
- and only on the current Socket.IO server (local)
- cannot get emit of undefined
```js
io.to("room1");io.to("room2").emit(/* ... */); // also sent to room1// or with async/awaitio.to("room3").emit("details", await fetchDetails()); // random behavior: maybe in room3, maybe to all clients
```

```js
const operator1 = io.to("room1");const operator2 = operator1.to("room2");const operator3 = socket.broadcast;const operator4 = socket.to("room3").to("room4");operator1.emit(/* ... */); // only to clients in "room1"operator2.emit(/* ... */); // to clients in "room1" or in "room2"operator3.emit(/* ... */); // to all clients but the senderoperator4.emit(/* ... */); // to clients in "room3" or in "room4" but the sender
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: "eiows"});
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: require("eiows").Server});
```

```js
let manager = SocketManager(socketURL: URL(string: "http://localhost:8080")!, config: [  .log(true),  .connectParams(["EIO": "3"])])let socket = manager.defaultSocket
```

```js
io.except("room1").emit(/* ... */); // to all clients except the ones in "room1"io.to("room2").except("room3").emit(/* ... */); // to all clients in "room2" except the ones in "room3"socket.broadcast.except("room1").emit(/* ... */); // to all clients except the ones in "room1" and the sendersocket.except("room1").emit(/* ... */); // same as abovesocket.to("room4").except("room5").emit(/* ... */); // to all clients in "room4" except the ones in "room5" and the sender
```

```js
const rooms = ["room1", "room2", "room3"];for (const room of rooms) {  io.to(room);}// broadcast to clients in "room1", "room2" or "room3"// WARNING !!! this does not work anymore in v4, see the breaking change aboveio.emit(/* ... */);
```

```js
io.to(["room1", "room2", "room3"]).emit(/* ... */);socket.to(["room1", "room2", "room3"]).emit(/* ... */);
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances of the "admin" namespace in the "room1" room join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances of the "admin" namespace in the "room1" room leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances of the "admin" namespace in the "room1" room disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
// return all Socket instances of the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances of the "admin" namespace in the "room1" roomconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
io.of("/admin").in("room1").except("room2").local.disconnectSockets();
```

```js
interface ClientToServerEvents {  noArg: () => void;  basicEmit: (a: number, b: string, c: number[]) => void;}interface ServerToClientEvents {  withAck: (d: string, cb: (e: number) => void) => void;}
```

```js
import { io, Socket } from "socket.io-client";const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();socket.emit("noArg");socket.emit("basicEmit", 1, "2", [3]);socket.on("withAck", (d, cb) => {    cb(4);});
```

```js
import { Server } from "socket.io";const io = new Server<ClientToServerEvents, ServerToClientEvents>(3000);io.on("connection", (socket) => {    socket.on("noArg", () => {      // ...    });    socket.on("basicEmit", (a, b, c) => {      // ...    });    socket.emit("withAck", "42", (e) => {        console.log(e);    });});
```

```js
const socket = io({  autoUnref: true});
```

```js
socket.to("room1").broadcast.emit(/* ... */);
```

```js
// VALIDsocket.broadcast.emit(/* ... */); // to all clients but the sendersocket.to("room1").emit(/* ... */); // to clients in "room1" but the sender// VALID (but useless 'broadcast' flag)socket.broadcast.to("room1").emit(/* ... */);// INVALIDsocket.to("room1").broadcast.emit(/* ... */);
```

```js
allowEIO3: true
```

```js
io.to()
```

```js
wsEngine
```

```js
pingTimeout
```

```js
io.to()
```

```js
autoUnref
```

```js
io.to()
```

```js
io.to()
```

```js
io.to("room1");io.to("room2").emit(/* ... */); // also sent to room1// or with async/awaitio.to("room3").emit("details", await fetchDetails()); // random behavior: maybe in room3, maybe to all clients
```

```js
io.to()
```

```js
const operator1 = io.to("room1");const operator2 = operator1.to("room2");const operator3 = socket.broadcast;const operator4 = socket.to("room3").to("room4");operator1.emit(/* ... */); // only to clients in "room1"operator2.emit(/* ... */); // to clients in "room1" or in "room2"operator3.emit(/* ... */); // to all clients but the senderoperator4.emit(/* ... */); // to clients in "room3" or in "room4" but the sender
```

```js
wsEngine
```

```js
wsEngine
```

```js
Critical dependency: the request of a dependency is an expression
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: "eiows"});
```

```js
const io = require("socket.io")(httpServer, {  wsEngine: require("eiows").Server});
```

```js
EIO
```

```js
EIO=4
```

```js
allowEIO3: true
```

```js
let manager = SocketManager(socketURL: URL(string: "http://localhost:8080")!, config: [  .log(true),  .connectParams(["EIO": "3"])])let socket = manager.defaultSocket
```

```js
EIO=3
```

```js
EIO
```

```js
pingTimeout
```

```js
pingTimeout
```

```js
socket.io@2.1.0
```

```js
io.except("room1").emit(/* ... */); // to all clients except the ones in "room1"io.to("room2").except("room3").emit(/* ... */); // to all clients in "room2" except the ones in "room3"socket.broadcast.except("room1").emit(/* ... */); // to all clients except the ones in "room1" and the sendersocket.except("room1").emit(/* ... */); // same as abovesocket.to("room4").except("room5").emit(/* ... */); // to all clients in "room4" except the ones in "room5" and the sender
```

```js
io.to()
```

```js
to()
```

```js
const rooms = ["room1", "room2", "room3"];for (const room of rooms) {  io.to(room);}// broadcast to clients in "room1", "room2" or "room3"// WARNING !!! this does not work anymore in v4, see the breaking change aboveio.emit(/* ... */);
```

```js
io.to(["room1", "room2", "room3"]).emit(/* ... */);socket.to(["room1", "room2", "room3"]).emit(/* ... */);
```

```js
socketsJoin
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances of the "admin" namespace in the "room1" room join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");
```

```js
socketsLeave
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances of the "admin" namespace in the "room1" room leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");
```

```js
disconnectSockets
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances of the "admin" namespace in the "room1" room disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
fetchSockets
```

```js
// return all Socket instances of the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances of the "admin" namespace in the "room1" roomconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
sockets
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
io.of("/admin").in("room1").except("room2").local.disconnectSockets();
```

```js
in("room1")
```

```js
to("room1")
```

```js
except("room2")
```

```js
local
```

```js
interface ClientToServerEvents {  noArg: () => void;  basicEmit: (a: number, b: string, c: number[]) => void;}interface ServerToClientEvents {  withAck: (d: string, cb: (e: number) => void) => void;}
```

```js
import { io, Socket } from "socket.io-client";const socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();socket.emit("noArg");socket.emit("basicEmit", 1, "2", [3]);socket.on("withAck", (d, cb) => {    cb(4);});
```

```js
ServerToClientEvents
```

```js
ClientToServerEvents
```

```js
import { Server } from "socket.io";const io = new Server<ClientToServerEvents, ServerToClientEvents>(3000);io.on("connection", (socket) => {    socket.on("noArg", () => {      // ...    });    socket.on("basicEmit", (a, b, c) => {      // ...    });    socket.emit("withAck", "42", (e) => {        console.log(e);    });});
```

```js
any
```

```js
autoUnref
```

```js
autoUnref
```

```js
autoUnref
```

```js
const socket = io({  autoUnref: true});
```

```js
cannot get emit of undefined
```

```js
socket.to("room1").broadcast.emit(/* ... */);
```

```js
broadcast
```

```js
to("room1")
```

```js
// VALIDsocket.broadcast.emit(/* ... */); // to all clients but the sendersocket.to("room1").emit(/* ... */); // to clients in "room1" but the sender// VALID (but useless 'broadcast' flag)socket.broadcast.to("room1").emit(/* ... */);// INVALIDsocket.to("room1").broadcast.emit(/* ... */);
```

# https://socket.io/docs/v4/mongo-adapter

# MongoDB adapter

## How it works​

## Supported features​

## Installation​

## Usage​

## Options​

## Common questions​

## Latest releases​

## Emitter​

### Usage with a capped collection​

### Usage with a TTL index​

### Do I still need to enable sticky sessions when using the MongoDB adapter?​

### What happens when the MongoDB cluster is down?​

### Installation​

### Usage​

The MongoDB adapter relies on MongoDB's Change Streams (and thus requires a replica set or a sharded cluster).

Every packet that is sent to multiple clients (e.g. io.to("room1").emit() or socket.broadcast.emit()) is:

The source code of this adapter can be found here.

For TypeScript users, you might also need @types/mongodb.

Broadcasting packets within a Socket.IO cluster is achieved by creating MongoDB documents and using a change stream on each Socket.IO server.

There are two ways to clean up the documents in MongoDB:

Yes. Failing to do so will result in HTTP 400 responses (you are reaching a server that is not aware of the Socket.IO session).

More information can be found here.

In case the connection to the MongoDB cluster is severed, the behavior will depend on the value of the bufferMaxEntries option of the MongoDB client:

Documentation: http://mongodb.github.io/node-mongodb-native/3.6/api/global.html#MongoClientOptions

Complete changelog

The MongoDB emitter allows sending packets to the connected clients from another Node.js process:

Please refer to the cheatsheet here.

- Adapters
- MongoDB adapter
- sent to all matching clients connected to the current server
- inserted in a MongoDB capped collection, and received by the other Socket.IO servers of the cluster
- a capped collection
- a TTL index
- if its value is -1 (default), the packets will be buffered until reconnection.
- if its value is 0, the packets will only be sent to the clients that are connected to the current server.
```js
npm install @socket.io/mongo-adapter mongodb
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/mongo-adapter";import { MongoClient } from "mongodb";const DB = "mydb";const COLLECTION = "socket.io-adapter-events";const io = new Server();const mongoClient = new MongoClient("mongodb://localhost:27017/?replicaSet=rs0");await mongoClient.connect();try {  await mongoClient.db(DB).createCollection(COLLECTION, {    capped: true,    size: 1e6  });} catch (e) {  // collection already exists}const mongoCollection = mongoClient.db(DB).collection(COLLECTION);io.adapter(createAdapter(mongoCollection));io.listen(3000);
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/mongo-adapter";import { MongoClient } from "mongodb";const DB = "mydb";const COLLECTION = "socket.io-adapter-events";const io = new Server();const mongoClient = new MongoClient("mongodb://localhost:27017/?replicaSet=rs0");await mongoClient.connect();const mongoCollection = mongoClient.db(DB).collection(COLLECTION);await mongoCollection.createIndex(  { createdAt: 1 },  { expireAfterSeconds: 3600, background: true });io.adapter(createAdapter(mongoCollection, {  addCreatedAtField: true}));io.listen(3000);
```

```js
npm install @socket.io/mongo-emitter mongodb
```

```js
const { Emitter } = require("@socket.io/mongo-emitter");const { MongoClient } = require("mongodb");const mongoClient = new MongoClient("mongodb://localhost:27017/?replicaSet=rs0");const main = async () => {  await mongoClient.connect();  const mongoCollection = mongoClient.db("mydb").collection("socket.io-adapter-events");  const emitter = new Emitter(mongoCollection);  setInterval(() => {    emitter.emit("ping", new Date());  }, 1000);}main();
```

```js
io.to("room1").emit()
```

```js
socket.broadcast.emit()
```

```js
socket.io
```

```js
4.0.0
```

```js
0.1.0
```

```js
4.1.0
```

```js
0.1.0
```

```js
4.5.0
```

```js
0.2.0
```

```js
4.6.0
```

```js
0.3.0
```

```js
npm install @socket.io/mongo-adapter mongodb
```

```js
@types/mongodb
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/mongo-adapter";import { MongoClient } from "mongodb";const DB = "mydb";const COLLECTION = "socket.io-adapter-events";const io = new Server();const mongoClient = new MongoClient("mongodb://localhost:27017/?replicaSet=rs0");await mongoClient.connect();try {  await mongoClient.db(DB).createCollection(COLLECTION, {    capped: true,    size: 1e6  });} catch (e) {  // collection already exists}const mongoCollection = mongoClient.db(DB).collection(COLLECTION);io.adapter(createAdapter(mongoCollection));io.listen(3000);
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/mongo-adapter";import { MongoClient } from "mongodb";const DB = "mydb";const COLLECTION = "socket.io-adapter-events";const io = new Server();const mongoClient = new MongoClient("mongodb://localhost:27017/?replicaSet=rs0");await mongoClient.connect();const mongoCollection = mongoClient.db(DB).collection(COLLECTION);await mongoCollection.createIndex(  { createdAt: 1 },  { expireAfterSeconds: 3600, background: true });io.adapter(createAdapter(mongoCollection, {  addCreatedAtField: true}));io.listen(3000);
```

```js
uid
```

```js
v0.1.0
```

```js
requestsTimeout
```

```js
fetchSockets()
```

```js
serverSideEmit()
```

```js
5000
```

```js
v0.1.0
```

```js
heartbeatInterval
```

```js
5000
```

```js
v0.1.0
```

```js
heartbeatTimeout
```

```js
10000
```

```js
v0.1.0
```

```js
addCreatedAtField
```

```js
createdAt
```

```js
false
```

```js
v0.2.0
```

```js
bufferMaxEntries
```

```js
0.3.2
```

```js
0.3.1...0.3.2
```

```js
0.3.1
```

```js
0.3.0...0.3.1
```

```js
0.3.0
```

```js
0.2.1...0.3.0
```

```js
0.2.1
```

```js
0.2.0...0.2.1
```

```js
0.2.0
```

```js
0.1.0...0.2.0
```

```js
0.1.0
```

```js
npm install @socket.io/mongo-emitter mongodb
```

```js
const { Emitter } = require("@socket.io/mongo-emitter");const { MongoClient } = require("mongodb");const mongoClient = new MongoClient("mongodb://localhost:27017/?replicaSet=rs0");const main = async () => {  await mongoClient.connect();  const mongoCollection = mongoClient.db("mydb").collection("socket.io-adapter-events");  const emitter = new Emitter(mongoCollection);  setInterval(() => {    emitter.emit("ping", new Date());  }, 1000);}main();
```

# https://socket.io/docs/v4/namespaces

# Namespaces

## Introduction​

## Main namespace​

## Custom namespaces​

## Client initialization​

## Dynamic namespaces​

A Namespace is a communication channel that allows you to split the logic of your application over a single shared connection (also called "multiplexing").

Each namespace has its own:

Possible use cases:

Until now, you interacted with the main namespace, called /. The io instance inherits all of its methods:

Some tutorials may also mention io.sockets, it's simply an alias for io.of("/").

To set up a custom namespace, you can call the of function on the server-side:

Same-origin version:

Cross-origin/Node.js version:

In the example above, only one WebSocket connection will be established, and the packets will automatically be routed to the right namespace.

Please note that multiplexing will be disabled in the following cases:

It is also possible to dynamically create namespaces, either with a regular expression:

or with a function:

You can have access to the new namespace in the connection event:

The return value of the of() method is what we call the parent namespace, from which you can:

The middleware will automatically be registered on each child namespace.

Existing namespaces have priority over dynamic namespaces. For example:

- Advanced
- Namespaces
- event handlers
- rooms
- middlewares
- you want to create a special namespace that only authorized users have access to, so the logic related to those users is separated from the rest of the application
- your application has multiple tenants so you want to dynamically create one namespace per tenant
- multiple creation for the same namespace
- different domains
- usage of the forceNew option
- register middlewares
- broadcast events
```js
io.of("/orders").on("connection", (socket) => {  socket.on("order:list", () => {});  socket.on("order:create", () => {});});io.of("/users").on("connection", (socket) => {  socket.on("user:list", () => {});});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.on("connection", (socket) => {  socket.join("room1");  orderNamespace.to("room1").emit("hello");});const userNamespace = io.of("/users");userNamespace.on("connection", (socket) => {  socket.join("room1"); // distinct from the room in the "orders" namespace  userNamespace.to("room1").emit("holà");});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.use((socket, next) => {  // ensure the socket has access to the "orders" namespace, and then  next();});const userNamespace = io.of("/users");userNamespace.use((socket, next) => {  // ensure the socket has access to the "users" namespace, and then  next();});
```

```js
const adminNamespace = io.of("/admin");adminNamespace.use((socket, next) => {  // ensure the user has sufficient rights  next();});adminNamespace.on("connection", socket => {  socket.on("delete user", () => {    // ...  });});
```

```js
const workspaces = io.of(/^\/\w+$/);workspaces.on("connection", socket => {  const workspace = socket.nsp;  workspace.emit("hello");});
```

```js
io.on("connection", (socket) => {});io.use((socket, next) => { next() });io.emit("hello");// are actually equivalent toio.of("/").on("connection", (socket) => {});io.of("/").use((socket, next) => { next() });io.of("/").emit("hello");
```

```js
io.sockets === io.of("/")
```

```js
const nsp = io.of("/my-namespace");nsp.on("connection", socket => {  console.log("someone connected");});nsp.emit("hi", "everyone!");
```

```js
const socket = io(); // or io("/"), the main namespaceconst orderSocket = io("/orders"); // the "orders" namespaceconst userSocket = io("/users"); // the "users" namespace
```

```js
const socket = io("https://example.com"); // or io("https://example.com/"), the main namespaceconst orderSocket = io("https://example.com/orders"); // the "orders" namespaceconst userSocket = io("https://example.com/users"); // the "users" namespace
```

```js
const socket1 = io();const socket2 = io(); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io("https://first.example.com");const socket2 = io("https://second.example.com"); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io();const socket2 = io("/admin", { forceNew: true }); // no multiplexing, two distinct WebSocket connections
```

```js
io.of(/^\/dynamic-\d+$/);
```

```js
io.of((name, auth, next) => {  next(null, true); // or false, when the creation is denied});
```

```js
io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const namespace = socket.nsp;});
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.use((socket, next) => { next() });
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.emit("hello"); // will be sent to users in /dynamic-1, /dynamic-2, ...
```

```js
// register "dynamic-101" namespaceio.of("/dynamic-101");io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  // will not be called for a connection on the "dynamic-101" namespace});
```

```js
io.of("/orders").on("connection", (socket) => {  socket.on("order:list", () => {});  socket.on("order:create", () => {});});io.of("/users").on("connection", (socket) => {  socket.on("user:list", () => {});});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.on("connection", (socket) => {  socket.join("room1");  orderNamespace.to("room1").emit("hello");});const userNamespace = io.of("/users");userNamespace.on("connection", (socket) => {  socket.join("room1"); // distinct from the room in the "orders" namespace  userNamespace.to("room1").emit("holà");});
```

```js
const orderNamespace = io.of("/orders");orderNamespace.use((socket, next) => {  // ensure the socket has access to the "orders" namespace, and then  next();});const userNamespace = io.of("/users");userNamespace.use((socket, next) => {  // ensure the socket has access to the "users" namespace, and then  next();});
```

```js
const adminNamespace = io.of("/admin");adminNamespace.use((socket, next) => {  // ensure the user has sufficient rights  next();});adminNamespace.on("connection", socket => {  socket.on("delete user", () => {    // ...  });});
```

```js
const workspaces = io.of(/^\/\w+$/);workspaces.on("connection", socket => {  const workspace = socket.nsp;  workspace.emit("hello");});
```

```js
io.on("connection", (socket) => {});io.use((socket, next) => { next() });io.emit("hello");// are actually equivalent toio.of("/").on("connection", (socket) => {});io.of("/").use((socket, next) => { next() });io.of("/").emit("hello");
```

```js
io.sockets
```

```js
io.of("/")
```

```js
io.sockets === io.of("/")
```

```js
const nsp = io.of("/my-namespace");nsp.on("connection", socket => {  console.log("someone connected");});nsp.emit("hi", "everyone!");
```

```js
const socket = io(); // or io("/"), the main namespaceconst orderSocket = io("/orders"); // the "orders" namespaceconst userSocket = io("/users"); // the "users" namespace
```

```js
const socket = io("https://example.com"); // or io("https://example.com/"), the main namespaceconst orderSocket = io("https://example.com/orders"); // the "orders" namespaceconst userSocket = io("https://example.com/users"); // the "users" namespace
```

```js
const socket1 = io();const socket2 = io(); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io("https://first.example.com");const socket2 = io("https://second.example.com"); // no multiplexing, two distinct WebSocket connections
```

```js
const socket1 = io();const socket2 = io("/admin", { forceNew: true }); // no multiplexing, two distinct WebSocket connections
```

```js
io.of(/^\/dynamic-\d+$/);
```

```js
io.of((name, auth, next) => {  next(null, true); // or false, when the creation is denied});
```

```js
connection
```

```js
io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const namespace = socket.nsp;});
```

```js
of()
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.use((socket, next) => { next() });
```

```js
const parentNamespace = io.of(/^\/dynamic-\d+$/);parentNamespace.emit("hello"); // will be sent to users in /dynamic-1, /dynamic-2, ...
```

```js
// register "dynamic-101" namespaceio.of("/dynamic-101");io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  // will not be called for a connection on the "dynamic-101" namespace});
```

# https://socket.io/docs/v4/performance-tuning

# Performance tuning

## At the Socket.IO level​

## At the OS level​

### Install ws native add-ons​

### Use another WebSocket server implementation​

### Use a custom parser​

### Discard the initial HTTP request​

Here are some tips to improve the performance of your Socket.IO server:

You might also be interested in scaling to multiple nodes.

Since, in most cases, the Socket.IO connection will be established with WebSocket, the performance of your Socket.IO server will be strongly linked to the performance of the underlying WebSocket server (ws, by default).

ws comes with two optional binary add-ons which improve certain operations. Prebuilt binaries are available for the most popular platforms so you don't necessarily need to have a C++ compiler installed on your machine.

To install those packages:

Please note that these packages are optional, the WebSocket server will fallback to the Javascript implementation if they are not available. More information can be found here.

For example, you can use the eiows package, which is a fork of the (now deprecated) uws package:

And then use the wsEngine option:

If you send binary data over the Socket.IO connection, using a custom parser like the one based on msgpack might be interesting, as by default each buffer will be sent in its own WebSocket frame.

Usage:

Server

Client

By default, a reference to the first HTTP request of each session is kept in memory. This reference is needed when working with express-session for example (see here), but can be discarded to save memory:

Before:

After:

There are lots of good articles on how to tune your OS to accept a large number of connections. Please see this one for example.

While load testing your Socket.IO server, you will likely reach the two following limits:

If you can't go over 1000 concurrent connections (new clients are not able to connect), you have most certainly reached the maximum number of open files:

To increase this number, create a new file /etc/security/limits.d/custom.conf with the following content (requires root privileges):

And then reload your session. Your new limit should now be updated:

If you can't go over 28000 concurrent connections, you have most certainly reached the maximum number of available local ports:

To increase this number, create a new file /etc/sysctl.d/net.ipv4.ip_local_port_range.conf with the following content (again, requires root privileges):

Note: we used 10000 as a lower bound so it does not include the ports that are used by the services on the machine (like 5432 for a PostgreSQL server), but you can totally use a lower value (down to 1024).

Once you reboot your machine, you will now be able to happily go to 55k concurrent connections (per incoming IP).

See also:

- Advanced
- Performance tuning
- at the Socket.IO level
- at the OS level
- bufferutil: Allows to efficiently perform operations such as masking and unmasking the data payload of the WebSocket frames.
- utf-8-validate: Allows to efficiently check if a message contains valid UTF-8 as required by the spec.
- maximum number of open files
- maximum number of available local ports
- https://unix.stackexchange.com/a/130798
```js
$ npm install --save-optional bufferutil utf-8-validate
```

```js
$ npm install eiows
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const httpServer = createServer();const io = new Server(httpServer, {  wsEngine: require("eiows").Server});
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const parser = require("socket.io-msgpack-parser");const httpServer = createServer();const io = new Server(httpServer, {  parser});
```

```js
const { io } = require("socket.io-client");const parser = require("socket.io-msgpack-parser");const socket = io("https://example.com", {  parser});
```

```js
io.engine.on("connection", (rawSocket) => {  rawSocket.request = null;});
```

```js
$ ulimit -n1024
```

```js
* soft nofile 1048576* hard nofile 1048576
```

```js
$ ulimit -n1048576
```

```js
$ cat /proc/sys/net/ipv4/ip_local_port_range32768   60999
```

```js
net.ipv4.ip_local_port_range = 10000 65535
```

```js
$ npm install --save-optional bufferutil utf-8-validate
```

```js
$ npm install eiows
```

```js
wsEngine
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const httpServer = createServer();const io = new Server(httpServer, {  wsEngine: require("eiows").Server});
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const parser = require("socket.io-msgpack-parser");const httpServer = createServer();const io = new Server(httpServer, {  parser});
```

```js
const { io } = require("socket.io-client");const parser = require("socket.io-msgpack-parser");const socket = io("https://example.com", {  parser});
```

```js
express-session
```

```js
io.engine.on("connection", (rawSocket) => {  rawSocket.request = null;});
```

```js
$ ulimit -n1024
```

```js
/etc/security/limits.d/custom.conf
```

```js
* soft nofile 1048576* hard nofile 1048576
```

```js
$ ulimit -n1048576
```

```js
$ cat /proc/sys/net/ipv4/ip_local_port_range32768   60999
```

```js
/etc/sysctl.d/net.ipv4.ip_local_port_range.conf
```

```js
net.ipv4.ip_local_port_range = 10000 65535
```

```js
10000
```

```js
5432
```

```js
1024
```

# https://socket.io/docs/v4/pm2

# Usage with PM2

## Installation​

## Usage​

## How it works​

PM2 is a production process manager for Node.js applications with a built-in load balancer. It allows you to keep applications alive forever, to reload them without downtime and to facilitate common system admin tasks.

You can find its documentation here: https://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/

To scale a Socket.IO server with PM2, there are three solutions:

Though in that case, there will be no fallback to HTTP long-polling if the WebSocket connection cannot be established.

use a distinct port for each worker, and a load-balancer like nginx in front of them

use @socket.io/pm2

If pm2 is already installed, you will have to remove it first:

@socket.io/pm2 can be used as a drop-in replacement for pm2, and supports all the commands of the class pm2 utility.

The only difference comes from this commit.

worker.js

ecosystem.config.js

And then run pm2 start ecosystem.config.js (or pm2 start worker.js -i 0). That's it! You can now reach the Socket.IO cluster on port 8080.

When scaling to multiple nodes, there are two things to do:

In order to achieve this, @socket.io/pm2 includes two additional packages:

The only difference with pm2 comes from this commit:

Please note that if you have several hosts each running a PM2 cluster, you will have to use another adapter, like the Redis adapter.

The source code of the fork can be found here. We will try to closely follow the releases of the pm2 package.

- Advanced
- Usage with PM2
- disable HTTP long-polling on the client-side
- use a distinct port for each worker, and a load-balancer like nginx in front of them
- use @socket.io/pm2
- enable sticky sessions, so that the HTTP requests of a Socket.IO session are routed to the same worker
- use a custom adapter, so that the packets are broadcast to all clients, even if they are connected to another worker
- @socket.io/sticky
- @socket.io/cluster-adapter
- the God process now creates its own HTTP server and routes the HTTP requests to the right worker
- the God process also relays the packets between the workers, so that io.emit() correctly reaches all clients
```js
const socket = io({  transports: ["websocket"]});
```

```js
npm install -g @socket.io/pm2
```

```js
npm remove -g pm2
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const { createAdapter } = require("@socket.io/cluster-adapter");const { setupWorker } = require("@socket.io/sticky");const httpServer = createServer();const io = new Server(httpServer);io.adapter(createAdapter());setupWorker(io);io.on("connection", (socket) => {  console.log(`connect ${socket.id}`);});
```

```js
module.exports = {  apps : [{    script    : "worker.js",    instances : "max",    exec_mode : "cluster"  }]}
```

```js
const socket = io({  transports: ["websocket"]});
```

```js
@socket.io/pm2
```

```js
npm install -g @socket.io/pm2
```

```js
pm2
```

```js
npm remove -g pm2
```

```js
@socket.io/pm2
```

```js
pm2
```

```js
pm2
```

```js
worker.js
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const { createAdapter } = require("@socket.io/cluster-adapter");const { setupWorker } = require("@socket.io/sticky");const httpServer = createServer();const io = new Server(httpServer);io.adapter(createAdapter());setupWorker(io);io.on("connection", (socket) => {  console.log(`connect ${socket.id}`);});
```

```js
ecosystem.config.js
```

```js
module.exports = {  apps : [{    script    : "worker.js",    instances : "max",    exec_mode : "cluster"  }]}
```

```js
pm2 start ecosystem.config.js
```

```js
pm2 start worker.js -i 0
```

```js
@socket.io/pm2
```

```js
@socket.io/sticky
```

```js
@socket.io/cluster-adapter
```

```js
pm2
```

```js
io.emit()
```

```js
pm2
```

# https://socket.io/docs/v4/postgres-adapter

# Postgres adapter

## How it works​

## Supported features​

## Installation​

## Usage​

## Options​

## Common questions​

## Latest releases​

## Emitter​

### Do I still need to enable sticky sessions when using the Postgres adapter?​

### What happens when the Postgres server is down?​

### Installation​

### Usage​

### Latest releases​

The Postgres adapter relies on the NOTIFY and LISTEN commands.

Every packet that is sent to multiple clients (e.g. io.to("room1").emit() or socket.broadcast.emit()) is:

The source code of this adapter can be found here.

For TypeScript users, you might also need @types/pg.

Yes. Failing to do so will result in HTTP 400 responses (you are reaching a server that is not aware of the Socket.IO session).

More information can be found here.

In case the connection to the Postgres server is severed, the packets will only be sent to the clients that are connected to the current server.

Complete changelog

The Postgres emitter allows sending packets to the connected clients from another Node.js process:

Please refer to the cheatsheet here.

Complete changelog

- Adapters
- Postgres adapter
- sent to all matching clients connected to the current server
- if the packet contains binary data or is above the 8000 bytes limit, the packet is:encoded with msgpack and inserted in an auxiliary tablethe row ID is sent within a NOTIFY commandthis row ID is received by the other Socket.IO servers of the cluster, which query the table, decode the packet and then broadcast it to their own set of connected clients
- encoded with msgpack and inserted in an auxiliary table
- the row ID is sent within a NOTIFY command
- this row ID is received by the other Socket.IO servers of the cluster, which query the table, decode the packet and then broadcast it to their own set of connected clients
- else, the packet is simply sent within a NOTIFY command and received by the other Socket.IO servers of the cluster
```js
npm install @socket.io/postgres-adapter pg
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/postgres-adapter";import pg from "pg";const io = new Server();const pool = new pg.Pool({  user: "postgres",  host: "localhost",  database: "postgres",  password: "changeit",  port: 5432,});pool.query(`  CREATE TABLE IF NOT EXISTS socket_io_attachments (      id          bigserial UNIQUE,      created_at  timestamptz DEFAULT NOW(),      payload     bytea  );`);pool.on("error", (err) => {  console.error("Postgres error", err);});io.adapter(createAdapter(pool));io.listen(3000);
```

```js
npm install @socket.io/postgres-emitter pg
```

```js
const { Emitter } = require("@socket.io/postgres-emitter");const { Pool } = require("pg");const pool = new Pool({  user: "postgres",  host: "localhost",  database: "postgres",  password: "changeit",  port: 5432,});const emitter = new Emitter(pool);setInterval(() => {  emitter.emit("ping", new Date());}, 1000);
```

```js
io.to("room1").emit()
```

```js
socket.broadcast.emit()
```

```js
socket.io
```

```js
4.0.0
```

```js
0.1.0
```

```js
4.1.0
```

```js
0.1.0
```

```js
4.5.0
```

```js
0.3.0
```

```js
4.6.0
```

```js
npm install @socket.io/postgres-adapter pg
```

```js
@types/pg
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/postgres-adapter";import pg from "pg";const io = new Server();const pool = new pg.Pool({  user: "postgres",  host: "localhost",  database: "postgres",  password: "changeit",  port: 5432,});pool.query(`  CREATE TABLE IF NOT EXISTS socket_io_attachments (      id          bigserial UNIQUE,      created_at  timestamptz DEFAULT NOW(),      payload     bytea  );`);pool.on("error", (err) => {  console.error("Postgres error", err);});io.adapter(createAdapter(pool));io.listen(3000);
```

```js
uid
```

```js
channelPrefix
```

```js
socket.io
```

```js
tableName
```

```js
socket_io_attachments
```

```js
payloadThreshold
```

```js
8000
```

```js
requestsTimeout
```

```js
fetchSockets()
```

```js
serverSideEmit()
```

```js
5000
```

```js
heartbeatInterval
```

```js
5000
```

```js
heartbeatTimeout
```

```js
10000
```

```js
cleanupInterval
```

```js
30000
```

```js
0.4.0
```

```js
0.3.1...0.4.0
```

```js
0.3.1
```

```js
0.3.0...0.3.1
```

```js
0.3.0
```

```js
0.2.0...0.3.0
```

```js
0.2.0
```

```js
0.1.1...0.2.0
```

```js
0.1.1
```

```js
0.1.0...0.1.1
```

```js
0.1.0
```

```js
npm install @socket.io/postgres-emitter pg
```

```js
const { Emitter } = require("@socket.io/postgres-emitter");const { Pool } = require("pg");const pool = new Pool({  user: "postgres",  host: "localhost",  database: "postgres",  password: "changeit",  port: 5432,});const emitter = new Emitter(pool);setInterval(() => {  emitter.emit("ping", new Date());}, 1000);
```

```js
0.1.0
```

# https://socket.io/docs/v4/redis-adapter

# Redis adapter

## How it works​

## Supported features​

## Installation​

## Compatibility table​

## Usage​

## Options​

## Common questions​

## Migrating from socket.io-redis​

## Latest releases​

## Emitter​

### With the redis package​

### With the redis package and a Redis cluster​

### With the ioredis package​

### With the ioredis package and a Redis cluster​

### With Redis sharded Pub/Sub​

### Default adapter​

### Sharded adapter​

### Is there any data stored in Redis?​

### Do I still need to enable sticky sessions when using the Redis adapter?​

### What happens when the Redis server is down?​

### Installation​

### Usage​

### Migrating from socket.io-emitter​

### Latest releases​

The Redis adapter relies on the Redis Pub/Sub mechanism.

Every packet that is sent to multiple clients (e.g. io.to("room1").emit() or socket.broadcast.emit()) is:

The source code of this adapter can be found here.

For new developments, we recommend using the sharded adapter, which takes advantage of the sharded Pub/Sub feature introduced in Redis 7.0.

The redis package seems to have problems restoring the Redis subscriptions after reconnection:

You may want to use the ioredis package instead.

Sharded Pub/Sub was introduced in Redis 7.0 in order to help scaling the usage of Pub/Sub in cluster mode.

Reference: https://redis.io/docs/interact/pubsub/#sharded-pubsub

A dedicated adapter can be created with the createShardedAdapter() method:

Minimum requirements:

It is not currently possible to use the sharded adapter with the ioredis package and a Redis cluster (reference).

Setting the publishOnSpecificResponseChannel option to true is more efficient since the responses (for example when calling fetchSockets() or serverSideEmit()) are only sent to the requesting server, and not to all the servers.

However, it currently defaults to false for backward-compatibility.

Available values for the subscriptionMode option:

No, the Redis adapter uses the Pub/Sub mechanism to forward the packets between the Socket.IO servers, so there are no keys stored in Redis.

Yes. Failing to do so will result in HTTP 400 responses (you are reaching a server that is not aware of the Socket.IO session).

More information can be found here.

In case the connection to the Redis server is severed, the packets will only be sent to the clients that are connected to the current server.

The package was renamed from socket.io-redis to @socket.io/redis-adapter in v7, in order to match the name of the Redis emitter (@socket.io/redis-emitter).

To migrate to the new package, you'll need to make sure to provide your own Redis clients, as the package will no longer create Redis clients on behalf of the user.

Before:

After:

The communication protocol between the Socket.IO servers has not been updated, so you can have some servers with socket.io-redis and some others with @socket.io/redis-adapter at the same time.

Complete changelog

The Redis emitter allows sending packets to the connected clients from another Node.js process:

This emitter is also available in several languages:

Note: with redis@3, calling connect() on the Redis client is not needed:

Please refer to the cheatsheet here.

The package was renamed from socket.io-emitter to @socket.io/redis-emitter in v4, in order to better reflect the relationship with Redis.

To migrate to the new package, you'll need to make sure to provide your own Redis clients, as the package will no longer create Redis clients on behalf of the user.

Before:

After:

Complete changelog

- Adapters
- Redis adapter
- sent to all matching clients connected to the current server
- published in a Redis channel, and received by the other Socket.IO servers of the cluster
- https://github.com/redis/node-redis/issues/2155
- https://github.com/redis/node-redis/issues/1252
- Redis 7.0
- redis@4.6.0
- Javascript: https://github.com/socketio/socket.io-redis-emitter
- Java: https://github.com/sunsus/socket.io-java-emitter
- Python: https://pypi.org/project/socket.io-emitter/
- PHP: https://github.com/rase-/socket.io-php-emitter
- Golang: https://github.com/yosuke-furukawa/socket.io-go-emitter
- Perl: https://metacpan.org/pod/SocketIO::Emitter
- Rust: https://github.com/epli2/socketio-rust-emitter
```js
npm install @socket.io/redis-adapter
```

```js
import { createClient } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = createClient({ url: "redis://localhost:6379" });const subClient = pubClient.duplicate();await Promise.all([  pubClient.connect(),  subClient.connect()]);const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { createCluster } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = createCluster({  rootNodes: [    {      url: "redis://localhost:7000",    },    {      url: "redis://localhost:7001",    },    {      url: "redis://localhost:7002",    },  ],});const subClient = pubClient.duplicate();await Promise.all([  pubClient.connect(),  subClient.connect()]);const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { Redis } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = new Redis();const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { Cluster } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = new Cluster([  {    host: "localhost",    port: 7000,  },  {    host: "localhost",    port: 7001,  },  {    host: "localhost",    port: 7002,  },]);const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { Server } from "socket.io";import { createClient } from "redis";import { createShardedAdapter } from "@socket.io/redis-adapter";const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();await Promise.all([  pubClient.connect(),  subClient.connect()]);const io = new Server({  adapter: createShardedAdapter(pubClient, subClient)});io.listen(3000);
```

```js
const redisAdapter = require("socket.io-redis");io.adapter(redisAdapter({ host: "localhost", port: 6379 }));
```

```js
const { createClient } = require("redis");const { createAdapter } = require("@socket.io/redis-adapter");const pubClient = createClient({ url: "redis://localhost:6379" });const subClient = pubClient.duplicate();io.adapter(createAdapter(pubClient, subClient));
```

```js
npm install @socket.io/redis-emitter redis
```

```js
import { Emitter } from "@socket.io/redis-emitter";import { createClient } from "redis";const redisClient = createClient({ url: "redis://localhost:6379" });redisClient.connect().then(() => {  const emitter = new Emitter(redisClient);  setInterval(() => {    emitter.emit("time", new Date);  }, 5000);});
```

```js
import { Emitter } from "@socket.io/redis-emitter";import { createClient } from "redis";const redisClient = createClient({ url: "redis://localhost:6379" });const emitter = new Emitter(redisClient);setInterval(() => {  emitter.emit("time", new Date);}, 5000);
```

```js
const io = require("socket.io-emitter")({ host: "127.0.0.1", port: 6379 });
```

```js
const { Emitter } = require("@socket.io/redis-emitter");const { createClient } = require("redis");const redisClient = createClient();const io = new Emitter(redisClient);
```

```js
io.to("room1").emit()
```

```js
socket.broadcast.emit()
```

```js
socket.io
```

```js
4.0.0
```

```js
6.1.0
```

```js
4.1.0
```

```js
7.0.0
```

```js
4.5.0
```

```js
7.2.0
```

```js
4.6.0
```

```js
npm install @socket.io/redis-adapter
```

```js
redis
```

```js
redis
```

```js
ioredis
```

```js
import { createClient } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = createClient({ url: "redis://localhost:6379" });const subClient = pubClient.duplicate();await Promise.all([  pubClient.connect(),  subClient.connect()]);const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
redis
```

```js
import { createCluster } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = createCluster({  rootNodes: [    {      url: "redis://localhost:7000",    },    {      url: "redis://localhost:7001",    },    {      url: "redis://localhost:7002",    },  ],});const subClient = pubClient.duplicate();await Promise.all([  pubClient.connect(),  subClient.connect()]);const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
ioredis
```

```js
import { Redis } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = new Redis();const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
ioredis
```

```js
import { Cluster } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";const pubClient = new Cluster([  {    host: "localhost",    port: 7000,  },  {    host: "localhost",    port: 7001,  },  {    host: "localhost",    port: 7002,  },]);const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
createShardedAdapter()
```

```js
import { Server } from "socket.io";import { createClient } from "redis";import { createShardedAdapter } from "@socket.io/redis-adapter";const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();await Promise.all([  pubClient.connect(),  subClient.connect()]);const io = new Server({  adapter: createShardedAdapter(pubClient, subClient)});io.listen(3000);
```

```js
redis@4.6.0
```

```js
ioredis
```

```js
key
```

```js
socket.io
```

```js
requestsTimeout
```

```js
5_000
```

```js
publishOnSpecificResponseChannel
```

```js
false
```

```js
parser
```

```js
publishOnSpecificResponseChannel
```

```js
true
```

```js
fetchSockets()
```

```js
serverSideEmit()
```

```js
false
```

```js
channelPrefix
```

```js
socket.io
```

```js
subscriptionMode
```

```js
dynamic
```

```js
subscriptionMode
```

```js
static
```

```js
dynamic
```

```js
dynamic-private
```

```js
dynamic
```

```js
socket.emit()
```

```js
socket.io-redis
```

```js
socket.io-redis
```

```js
@socket.io/redis-adapter
```

```js
@socket.io/redis-emitter
```

```js
const redisAdapter = require("socket.io-redis");io.adapter(redisAdapter({ host: "localhost", port: 6379 }));
```

```js
const { createClient } = require("redis");const { createAdapter } = require("@socket.io/redis-adapter");const pubClient = createClient({ url: "redis://localhost:6379" });const subClient = pubClient.duplicate();io.adapter(createAdapter(pubClient, subClient));
```

```js
socket.io-redis
```

```js
@socket.io/redis-adapter
```

```js
8.3.0
```

```js
8.2.1...8.3.0
```

```js
8.2.1
```

```js
8.2.0...8.2.1
```

```js
8.2.0
```

```js
8.1.0...8.2.0
```

```js
8.1.0
```

```js
8.0.0...8.1.0
```

```js
8.0.0
```

```js
7.2.0...8.0.0
```

```js
7.2.0
```

```js
7.1.0...7.2.0
```

```js
npm install @socket.io/redis-emitter redis
```

```js
import { Emitter } from "@socket.io/redis-emitter";import { createClient } from "redis";const redisClient = createClient({ url: "redis://localhost:6379" });redisClient.connect().then(() => {  const emitter = new Emitter(redisClient);  setInterval(() => {    emitter.emit("time", new Date);  }, 5000);});
```

```js
redis@3
```

```js
connect()
```

```js
import { Emitter } from "@socket.io/redis-emitter";import { createClient } from "redis";const redisClient = createClient({ url: "redis://localhost:6379" });const emitter = new Emitter(redisClient);setInterval(() => {  emitter.emit("time", new Date);}, 5000);
```

```js
socket.io-emitter
```

```js
socket.io-emitter
```

```js
@socket.io/redis-emitter
```

```js
const io = require("socket.io-emitter")({ host: "127.0.0.1", port: 6379 });
```

```js
const { Emitter } = require("@socket.io/redis-emitter");const { createClient } = require("redis");const redisClient = createClient();const io = new Emitter(redisClient);
```

```js
5.1.0
```

```js
5.0.0...5.1.0
```

```js
5.0.0
```

```js
4.1.1...5.0.0
```

```js
4.1.1
```

```js
4.1.0...4.1.1
```

```js
4.1.0
```

```js
4.0.0...4.1.0
```

```js
4.0.0
```

```js
3.2.0...4.0.0
```

# https://socket.io/docs/v4/redis-streams-adapter

# Redis Streams adapter

## How it works​

## Supported features​

## Installation​

## Usage​

## Options​

## Common questions​

## Latest releases​

### With the redis package​

### With the redis package and a Redis cluster​

### With the ioredis package​

### With the ioredis package and a Redis cluster​

### Do I still need to enable sticky sessions when using the Redis Streams adapter?​

### What happens when the Redis server is down?​

The adapter will use a Redis stream to forward packets between the Socket.IO servers.

The main difference with the existing Redis adapter (which use the Redis Pub/Sub mechanism) is that this adapter will properly handle any temporary disconnection to the Redis server and resume the stream without losing any packets.

This adapter is also compatible with Valkey.

Source code: https://github.com/socketio/socket.io-redis-streams-adapter

Yes. Failing to do so will result in HTTP 400 responses (you are reaching a server that is not aware of the Socket.IO session).

More information can be found here.

Unlike the classic Redis adapter, this adapter will properly handle any temporary disconnection to the Redis server and resume the stream without losing any packets.

Complete changelog

- Adapters
- Redis Streams adapter
- a single stream is used for all namespaces
- the maxLen option allows to limit the size of the stream
- unlike the adapter based on Redis PUB/SUB mechanism, this adapter will properly handle any temporary disconnection to the Redis server and resume the stream
- if connection state recovery is enabled, the sessions will be stored in Redis as a classic key/value pair
```js
npm install @socket.io/redis-streams-adapter redis
```

```js
import { createClient } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = createClient({ url: "redis://localhost:6379" });await redisClient.connect();const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
import { createCluster } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = createCluster({  rootNodes: [    {      url: "redis://localhost:7000",    },    {      url: "redis://localhost:7001",    },    {      url: "redis://localhost:7002",    },  ],});await redisClient.connect();const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
import { Redis } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = new Redis();const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
import { Cluster } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = new Cluster([  {    host: "localhost",    port: 7000,  },  {    host: "localhost",    port: 7001,  },  {    host: "localhost",    port: 7002,  },]);const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
maxLen
```

```js
socket.io
```

```js
4.0.0
```

```js
0.1.0
```

```js
4.1.0
```

```js
0.1.0
```

```js
4.5.0
```

```js
0.1.0
```

```js
4.6.0
```

```js
0.1.0
```

```js
npm install @socket.io/redis-streams-adapter redis
```

```js
redis
```

```js
import { createClient } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = createClient({ url: "redis://localhost:6379" });await redisClient.connect();const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
redis
```

```js
import { createCluster } from "redis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = createCluster({  rootNodes: [    {      url: "redis://localhost:7000",    },    {      url: "redis://localhost:7001",    },    {      url: "redis://localhost:7002",    },  ],});await redisClient.connect();const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
ioredis
```

```js
import { Redis } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = new Redis();const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
ioredis
```

```js
import { Cluster } from "ioredis";import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-streams-adapter";const redisClient = new Cluster([  {    host: "localhost",    port: 7000,  },  {    host: "localhost",    port: 7001,  },  {    host: "localhost",    port: 7002,  },]);const io = new Server({  adapter: createAdapter(redisClient)});io.listen(3000);
```

```js
streamName
```

```js
socket.io
```

```js
maxLen
```

```js
10_000
```

```js
readCount
```

```js
100
```

```js
sessionKeyPrefix
```

```js
sio:session:
```

```js
heartbeatInterval
```

```js
5_000
```

```js
heartbeatTimeout
```

```js
10_000
```

```js
0.2.2
```

```js
0.2.1...0.2.2
```

```js
0.2.1
```

```js
0.2.0...0.2.1
```

```js
0.2.0
```

```js
0.1.0...0.2.0
```

```js
0.1.0
```

# https://socket.io/docs/v4/reverse-proxy

# Behind a reverse proxy

## nginx​

## Apache HTTPD​

## Node.js http-proxy​

## Caddy 2​

You will find below the configuration needed for deploying a Socket.IO server behind a reverse-proxy solution, such as:

In a multi-server setup, please check the documentation here.

Content of /etc/nginx/nginx.conf:

Related:

The value of nginx's proxy_read_timeout (60 seconds by default) must be bigger than Socket.IO's pingInterval + pingTimeout (45 seconds by default), else nginx will forcefully close the connection if no data is sent after the given delay and the client will get a "transport close" error.

If you only want to forward the Socket.IO requests (for example when nginx handles the static content):

Or with a custom path:

In that case, the server and the client must be configured accordingly:

Server

Client

Content of /usr/local/apache2/conf/httpd.conf:

Related:

Installation: npm i http-proxy

Documentation

Content of Caddyfile for Caddy 2, if you only want to forward the Socket.IO requests

Or, if you want a custom path:

Related

- Server
- Behind a reverse proxy
- nginx
- Apache HTTPD
- Node.js http-proxy
- Caddy 2
- proxy_pass documentation
- configuration in a multi-server setup
- mod_proxy_wstunnel documentation
- configuration in a multi-server setup
- Solution forum post
- Caddyfile reverse proxy
- Caddyfile directives
```js
http {  server {    listen 80;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
http {  server {    listen 80;    root /var/www/html;    location /socket.io/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
http {  server {    listen 80;    root /var/www/html;    location /my-custom-path/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
import { Server } from "socket.io";const io = new Server({  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/my-custom-path/"});
```

```js
Listen 80ServerName example.comLoadModule mpm_event_module             modules/mod_mpm_event.soLoadModule authn_file_module            modules/mod_authn_file.soLoadModule authn_core_module            modules/mod_authn_core.soLoadModule authz_host_module            modules/mod_authz_host.soLoadModule authz_groupfile_module       modules/mod_authz_groupfile.soLoadModule authz_user_module            modules/mod_authz_user.soLoadModule authz_core_module            modules/mod_authz_core.soLoadModule headers_module               modules/mod_headers.soLoadModule lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.soLoadModule proxy_module                 modules/mod_proxy.soLoadModule proxy_balancer_module        modules/mod_proxy_balancer.soLoadModule proxy_http_module            modules/mod_proxy_http.soLoadModule proxy_wstunnel_module        modules/mod_proxy_wstunnel.soLoadModule rewrite_module               modules/mod_rewrite.soLoadModule slotmem_shm_module           modules/mod_slotmem_shm.soLoadModule unixd_module                 modules/mod_unixd.soUser daemonGroup daemonProxyPass / http://localhost:3000/RewriteEngine onRewriteCond %{HTTP:Upgrade} websocket [NC]RewriteCond %{HTTP:Connection} upgrade [NC]RewriteRule ^/?(.*) "ws://localhost:3000/$1" [P,L]# must be bigger than pingInterval (25s by default) + pingTimeout (20s by default)ProxyTimeout 60
```

```js
const httpProxy = require("http-proxy");httpProxy  .createProxyServer({    target: "http://localhost:3000",    ws: true,  })  .listen(80);
```

```js
example.com {    reverse_proxy /socket.io/* localhost:3000}
```

```js
example.com {  rewrite /path /path/  handle_path /path/* {    rewrite * /socket.io{path}    reverse_proxy localhost:3000  }}
```

```js
http-proxy
```

```js
/etc/nginx/nginx.conf
```

```js
http {  server {    listen 80;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
proxy_read_timeout
```

```js
pingInterval + pingTimeout
```

```js
http {  server {    listen 80;    root /var/www/html;    location /socket.io/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
http {  server {    listen 80;    root /var/www/html;    location /my-custom-path/ {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://localhost:3000;      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }}
```

```js
import { Server } from "socket.io";const io = new Server({  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/my-custom-path/"});
```

```js
/usr/local/apache2/conf/httpd.conf
```

```js
Listen 80ServerName example.comLoadModule mpm_event_module             modules/mod_mpm_event.soLoadModule authn_file_module            modules/mod_authn_file.soLoadModule authn_core_module            modules/mod_authn_core.soLoadModule authz_host_module            modules/mod_authz_host.soLoadModule authz_groupfile_module       modules/mod_authz_groupfile.soLoadModule authz_user_module            modules/mod_authz_user.soLoadModule authz_core_module            modules/mod_authz_core.soLoadModule headers_module               modules/mod_headers.soLoadModule lbmethod_byrequests_module   modules/mod_lbmethod_byrequests.soLoadModule proxy_module                 modules/mod_proxy.soLoadModule proxy_balancer_module        modules/mod_proxy_balancer.soLoadModule proxy_http_module            modules/mod_proxy_http.soLoadModule proxy_wstunnel_module        modules/mod_proxy_wstunnel.soLoadModule rewrite_module               modules/mod_rewrite.soLoadModule slotmem_shm_module           modules/mod_slotmem_shm.soLoadModule unixd_module                 modules/mod_unixd.soUser daemonGroup daemonProxyPass / http://localhost:3000/RewriteEngine onRewriteCond %{HTTP:Upgrade} websocket [NC]RewriteCond %{HTTP:Connection} upgrade [NC]RewriteRule ^/?(.*) "ws://localhost:3000/$1" [P,L]# must be bigger than pingInterval (25s by default) + pingTimeout (20s by default)ProxyTimeout 60
```

```js
http-proxy
```

```js
npm i http-proxy
```

```js
const httpProxy = require("http-proxy");httpProxy  .createProxyServer({    target: "http://localhost:3000",    ws: true,  })  .listen(80);
```

```js
Caddyfile
```

```js
example.com {    reverse_proxy /socket.io/* localhost:3000}
```

```js
example.com {  rewrite /path /path/  handle_path /path/* {    rewrite * /socket.io{path}    reverse_proxy localhost:3000  }}
```

# https://socket.io/docs/v4/rooms

# Rooms

## Joining and leaving​

## Sample use cases​

## Disconnection​

## With multiple Socket.IO servers​

## Implementation details​

## Room events​

A room is an arbitrary channel that sockets can join and leave. It can be used to broadcast events to a subset of clients:

Please note that rooms are a server-only concept (i.e. the client does not have access to the list of rooms it has joined).

You can call join to subscribe the socket to a given channel:

And then simply use to or in (they are the same) when broadcasting or emitting:

Or exclude a room:

You can also emit to several rooms at the same time:

In that case, a union is performed: every socket that is at least in one of the rooms will get the event once (even if the socket is in two or more rooms).

You can also broadcast to a room from a given socket:

In that case, every socket in the room excluding the sender will get the event.

To leave a channel you call leave in the same fashion as join.

Upon disconnection, sockets leave all the channels they were part of automatically, and no special teardown is needed on your part.

You can fetch the rooms the Socket was in by listening to the disconnecting event:

Like global broadcasting, broadcasting to rooms also works with multiple Socket.IO servers.

You just need to replace the default Adapter by the Redis Adapter. More information about it here.

The "room" feature is implemented by what we call an Adapter. This Adapter is a server-side component which is responsible for:

You can find the code of the default in-memory adapter here.

Basically, it consists in two ES6 Maps:

Calling socket.join("the-room") will result in:

Those two maps are then used when broadcasting:

You can access those objects with:

Notes:

Starting with socket.io@3.1.0, the underlying Adapter will emit the following events:

Example:

- Events
- Rooms
- broadcast data to each device / tab of a given user
- send notifications about a given entity
- storing the relationships between the Socket instances and the rooms
- broadcasting events to all (or a subset of) clients
- sids: Map<SocketId, Set<Room>>
- rooms: Map<Room, Set<SocketId>>
- in the sids Map, adding "the-room" to the Set identified by the socket ID
- in the rooms Map, adding the socket ID in the Set identified by the string "the-room"
- a broadcast to all sockets (io.emit()) loops through the sids Map, and send the packet to all sockets
- a broadcast to a given room (io.to("room21").emit()) loops through the Set in the rooms Map, and sends the packet to all matching sockets
- those objects are not meant to be directly modified, you should always use socket.join(...) and socket.leave(...) instead.
- in a multi-server setup, the rooms and sids objects are not shared between the Socket.IO servers (a room may only "exist" on one server and not on another).
- create-room (argument: room)
- delete-room (argument: room)
- join-room (argument: room, id)
- leave-room (argument: room, id)
```js
io.on("connection", (socket) => {  socket.join("some room");});
```

```js
io.to("some room").emit("some event");
```

```js
io.except("some room").emit("some event");
```

```js
io.to("room1").to("room2").to("room3").emit("some event");
```

```js
io.on("connection", (socket) => {  socket.to("some room").emit("some event");});
```

```js
function computeUserIdFromHeaders(headers) {  // to be implemented}io.on("connection", async (socket) => {  const userId = await computeUserIdFromHeaders(socket.handshake.headers);  socket.join(userId);  // and then later  io.to(userId).emit("hi");});
```

```js
io.on("connection", async (socket) => {  const projects = await fetchProjects(socket);  projects.forEach(project => socket.join("project:" + project.id));  // and then later  io.to("project:4321").emit("project updated");});
```

```js
io.on("connection", socket => {  socket.on("disconnecting", () => {    console.log(socket.rooms); // the Set contains at least the socket ID  });  socket.on("disconnect", () => {    // socket.rooms.size === 0  });});
```

```js
// main namespaceconst rooms = io.of("/").adapter.rooms;const sids = io.of("/").adapter.sids;// custom namespaceconst rooms = io.of("/my-namespace").adapter.rooms;const sids = io.of("/my-namespace").adapter.sids;
```

```js
io.of("/").adapter.on("create-room", (room) => {  console.log(`room ${room} was created`);});io.of("/").adapter.on("join-room", (room, id) => {  console.log(`socket ${id} has joined room ${room}`);});
```

```js
join
```

```js
leave
```

```js
join
```

```js
io.on("connection", (socket) => {  socket.join("some room");});
```

```js
io.to("some room").emit("some event");
```

```js
io.except("some room").emit("some event");
```

```js
io.to("room1").to("room2").to("room3").emit("some event");
```

```js
io.on("connection", (socket) => {  socket.to("some room").emit("some event");});
```

```js
leave
```

```js
join
```

```js
function computeUserIdFromHeaders(headers) {  // to be implemented}io.on("connection", async (socket) => {  const userId = await computeUserIdFromHeaders(socket.handshake.headers);  socket.join(userId);  // and then later  io.to(userId).emit("hi");});
```

```js
io.on("connection", async (socket) => {  const projects = await fetchProjects(socket);  projects.forEach(project => socket.join("project:" + project.id));  // and then later  io.to("project:4321").emit("project updated");});
```

```js
leave
```

```js
disconnecting
```

```js
io.on("connection", socket => {  socket.on("disconnecting", () => {    console.log(socket.rooms); // the Set contains at least the socket ID  });  socket.on("disconnect", () => {    // socket.rooms.size === 0  });});
```

```js
sids
```

```js
Map<SocketId, Set<Room>>
```

```js
rooms
```

```js
Map<Room, Set<SocketId>>
```

```js
socket.join("the-room")
```

```js
sids
```

```js
rooms
```

```js
io.emit()
```

```js
sids
```

```js
io.to("room21").emit()
```

```js
rooms
```

```js
// main namespaceconst rooms = io.of("/").adapter.rooms;const sids = io.of("/").adapter.sids;// custom namespaceconst rooms = io.of("/my-namespace").adapter.rooms;const sids = io.of("/my-namespace").adapter.sids;
```

```js
socket.join(...)
```

```js
socket.leave(...)
```

```js
rooms
```

```js
sids
```

```js
socket.io@3.1.0
```

```js
create-room
```

```js
delete-room
```

```js
join-room
```

```js
leave-room
```

```js
io.of("/").adapter.on("create-room", (room) => {  console.log(`room ${room} was created`);});io.of("/").adapter.on("join-room", (room, id) => {  console.log(`socket ${id} has joined room ${room}`);});
```

# https://socket.io/docs/v4/server-api

## Server​

## Namespace​

## Socket​

## Client​

## Engine​

### Constructor​

### Events​

### Attributes​

### Methods​

### Attributes​

### Events​

### Methods​

### Flags​

### Events​

### Attributes​

### Methods​

### Flags​

### Attributes​

### Events​

### Attributes​

### Methods​

Related documentation pages:

The complete list of available options can be found here.

The complete list of available options can be found here.

The complete list of available options can be found here.

Synonym of Event: "connection".

Fired upon a connection from client.

Fired when a new namespace is created:

This can be useful for example:

A reference to the underlying Engine.IO server. See here.

An alias for the main namespace (/).

Sets the adapter value. Defaults to an instance of the Adapter that ships with socket.io which is memory based. See socket.io-adapter. If no arguments are supplied this method returns the current value.

Attaches the Server to an httpServer with the supplied options.

Attaches the Server on the given port with the supplied options.

Attaches the Socket.IO server to an µWebSockets.js app:

Closes the Socket.IO server and disconnect all clients. The callback argument is optional and will be called when all connections are closed.

This also closes the underlying HTTP server.

Only closing the underlying HTTP server is not sufficient, as it will only prevent the server from accepting new connections but clients connected with WebSocket will not be disconnected right away.

Reference: https://nodejs.org/api/http.html#serverclosecallback

Added in v4.0.0

Alias for io.of("/").disconnectSockets(close).

This method also works within a cluster of multiple Socket.IO servers, with a compatible adapter like the Postgres adapter.

In that case, if you only want to affect the socket instances on the given node, you need to use the local flag:

See here.

Emits an event to all connected clients in the main namespace.

Any number of parameters can be included, and all serializable data structures are supported:

And on the receiving side:

The arguments will automatically be serialized, so calling JSON.stringify() is not needed.

You can use to() and except() to send the packet to specific clients:

Starting with version 4.5.0, it is now possible to use acknowledgements when broadcasting:

Calling timeout() is mandatory in that case.

Added in v4.6.0

Promised-based version of broadcasting and expecting an acknowledgement from all targeted clients:

The example above is equivalent to:

And on the receiving side:

Added in v4.0.0

Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have not joined the given rooms.

Added in v4.0.0

Alias for io.of("/").fetchSocket().

Sample usage:

This method also works within a cluster of multiple Socket.IO servers, with a compatible adapter like the Postgres adapter.

In that case, if you only want to return the socket instances on the given node, you need to use the local flag:

See here.

Added in v1.0.0

Synonym of server.to(room), but might feel clearer in some cases:

Synonym of server.attach(httpServer[, options]).

Synonym of server.attach(port[, options]).

Initializes and retrieves the given Namespace by its pathname identifier nsp. If the namespace was already initialized it returns it immediately.

A regex or a function can also be provided, in order to create namespace in a dynamic way:

With a function:

Inherited from the EventEmitter class.

Adds the listener function to the end of the listeners array for the event named eventName.

Available events:

Sets the path value under which engine.io and the static files will be served. Defaults to /socket.io/. If no arguments are supplied this method returns the current value.

The path value must match the one on the client side:

If value is true the attached server will serve the client files. Defaults to true. This method has no effect after listen is called. If no arguments are supplied this method returns the current value.

Added in v4.1.0

Alias for: io.of("/").serverSideEmit(/* ... */);

Sends a message to the other Socket.IO servers of the cluster.

Syntax:

And on the receiving side:

Acknowledgements are supported too:

Notes:

the connection, connect and new_namespace strings are reserved and cannot be used in your application.

you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)

Example:

Added in v4.6.0

Alias for: io.of("/").serverSideEmitWithAck(/* ... */);

Promised-based version of broadcasting and expecting an acknowledgement from the other Socket.IO servers of the cluster.

The example above is equivalent to:

And on the receiving side:

Added in v4.0.0

Alias for io.of("/").socketsJoin(rooms).

This method also works within a cluster of multiple Socket.IO servers, with a compatible adapter like the Postgres adapter.

In that case, if you only want to affect the socket instances on the given node, you need to use the local flag:

See here.

Added in v4.0.0

Alias for io.of("/").socketsLeave(rooms).

This method also works within a cluster of multiple Socket.IO servers, with a compatible adapter like the Postgres adapter.

In that case, if you only want to affect the socket instances on the given node, you need to use the local flag:

See here.

Added in v4.5.0

Sets a modifier for a subsequent event emission that the callback will be called with an error when the
given number of milliseconds have elapsed without an acknowledgement from all targeted clients:

Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have joined the given room.

To emit to multiple rooms, you can call to several times.

Added in v1.0.0

Alias for io.of("/").use(fn).

Registers a middleware for the main namespace, which is a function that gets executed for every incoming Socket, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.

Errors passed to middleware callbacks are sent as special connect_error packets to clients.

Server

Client

More information can be found here.

If you are looking for Express middlewares, please check this section.

Represents a pool of sockets connected under a given scope identified by a pathname (eg: /chat).

More information can be found here.

The "Adapter" used for the namespace.

Note: the adapter of the main namespace can be accessed with io.of("/").adapter.

More information about it here.

The namespace identifier property.

A map of Socket instances that are connected to this namespace.

Synonym of Event: "connection".

Fired upon a connection from client.

This method will be removed in the next major release, please use serverSideEmit() or fetchSockets() instead.

Gets a list of socket IDs connected to this namespace (across all nodes if applicable).

Added in v4.0.0

Makes the matching Socket instances disconnect.

Emits an event to all connected clients in the given namespace.

Any number of parameters can be included, and all serializable data structures are supported:

And on the receiving side:

The arguments will automatically be serialized, so calling JSON.stringify() is not needed.

You can use to() and except() to send the packet to specific clients:

Starting with version 4.5.0, it is now possible to use acknowledgements when broadcasting:

Calling timeout() is mandatory in that case.

Added in v4.6.0

Promised-based version of broadcasting and expecting an acknowledgement from all targeted clients in the given namespace:

The example above is equivalent to:

And on the receiving side:

Added in v4.0.0

Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have not joined the given rooms.

Added in v4.0.0

Returns the matching Socket instances:

The sockets variable in the example above is an array of objects exposing a subset of the usual Socket class:

The data attribute is an arbitrary object that can be used to share information between Socket.IO servers:

Important note: this method (and socketsJoin, socketsLeave and disconnectSockets too) is compatible with the Redis adapter (starting with socket.io-redis@6.1.0), which means that they will work across Socket.IO servers.

Added in v1.0.0

Synonym of namespace.to(room), but might feel clearer in some cases:

Added in v4.1.0

Sends a message to the other Socket.IO servers of the cluster.

Syntax:

And on the receiving side:

Acknowledgements are supported too:

Notes:

the connection, connect and new_namespace strings are reserved and cannot be used in your application.

you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)

Example:

Added in v4.6.0

Promised-based version of broadcasting and expecting an acknowledgement from the other Socket.IO servers of the cluster.

The example above is equivalent to:

And on the receiving side:

Added in v4.0.0

Makes the matching Socket instances join the specified rooms:

More information can be found here.

Added in v4.0.0

Makes the matching Socket instances leave the specified rooms:

Added in v4.5.0

Sets a modifier for a subsequent event emission that the callback will be called with an error when the
given number of milliseconds have elapsed without an acknowledgement from the client:

Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have joined the given room.

To emit to multiple rooms, you can call to several times.

Added in v1.0.0

Registers a middleware for the given namespace, which is a function that gets executed for every incoming Socket, and receives as parameters the socket and a function to optionally defer execution to the next registered middleware.

Errors passed to middleware callbacks are sent as special connect_error packets to clients.

Server

Client

More information can be found here.

If you are looking for Express middlewares, please check this section.

Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node (when scaling to multiple nodes).

Sets a modifier for a subsequent event emission that the event data may be lost if the clients are not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

A Socket is the fundamental class for interacting with browser clients. A Socket belongs to a certain Namespace (by default /) and uses an underlying Client to communicate.

It should be noted the Socket doesn't relate directly to the actual underlying TCP/IP socket and it is only the name of the class.

Within each Namespace, you can also define arbitrary channels (called room) that the Socket can join and leave. That provides a convenient way to broadcast to a group of Sockets (see Socket#to below).

The Socket class inherits from EventEmitter. The Socket class overrides the emit method, and does not modify any other EventEmitter method. All methods documented here which also appear as EventEmitter methods (apart from emit) are implemented by EventEmitter, and documentation for EventEmitter applies.

More information can be found here.

Fired upon disconnection.

Possible reasons:

Added in v1.5.0

Fired when the client is going to be disconnected (but hasn't left its rooms yet).

With an asynchronous handler, you will need to create a copy of the rooms attribute:

Those events, along with connect, connect_error, newListener and removeListener, are special events that shouldn't be used in your application:

A reference to the underlying Client object.

A reference to the underlying Client transport connection (engine.io Socket object). This allows access to the IO transport layer, which still (mostly) abstracts the actual TCP/IP socket.

Added in v4.0.0

An arbitrary object that can be used in conjunction with the fetchSockets() utility method:

This also works within a Socket.IO cluster, with a compatible adapter like the Postgres adapter.

The handshake details:

Usage:

Example:

Note: the headers attribute refers to the headers of the first HTTP request of the session, and won't be updated by the subsequent HTTP requests.

A unique identifier for the session, that comes from the underlying Client.

The id attribute is an ephemeral ID that is not meant to be used in your application (or only for debugging purposes) because:

Please use a regular session ID instead (either sent in a cookie, or stored in the localStorage and sent in the auth payload).

See also:

Added in v4.6.0

Whether the connection state was successfully recovered during the last reconnection.

More information about this feature here.

A getter proxy that returns the reference to the request that originated the underlying engine.io Client. Useful for accessing request headers such as Cookie or User-Agent.

Note: socket.request refers to the first HTTP request of the session, and won't be updated by the subsequent HTTP requests.

If you don't need this reference, you can discard it in order to reduce the memory footprint:

A Set of strings identifying the rooms this client is in.

Sets a modifier for a subsequent event emission that the event data will only be compressed if the value is true. Defaults to true when you don't call the method.

Disconnects this socket. If value of close is true, closes the underlying connection. Otherwise, it just disconnects the namespace.

(overrides EventEmitter.emit)

Emits an event to the socket identified by the string name. Any other parameters can be included. All serializable data structures are supported, including Buffer.

The ack argument is optional and will be called with the client's answer.

Server

Client

Added in v4.6.0

Promised-based version of emitting and expecting an acknowledgement from the given client:

The example above is equivalent to:

And on the receiving side:

Inherited from EventEmitter (along with other methods not mentioned here). See the Node.js documentation for the events module.

Added in v4.0.0

Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have not joined the given rooms (the socket itself being excluded).

Added in v1.0.0

Synonym of socket.to(room).

Adds the socket to the given room or to the list of rooms.

The mechanics of joining rooms are handled by the Adapter that has been configured (see Server#adapter above), defaulting to socket.io-adapter.

For your convenience, each socket automatically joins a room identified by its id (see Socket#id). This makes it easy to broadcast messages to other sockets:

Removes the socket from the given room.

Rooms are left automatically upon disconnection.

Returns the list of registered catch-all listeners.

Added in v4.5.0

Returns the list of registered catch-all listeners for outgoing packets.

Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed.

Added in v4.5.0

Removes the previously registered listener. If no listener is provided, all catch-all listeners are removed.

Inherited from the EventEmitter class.

Register a new handler for the given event.

Register a new catch-all listener.

Acknowledgements are not caught in the catch-all listener.

Added in v4.5.0

Register a new catch-all listener for outgoing packets.

Acknowledgements are not caught in the catch-all listener.

Inherited from EventEmitter (along with other methods not mentioned here). See the Node.js documentation for the events module.

Register a new catch-all listener. The listener is added to the beginning of the listeners array.

Added in v4.5.0

Register a new catch-all listener for outgoing packets. The listener is added to the beginning of the listeners array.

Inherited from EventEmitter (along with other methods not mentioned here). See the Node.js documentation for the events module.

Inherited from EventEmitter (along with other methods not mentioned here). See the Node.js documentation for the events module.

Sends a message event. See socket.emit(eventName[, ...args][, ack]).

Added in v4.4.0

Sets a modifier for a subsequent event emission that the callback will be called with an error when the
given number of milliseconds have elapsed without an acknowledgement from the client:

Sets a modifier for a subsequent event emission that the event will only be broadcast to clients that have joined the given room (the socket itself being excluded).

To emit to multiple rooms, you can call to several times.

Note: acknowledgements are not supported when broadcasting.

Registers a middleware, which is a function that gets executed for every incoming Packet and receives as parameter the packet and a function to optionally defer execution to the next registered middleware.

Errors passed to the middleware callback are then emitted as error events on the server-side:

Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the sender.

Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to receive messages (because of network slowness or other issues, or because they’re connected through long polling and is in the middle of a request-response cycle).

The Client class represents an incoming transport (engine.io) connection. A Client can be associated with many multiplexed Sockets that belong to different Namespaces.

A reference to the underlying engine.io Socket connection.

A getter proxy that returns the reference to the request that originated the engine.io connection. Useful for accessing request headers such as Cookie or User-Agent.

The Engine.IO server, which manages the WebSocket / HTTP long-polling connections. More information here.

Its source code can be found here: https://github.com/socketio/engine.io

Added in v4.1.0

This event will be emitted when a connection is abnormally closed. Here is the list of possible error codes:

Added in v4.1.0

This event will be emitted just before writing the response headers of each HTTP request of the session (including the WebSocket upgrade), allowing you to customize them.

Added in v4.1.0

This event will be emitted just before writing the response headers of the first HTTP request of the session (the handshake), allowing you to customize them.

If you need to perform some asynchronous operations, you will need to use the allowRequest option:

See also:

Added in v1.0.0

The number of currently connected clients.

The function used to generate a new session ID. Defaults to base64id.

Added in v1.0.0

This method can be used to inject an HTTP upgrade:

Example with both a Socket.IO server and a plain WebSocket server:

Added in v4.6.0

Adds a new Express middleware.

The middlewares will be called for each incoming HTTP requests, including upgrade requests.

Example with express-session:

Example with helmet:

- installation
- initialization
- details of the server instance
- httpServer <http.Server> | <https.Server>
- options <Object>
- port <number>
- options <Object>
- options <Object>
- socket (Socket) socket connection with client
- namespace Namespace
- to attach a shared middleware to each namespace
- to track the dynamically created namespaces
- <Namespace>
- value <Adapter>
- Returns <Server> | <Adapter>
- httpServer <http.Server> | <https.Server>
- options <Object>
- port <number>
- options <Object>
- app <uws.App>
- options <Object>
- engine <engine.Server>
- Returns <Server>
- callback <Function>
- eventName <string> | <symbol>
- args any[]
- Returns true
- eventName <string> | <symbol>
- args any[]
- Returns Promise<any[]>
- rooms <string> | <string[]>
- Returns BroadcastOperator
- nsp <string> | <RegExp> | <Function>
- Returns <Namespace>
- eventName <string> | <symbol>
- listener <Function>
- Returns <Server>
- connection
- new_namespace
- any custom event from the serverSideEmit method
- socket <engine.Socket>
- Returns <Server>
- value <string>
- Returns <Server> | <string>
- value <boolean>
- Returns <Server> | <boolean>
- eventName <string>
- args <any[]>
- ack <Function>
- Returns true
- the connection, connect and new_namespace strings are reserved and cannot be used in your application.
- you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)
- the acknowledgement callback might be called with an error, if the other Socket.IO servers do not respond after a given delay
- eventName <string>
- args <any[]>
- ack <Function>
- Returns Promise<any[]>
- value <number>
- Returns BroadcastOperator
- room <string> | <string[]>
- Returns BroadcastOperator for chaining
- fn <Function>
- <Adapter>
- <string>
- Map<SocketId, Socket>
- socket <Socket>
- Returns Promise<Set<SocketId>>
- close <boolean> whether to close the underlying connection
- Returns void
- eventName <string> | <symbol>
- args any[]
- Returns true
- eventName <string> | <symbol>
- args any[]
- Returns Promise<any[]>
- rooms <string> | <string[]>
- Returns BroadcastOperator
- Returns Socket[] | RemoteSocket[]
- eventName <string>
- args <any[]>
- ack <Function>
- Returns true
- the connection, connect and new_namespace strings are reserved and cannot be used in your application.
- you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)
- the acknowledgement callback might be called with an error, if the other Socket.IO servers do not respond after a given delay
- eventName <string>
- args <any[]>
- ack <Function>
- Returns Promise<any[]>
- rooms <string> | <string[]>
- Returns void
- rooms <string> | <string[]>
- Returns void
- value <number>
- Returns BroadcastOperator
- room <string> | <string[]>
- Returns BroadcastOperator for chaining
- fn <Function>
- reason <string> the reason of the disconnection (either client or server-side)
- reason <string> the reason of the disconnection (either client or server-side)
- <Client>
- <engine.Socket>
- <Object>
- <string>
- this ID is regenerated after each reconnection (for example when the WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if the client is disconnected, the messages sent from the server to this ID are lost)
- Part II of our private message guide
- How to deal with cookies
- <boolean>
- <http.IncomingMessage>
- Set<string>
- value <boolean> whether to following packet will be compressed
- Returns Socket for chaining
- close <boolean> whether to close the underlying connection
- Returns Socket
- eventName <string> | <symbol>
- args <any[]>
- ack <Function>
- Returns true
- eventName <string> | <symbol>
- args any[]
- Returns Promise<any>
- rooms <string> | <string[]>
- Returns BroadcastOperator
- room <string> | <string[]>
- Returns void | Promise
- room <string>
- Returns void | Promise
- Returns <Function[]>
- Returns <Function[]>
- listener <Function>
- listener <Function>
- eventName <string> | <symbol>
- callback <Function>
- Returns <Socket>
- callback <Function>
- callback <Function>
- callback <Function>
- callback <Function>
- args <any[]>
- ack <Function>
- Returns Socket
- value <number>
- Returns <Socket>
- room <string> | <string[]>
- Returns Socket for chaining
- fn <Function>
- <engine.Socket>
- <http.IncomingMessage>
- error <Error>
- headers <Object> a hash of headers, indexed by header name
- request <http.IncomingMessage> the incoming request
- headers <Object> a hash of headers, indexed by header name
- request <http.IncomingMessage> the incoming request
- how to use with express-session
- how to deal with cookies
- <number>
- <Function>
- request <http.IncomingMessage> the incoming request
- socket <stream.Duplex> the network socket between the server and client
- head <Buffer> the first packet of the upgraded stream (may be empty)
- <Function>
```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // options});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { Server } from "socket.io";const io = new Server(3000, {  // options});io.on("connection", (socket) => {  // ...});
```

```js
import { Server } from "socket.io";const io = new Server({  // options});io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
io.on("connection", (socket) => {  // ...});
```

```js
io.on("new_namespace", (namespace) => {  // ...});
```

```js
io.on("new_namespace", (namespace) => {  namespace.use(myMiddleware);});
```

```js
io.of(/\/nsp-\w+/);io.on("new_namespace", (namespace) => {  console.log(namespace.name);});
```

```js
io.sockets.emit("hi", "everyone");// is equivalent toio.of("/").emit("hi", "everyone");
```

```js
import { Server } from "socket.io"; import { createAdapter } from "@socket.io/redis-adapter";import { createClient } from "redis";const io = new Server();const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();io.adapter(createAdapter(pubClient, subClient));// redis@3io.listen(3000);// redis@4Promise.all([pubClient.connect(), subClient.connect()]).then(() => {  io.listen(3000);});
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server();io.attach(httpServer);io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { Server } from "socket.io";const io = new Server();io.attach(3000);io.on("connection", (socket) => {  // ...});
```

```js
import { App } from "uWebSockets.js";import { Server } from "socket.io";const app = App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
import { createServer } from "node:http";import { Server as Engine } from "engine.io";import { Server } from "socket.io";const httpServer = createServer((req, res) => {  res.writeHead(404).end();});const engine = new Engine();engine.attach(httpServer, {  path: "/socket.io/"});const io = new Server();io.bind(engine);httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server } from "socket.io";const PORT = 3030;const io = new Server(PORT);io.close();const httpServer = createServer();httpServer.listen(PORT); // PORT is free to useio.attach(httpServer);
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and close the low-level connection)io.in("room1").disconnectSockets(true);
```

```js
// make all Socket instances that are currently connected on the given node disconnectio.local.disconnectSockets();
```

```js
io.emit("hello");
```

```js
io.emit("hello", 1, "2", { "3": 4 }, Buffer.from([5]));
```

```js
socket.on("hello", (arg1, arg2, arg3, arg4) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { "3": 4 }  console.log(arg4); // ArrayBuffer or Buffer, depending on the platform});
```

```js
// the “hello” event will be broadcast to all connected clients that are either// in the "room1" room or in the "room2" room, excluding those in the "room3" roomio.to("room1").to("room2").except("room3").emit("hello");
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
try {  const responses = await io.timeout(10000).emitWithAck("some-event");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
socket.on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
// the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" roomio.except("room-101").emit("foo", "bar");// with an array of roomsio.except(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsio.except("room-101").except("room-102").emit("foo", "bar");
```

```js
// return all Socket instances of the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances in the "room1" room of the main namespaceconst sockets = await io.in("room1").fetchSockets();
```

```js
io.on("connection", (socket) => {  const userId = computeUserId(socket);  socket.join(userId);  socket.on("disconnect", async () => {    const sockets = await io.in(userId).fetchSockets();    if (sockets.length === 0) {      // no more active connections for the given user    }  });});
```

```js
// return all Socket instances that are currently connected on the given nodeconst sockets = await io.local.fetchSockets();
```

```js
// disconnect all clients in the "room-101" roomio.in("room-101").disconnectSockets();
```

```js
const adminNamespace = io.of("/admin");
```

```js
const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const newNamespace = socket.nsp; // newNamespace.name === "/dynamic-101"  // broadcast to all clients in the given sub-namespace  newNamespace.emit("hello");});// client-sideconst socket = io("/dynamic-101");// broadcast to all clients in each sub-namespacedynamicNsp.emit("hello");// use a middleware for each sub-namespacedynamicNsp.use((socket, next) => { /* ... */ });
```

```js
io.of((name, query, next) => {  // the checkToken method must return a boolean, indicating whether the client is able to connect or not.  next(null, checkToken(query.token));}).on("connection", (socket) => { /* ... */ });
```

```js
io.on("connection", (socket) => {  // ...});
```

```js
import { Server } from "socket.io";import { Server as Engine } from "engine.io";const engine = new Engine();const io = new Server();engine.on("connection", (socket) => {  io.onconnection(socket);});engine.listen(3000);
```

```js
import { Server } from "socket.io";const io = new Server();io.path("/myownpath/");
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/myownpath/"});
```

```js
import { Server } from "socket.io";const io = new Server();io.serveClient(false);io.listen(3000);
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
io.serverSideEmit("ping", (err, responses) => {  if (err) {    // at least one Socket.IO server has not responded    // the 'responses' array contains all the responses already received though  } else {    // success! the 'responses' array contains one object per other Socket.IO server in the cluster  }});
```

```js
try {  const responses = await io.serverSideEmitWithAck("some-event");  console.log(responses); // one response per server (except itself)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
io.serverSideEmit("some-event", (err, responses) => {  if (err) {    // some servers did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per server (except itself)  }});
```

```js
io.on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// this also works with a single socket IDio.in(theSocketId).socketsJoin("room1");
```

```js
// make all Socket instances that are currently connected on the given node join the "room1" roomio.local.socketsJoin("room1");
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsio.in("room1").socketsLeave(["room2", "room3"]);// this also works with a single socket IDio.in(theSocketId).socketsLeave("room1");
```

```js
// make all Socket instances that are currently connected on the given node leave the "room1" roomio.local.socketsLeave("room1");
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
// the “foo” event will be broadcast to all connected clients in the “room-101” roomio.to("room-101").emit("foo", "bar");// with an array of rooms (a client will be notified at most once)io.to(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsio.to("room-101").to("room-102").emit("foo", "bar");
```

```js
io.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});
```

```js
socket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
const adapter = io.of("/my-namespace").adapter;
```

```js
// number of sockets in this namespace (on this node)const socketCount = io.of("/admin").sockets.size;
```

```js
// main namespaceio.on("connection", (socket) => {  // ...});// custom namespaceio.of("/admin").on("connection", (socket) => {  // ...});
```

```js
// all sockets in the main namespaceconst ids = await io.allSockets();// all sockets in the main namespace and in the "user:1234" roomconst ids = await io.in("user:1234").allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and discard the low-level connection)io.in("room1").disconnectSockets(true);// make all Socket instances in the "room1" room of the "admin" namespace disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
io.of("/chat").emit("hello");
```

```js
io.of("/chat").emit("hello", 1, "2", { "3": 4 }, Buffer.from([5]));
```

```js
socket.on("hello", (arg1, arg2, arg3, arg4) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { "3": 4 }  console.log(arg4); // ArrayBuffer or Buffer, depending on the platform});
```

```js
// the “hello” event will be broadcast to all connected clients that are either// in the "room1" room or in the "room2" room, excluding those in the "room3" roomio.of("/chat").to("room1").to("room2").except("room3").emit("hello");
```

```js
io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
try {  const responses = await io.of("/chat").timeout(10000).emitWithAck("some-event");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}
```

```js
io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
socket.on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
const myNamespace = io.of("/my-namespace");// the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" roommyNamespace.except("room-101").emit("foo", "bar");// with an array of roomsmyNamespace.except(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsmyNamespace.except("room-101").except("room-102").emit("foo", "bar");
```

```js
// return all Socket instances in the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances in the "room1" room of the main namespaceconst sockets = await io.in("room1").fetchSockets();// return all Socket instances in the "room1" room of the "admin" namespaceconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  console.log(socket.data);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
// server Aio.on("connection", (socket) => {  socket.data.username = "alice";});// server Bconst sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
const myNamespace = io.of("/my-namespace");// disconnect all clients in the "room-101" roommyNamespace.in("room-101").disconnectSockets();
```

```js
io.of("/chat").serverSideEmit("hello", "world");
```

```js
io.of("/chat").on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.of("/chat").serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.of("/chat").on("ping", (cb) => {  cb("pong");});
```

```js
io.of("/chat").serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
io.of("/chat").serverSideEmit("ping", (err, responses) => {  if (err) {    // at least one Socket.IO server has not responded    // the 'responses' array contains all the responses already received though  } else {    // success! the 'responses' array contains one object per other Socket.IO server in the cluster  }});
```

```js
try {  const responses = await io.of("/chat").serverSideEmitWithAck("some-event");  console.log(responses); // one response per server (except itself)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
io.of("/chat").serverSideEmit("some-event", (err, responses) => {  if (err) {    // some servers did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per server (except itself)  }});
```

```js
io.of("/chat").on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");// this also works with a single socket IDio.in(theSocketId).socketsJoin("room1");
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsio.in("room1").socketsLeave(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");// this also works with a single socket IDio.in(theSocketId).socketsLeave("room1");
```

```js
io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
const myNamespace = io.of("/my-namespace");// the “foo” event will be broadcast to all connected clients in the “room-101” roommyNamespace.to("room-101").emit("foo", "bar");// with an array of rooms (a client will be notified at most once)myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsmyNamespace.to("room-101").to("room-102").emit("foo", "bar");
```

```js
io.of("/chat").use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});
```

```js
socket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
io.local.emit("an event", { some: "data" });
```

```js
io.volatile.emit("an event", { some: "data" }); // the clients may or may not receive it
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    console.log(socket.rooms); // Set { ... }  });});
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", async (reason) => {    const rooms = new Set(socket.rooms);    await someLongRunningOperation();    // socket.rooms will be empty there    console.log(rooms);  });});
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
io.on("connection", (socket) => {  console.log("initial transport", socket.conn.transport.name); // prints "polling"  socket.conn.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log("upgraded transport", socket.conn.transport.name); // prints "websocket"  });  socket.conn.on("packet", ({ type, data }) => {    // called for each packet received  });  socket.conn.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  socket.conn.on("drain", () => {    // called when the write buffer is drained  });  socket.conn.on("heartbeat", () => {    // called after each round trip of the heartbeat mechanism    console.log("heartbeat");  });  socket.conn.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
io.on("connection", (socket) => {  socket.data.username = "alice";});const sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
io.use((socket, next) => {  let handshake = socket.handshake;  // ...});io.on("connection", (socket) => {  let handshake = socket.handshake;  // ...});
```

```js
const handshake = {  headers: {    "user-agent": "node-XMLHttpRequest",    accept: "*/*",    host: "localhost:3000",    connection: "close"  },  time: "Wed Jan 01 2020 01:00:00 GMT+0100 (Central European Standard Time)",  address: "::ffff:127.0.0.1",  xdomain: false,  secure: false,  issued: 1577836800000,  url: "/socket.io/?EIO=4&transport=polling&t=OPAfXv5&b64=1",  query: {    EIO: "4",    transport: "polling",    t: "OPAfXv5",    b64: "1"  },  auth: {}}
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.headers === socket.request.headers); // prints "true"});
```

```js
io.on("connection", (socket) => {  if (socket.recovered) {    // recovery was successful: socket.id, socket.rooms and socket.data were restored  } else {    // new or unrecoverable session  }});
```

```js
import { parse } from "cookie";io.on("connection", (socket) => {  const cookies = parse(socket.request.headers.cookie || "");});
```

```js
io.on("connection", (socket) => {  console.log(socket.request.headers === socket.handshake.headers); // prints "true"});
```

```js
io.on("connection", (socket) => {  delete socket.conn.request;});
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
io.on("connection", (socket) => {  socket.compress(false).emit("uncompressed", "that's rough");});
```

```js
io.on("connection", (socket) => {  setTimeout(() => socket.disconnect(true), 5000);});
```

```js
io.on("connection", () => {  socket.emit("hello", "world");  socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6]) });});
```

```js
io.on("connection", (socket) => {  socket.emit("hello", "world", (response) => {    console.log(response); // "got it"  });});
```

```js
socket.on("hello", (arg, callback) => {  console.log(arg); // "world"  callback("got it");});
```

```js
io.on("connection", async (socket) => {  // without timeout  const response = await socket.emitWithAck("hello", "world");  // with a specific timeout  try {    const response = await socket.timeout(10000).emitWithAck("hello", "world");  } catch (err) {    // the client did not acknowledge the event in the given delay  }});
```

```js
io.on("connection", (socket) => {  // without timeout  socket.emit("hello", "world", (val) => {    // ...  });  // with a specific timeout  socket.timeout(10000).emit("hello", "world", (err, val) => {    // ...  });});
```

```js
socket.on("hello", (arg1, callback) => {  callback("got it"); // only one argument is expected});
```

```js
// to all clients except the ones in "room1" and the sendersocket.broadcast.except("room1").emit(/* ... */);// same as abovesocket.except("room1").emit(/* ... */);// to all clients in "room4" except the ones in "room5" and the sendersocket.to("room4").except("room5").emit(/* ... */);
```

```js
io.on("connection", (socket) => {  socket.join("room 237");    console.log(socket.rooms); // Set { <socket.id>, "room 237" }  socket.join(["room 237", "room 238"]);  io.to("room 237").emit("a new user has joined the room"); // broadcast to everyone in the room});
```

```js
io.on("connection", (socket) => {  socket.on("say to someone", (id, msg) => {    // send a private message to the socket with the given id    socket.to(id).emit("my message", msg);  });});
```

```js
io.on("connection", (socket) => {  socket.leave("room 237");  io.to("room 237").emit(`user ${socket.id} has left the room`);});
```

```js
const listeners = socket.listenersAny();
```

```js
const listeners = socket.listenersAnyOutgoing();
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
const myListener = () => { /* ... */ };socket.onAnyOutgoing(myListener);// remove a single listenersocket.offAnyOutgoing(myListener);// remove all listenerssocket.offAnyOutgoing();
```

```js
socket.on("news", (data) => {  console.log(data);});// with several argumentssocket.on("news", (arg1, arg2, arg3) => {  // ...});// or with acknowledgementsocket.on("news", (data, callback) => {  callback(0);});
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.emit("foo", (value) => {  // ...});socket.onAnyOutgoing(() => {  // triggered when the event is sent});socket.onAny(() => {  // not triggered when the acknowledgement is received});
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.on("foo", (value, callback) => {  callback("OK");});socket.onAny(() => {  // triggered when the event is received});socket.onAnyOutgoing(() => {  // not triggered when the acknowledgement is sent});
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.prependAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the client did not acknowledge the event in the given delay  }});
```

```js
io.on("connection", (socket) => {  // to one room  socket.to("others").emit("an event", { some: "data" });  // to multiple rooms  socket.to("room1").to("room2").emit("hello");  // or with an array  socket.to(["room1", "room2"]).emit("hello");  // a private message to another socket  socket.to(/* another socket id */).emit("hey");  // WARNING: `socket.to(socket.id).emit()` will NOT work  // Please use `io.to(socket.id).emit()` instead.});
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    // do not forget to call next    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("an event", { some: "data" }); // everyone gets it but the sender});
```

```js
io.on("connection", (socket) => {  socket.volatile.emit("an event", { some: "data" }); // the client may or may not receive it});
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
import { serialize, parse } from "cookie";io.engine.on("headers", (headers, request) => {  if (!request.headers.cookie) return;  const cookies = parse(request.headers.cookie);  if (!cookies.randomId) {    headers["set-cookie"] = serialize("randomId", "abc", { maxAge: 86400 });  }});
```

```js
import { serialize } from "cookie";io.engine.on("initial_headers", (headers, request) => {  headers["set-cookie"] = serialize("uid", "1234", { sameSite: "strict" });});
```

```js
import { serialize } from "cookie";const io = new Server(httpServer, {  allowRequest: async (req, callback) => {    const session = await fetchSession(req);    req.session = session;    callback(null, true);  }});io.engine.on("initial_headers", (headers, req) => {  if (req.session) {    headers["set-cookie"] = serialize("sid", req.session.id, { sameSite: "strict" });  }});
```

```js
const count = io.engine.clientsCount;// may or may not be similar to the count of Socket instances in the main namespace, depending on your usageconst count2 = io.of("/").sockets.size;
```

```js
const uuid = require("uuid");io.engine.generateId = () => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
import { createServer } from "http";import { Server as WsServer } from "ws";import { Server } from "socket.io";const httpServer = createServer();const wss = new WsServer({ noServer: true });const io = new Server(httpServer);httpServer.removeAllListeners("upgrade");httpServer.on("upgrade", (req, socket, head) => {  if (req.url === "/") {    wss.handleUpgrade(req, socket, head, (ws) => {      wss.emit("connection", ws, req);    });  } else if (req.url.startsWith("/socket.io/")) {    io.engine.handleUpgrade(req, socket, head);  } else {    socket.destroy();  }});httpServer.listen(3000);
```

```js
io.engine.use((req, res, next) => {  // do something  next();});
```

```js
import session from "express-session";io.engine.use(session({  secret: "keyboard cat",  resave: false,  saveUninitialized: true,  cookie: { secure: true }}));
```

```js
import helmet from "helmet";io.engine.use(helmet());
```

```js
httpServer
```

```js
<http.Server>
```

```js
<https.Server>
```

```js
options
```

```js
<Object>
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  // options});io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
port
```

```js
<number>
```

```js
options
```

```js
<Object>
```

```js
import { Server } from "socket.io";const io = new Server(3000, {  // options});io.on("connection", (socket) => {  // ...});
```

```js
options
```

```js
<Object>
```

```js
import { Server } from "socket.io";const io = new Server({  // options});io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
socket
```

```js
io.on("connection", (socket) => {  // ...});
```

```js
namespace
```

```js
Namespace
```

```js
io.on("new_namespace", (namespace) => {  // ...});
```

```js
io.on("new_namespace", (namespace) => {  namespace.use(myMiddleware);});
```

```js
io.of(/\/nsp-\w+/);io.on("new_namespace", (namespace) => {  console.log(namespace.name);});
```

```js
<Namespace>
```

```js
io.sockets.emit("hi", "everyone");// is equivalent toio.of("/").emit("hi", "everyone");
```

```js
value
```

```js
<Adapter>
```

```js
<Server>
```

```js
<Adapter>
```

```js
value
```

```js
Adapter
```

```js
import { Server } from "socket.io"; import { createAdapter } from "@socket.io/redis-adapter";import { createClient } from "redis";const io = new Server();const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();io.adapter(createAdapter(pubClient, subClient));// redis@3io.listen(3000);// redis@4Promise.all([pubClient.connect(), subClient.connect()]).then(() => {  io.listen(3000);});
```

```js
httpServer
```

```js
<http.Server>
```

```js
<https.Server>
```

```js
options
```

```js
<Object>
```

```js
Server
```

```js
httpServer
```

```js
options
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server();io.attach(httpServer);io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
port
```

```js
<number>
```

```js
options
```

```js
<Object>
```

```js
Server
```

```js
port
```

```js
options
```

```js
import { Server } from "socket.io";const io = new Server();io.attach(3000);io.on("connection", (socket) => {  // ...});
```

```js
app
```

```js
<uws.App>
```

```js
options
```

```js
<Object>
```

```js
import { App } from "uWebSockets.js";import { Server } from "socket.io";const app = App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
engine
```

```js
<engine.Server>
```

```js
<Server>
```

```js
Server
```

```js
import { createServer } from "node:http";import { Server as Engine } from "engine.io";import { Server } from "socket.io";const httpServer = createServer((req, res) => {  res.writeHead(404).end();});const engine = new Engine();engine.attach(httpServer, {  path: "/socket.io/"});const io = new Server();io.bind(engine);httpServer.listen(3000);
```

```js
callback
```

```js
<Function>
```

```js
callback
```

```js
import { createServer } from "http";import { Server } from "socket.io";const PORT = 3030;const io = new Server(PORT);io.close();const httpServer = createServer();httpServer.listen(PORT); // PORT is free to useio.attach(httpServer);
```

```js
io.of("/").disconnectSockets(close)
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and close the low-level connection)io.in("room1").disconnectSockets(true);
```

```js
local
```

```js
// make all Socket instances that are currently connected on the given node disconnectio.local.disconnectSockets();
```

```js
io.emit()
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
any[]
```

```js
true
```

```js
io.emit("hello");
```

```js
io.emit("hello", 1, "2", { "3": 4 }, Buffer.from([5]));
```

```js
socket.on("hello", (arg1, arg2, arg3, arg4) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { "3": 4 }  console.log(arg4); // ArrayBuffer or Buffer, depending on the platform});
```

```js
JSON.stringify()
```

```js
to()
```

```js
except()
```

```js
// the “hello” event will be broadcast to all connected clients that are either// in the "room1" room or in the "room2" room, excluding those in the "room3" roomio.to("room1").to("room2").except("room3").emit("hello");
```

```js
4.5.0
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
timeout()
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
any[]
```

```js
Promise<any[]>
```

```js
try {  const responses = await io.timeout(10000).emitWithAck("some-event");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
socket.on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
rooms
```

```js
<string>
```

```js
<string[]>
```

```js
BroadcastOperator
```

```js
rooms
```

```js
// the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" roomio.except("room-101").emit("foo", "bar");// with an array of roomsio.except(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsio.except("room-101").except("room-102").emit("foo", "bar");
```

```js
io.of("/").fetchSocket()
```

```js
// return all Socket instances of the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances in the "room1" room of the main namespaceconst sockets = await io.in("room1").fetchSockets();
```

```js
io.on("connection", (socket) => {  const userId = computeUserId(socket);  socket.join(userId);  socket.on("disconnect", async () => {    const sockets = await io.in(userId).fetchSockets();    if (sockets.length === 0) {      // no more active connections for the given user    }  });});
```

```js
local
```

```js
// return all Socket instances that are currently connected on the given nodeconst sockets = await io.local.fetchSockets();
```

```js
// disconnect all clients in the "room-101" roomio.in("room-101").disconnectSockets();
```

```js
nsp
```

```js
<string>
```

```js
<RegExp>
```

```js
<Function>
```

```js
<Namespace>
```

```js
Namespace
```

```js
nsp
```

```js
const adminNamespace = io.of("/admin");
```

```js
const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {  const newNamespace = socket.nsp; // newNamespace.name === "/dynamic-101"  // broadcast to all clients in the given sub-namespace  newNamespace.emit("hello");});// client-sideconst socket = io("/dynamic-101");// broadcast to all clients in each sub-namespacedynamicNsp.emit("hello");// use a middleware for each sub-namespacedynamicNsp.use((socket, next) => { /* ... */ });
```

```js
io.of((name, query, next) => {  // the checkToken method must return a boolean, indicating whether the client is able to connect or not.  next(null, checkToken(query.token));}).on("connection", (socket) => { /* ... */ });
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
listener
```

```js
<Function>
```

```js
<Server>
```

```js
listener
```

```js
eventName
```

```js
connection
```

```js
new_namespace
```

```js
serverSideEmit
```

```js
io.on("connection", (socket) => {  // ...});
```

```js
socket
```

```js
<engine.Socket>
```

```js
<Server>
```

```js
socket.io
```

```js
Socket
```

```js
import { Server } from "socket.io";import { Server as Engine } from "engine.io";const engine = new Engine();const io = new Server();engine.on("connection", (socket) => {  io.onconnection(socket);});engine.listen(3000);
```

```js
value
```

```js
<string>
```

```js
<Server>
```

```js
<string>
```

```js
value
```

```js
engine.io
```

```js
/socket.io/
```

```js
import { Server } from "socket.io";const io = new Server();io.path("/myownpath/");
```

```js
path
```

```js
import { io } from "socket.io-client";const socket = io({  path: "/myownpath/"});
```

```js
value
```

```js
<boolean>
```

```js
<Server>
```

```js
<boolean>
```

```js
value
```

```js
true
```

```js
true
```

```js
listen
```

```js
import { Server } from "socket.io";const io = new Server();io.serveClient(false);io.listen(3000);
```

```js
io.of("/").serverSideEmit(/* ... */);
```

```js
eventName
```

```js
<string>
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
true
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
connection
```

```js
connect
```

```js
new_namespace
```

```js
JSON.stringify
```

```js
io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
io.serverSideEmit("ping", (err, responses) => {  if (err) {    // at least one Socket.IO server has not responded    // the 'responses' array contains all the responses already received though  } else {    // success! the 'responses' array contains one object per other Socket.IO server in the cluster  }});
```

```js
io.of("/").serverSideEmitWithAck(/* ... */);
```

```js
eventName
```

```js
<string>
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
Promise<any[]>
```

```js
try {  const responses = await io.serverSideEmitWithAck("some-event");  console.log(responses); // one response per server (except itself)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
io.serverSideEmit("some-event", (err, responses) => {  if (err) {    // some servers did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per server (except itself)  }});
```

```js
io.on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
io.of("/").socketsJoin(rooms)
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// this also works with a single socket IDio.in(theSocketId).socketsJoin("room1");
```

```js
local
```

```js
// make all Socket instances that are currently connected on the given node join the "room1" roomio.local.socketsJoin("room1");
```

```js
io.of("/").socketsLeave(rooms)
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsio.in("room1").socketsLeave(["room2", "room3"]);// this also works with a single socket IDio.in(theSocketId).socketsLeave("room1");
```

```js
local
```

```js
// make all Socket instances that are currently connected on the given node leave the "room1" roomio.local.socketsLeave("room1");
```

```js
value
```

```js
<number>
```

```js
BroadcastOperator
```

```js
io.timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
room
```

```js
<string>
```

```js
<string[]>
```

```js
BroadcastOperator
```

```js
room
```

```js
// the “foo” event will be broadcast to all connected clients in the “room-101” roomio.to("room-101").emit("foo", "bar");// with an array of rooms (a client will be notified at most once)io.to(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsio.to("room-101").to("room-102").emit("foo", "bar");
```

```js
io.of("/").use(fn)
```

```js
<Function>
```

```js
Socket
```

```js
connect_error
```

```js
io.use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});
```

```js
socket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
/chat
```

```js
<Adapter>
```

```js
io.of("/").adapter
```

```js
const adapter = io.of("/my-namespace").adapter;
```

```js
<string>
```

```js
Map<SocketId, Socket>
```

```js
// number of sockets in this namespace (on this node)const socketCount = io.of("/admin").sockets.size;
```

```js
socket
```

```js
<Socket>
```

```js
// main namespaceio.on("connection", (socket) => {  // ...});// custom namespaceio.of("/admin").on("connection", (socket) => {  // ...});
```

```js
Promise<Set<SocketId>>
```

```js
serverSideEmit()
```

```js
fetchSockets()
```

```js
// all sockets in the main namespaceconst ids = await io.allSockets();// all sockets in the main namespace and in the "user:1234" roomconst ids = await io.in("user:1234").allSockets();// all sockets in the "chat" namespaceconst ids = await io.of("/chat").allSockets();// all sockets in the "chat" namespace and in the "general" roomconst ids = await io.of("/chat").in("general").allSockets();
```

```js
close
```

```js
<boolean>
```

```js
void
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and discard the low-level connection)io.in("room1").disconnectSockets(true);// make all Socket instances in the "room1" room of the "admin" namespace disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
io.emit()
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
any[]
```

```js
true
```

```js
io.of("/chat").emit("hello");
```

```js
io.of("/chat").emit("hello", 1, "2", { "3": 4 }, Buffer.from([5]));
```

```js
socket.on("hello", (arg1, arg2, arg3, arg4) => {  console.log(arg1); // 1  console.log(arg2); // "2"  console.log(arg3); // { "3": 4 }  console.log(arg4); // ArrayBuffer or Buffer, depending on the platform});
```

```js
JSON.stringify()
```

```js
to()
```

```js
except()
```

```js
// the “hello” event will be broadcast to all connected clients that are either// in the "room1" room or in the "room2" room, excluding those in the "room3" roomio.of("/chat").to("room1").to("room2").except("room3").emit("hello");
```

```js
4.5.0
```

```js
io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
timeout()
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
any[]
```

```js
Promise<any[]>
```

```js
try {  const responses = await io.of("/chat").timeout(10000).emitWithAck("some-event");  console.log(responses); // one response per client} catch (e) {  // some clients did not acknowledge the event in the given delay}
```

```js
io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
socket.on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
rooms
```

```js
<string>
```

```js
<string[]>
```

```js
BroadcastOperator
```

```js
rooms
```

```js
const myNamespace = io.of("/my-namespace");// the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" roommyNamespace.except("room-101").emit("foo", "bar");// with an array of roomsmyNamespace.except(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsmyNamespace.except("room-101").except("room-102").emit("foo", "bar");
```

```js
Socket[]
```

```js
RemoteSocket[]
```

```js
// return all Socket instances in the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances in the "room1" room of the main namespaceconst sockets = await io.in("room1").fetchSockets();// return all Socket instances in the "room1" room of the "admin" namespaceconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
sockets
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  console.log(socket.data);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
data
```

```js
// server Aio.on("connection", (socket) => {  socket.data.username = "alice";});// server Bconst sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
socketsJoin
```

```js
socketsLeave
```

```js
disconnectSockets
```

```js
socket.io-redis@6.1.0
```

```js
const myNamespace = io.of("/my-namespace");// disconnect all clients in the "room-101" roommyNamespace.in("room-101").disconnectSockets();
```

```js
eventName
```

```js
<string>
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
true
```

```js
io.of("/chat").serverSideEmit("hello", "world");
```

```js
io.of("/chat").on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.of("/chat").serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.of("/chat").on("ping", (cb) => {  cb("pong");});
```

```js
connection
```

```js
connect
```

```js
new_namespace
```

```js
JSON.stringify
```

```js
io.of("/chat").serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
io.of("/chat").serverSideEmit("ping", (err, responses) => {  if (err) {    // at least one Socket.IO server has not responded    // the 'responses' array contains all the responses already received though  } else {    // success! the 'responses' array contains one object per other Socket.IO server in the cluster  }});
```

```js
eventName
```

```js
<string>
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
Promise<any[]>
```

```js
try {  const responses = await io.of("/chat").serverSideEmitWithAck("some-event");  console.log(responses); // one response per server (except itself)} catch (e) {  // some servers did not acknowledge the event in the given delay}
```

```js
io.of("/chat").serverSideEmit("some-event", (err, responses) => {  if (err) {    // some servers did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per server (except itself)  }});
```

```js
io.of("/chat").on("some-event", (callback) => {  callback("got it"); // only one argument is expected});
```

```js
rooms
```

```js
<string>
```

```js
<string[]>
```

```js
void
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");// this also works with a single socket IDio.in(theSocketId).socketsJoin("room1");
```

```js
rooms
```

```js
<string>
```

```js
<string[]>
```

```js
void
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsio.in("room1").socketsLeave(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");// this also works with a single socket IDio.in(theSocketId).socketsLeave("room1");
```

```js
value
```

```js
<number>
```

```js
BroadcastOperator
```

```js
io.of("/chat").timeout(10000).emit("some-event", (err, responses) => {  if (err) {    // some clients did not acknowledge the event in the given delay  } else {    console.log(responses); // one response per client  }});
```

```js
room
```

```js
<string>
```

```js
<string[]>
```

```js
BroadcastOperator
```

```js
room
```

```js
const myNamespace = io.of("/my-namespace");// the “foo” event will be broadcast to all connected clients in the “room-101” roommyNamespace.to("room-101").emit("foo", "bar");// with an array of rooms (a client will be notified at most once)myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");// with multiple chained callsmyNamespace.to("room-101").to("room-102").emit("foo", "bar");
```

```js
<Function>
```

```js
Socket
```

```js
connect_error
```

```js
io.of("/chat").use((socket, next) => {  const err = new Error("not authorized");  err.data = { content: "Please retry later" }; // additional details  next(err);});
```

```js
socket.on("connect_error", err => {  console.log(err instanceof Error); // true  console.log(err.message); // not authorized  console.log(err.data); // { content: "Please retry later" }});
```

```js
io.local.emit("an event", { some: "data" });
```

```js
io.volatile.emit("an event", { some: "data" }); // the clients may or may not receive it
```

```js
Socket
```

```js
Socket
```

```js
Namespace
```

```js
Client
```

```js
Socket
```

```js
socket
```

```js
Namespace
```

```js
room
```

```js
Socket
```

```js
Socket
```

```js
Socket#to
```

```js
Socket
```

```js
Socket
```

```js
emit
```

```js
EventEmitter
```

```js
EventEmitter
```

```js
emit
```

```js
EventEmitter
```

```js
EventEmitter
```

```js
reason
```

```js
<string>
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
server namespace disconnect
```

```js
client namespace disconnect
```

```js
server shutting down
```

```js
ping timeout
```

```js
pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
parse error
```

```js
forced close
```

```js
forced server close
```

```js
connectTimeout
```

```js
reason
```

```js
<string>
```

```js
rooms
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    console.log(socket.rooms); // Set { ... }  });});
```

```js
rooms
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", async (reason) => {    const rooms = new Set(socket.rooms);    await someLongRunningOperation();    // socket.rooms will be empty there    console.log(rooms);  });});
```

```js
connect
```

```js
connect_error
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
<Client>
```

```js
Client
```

```js
<engine.Socket>
```

```js
Client
```

```js
Socket
```

```js
io.on("connection", (socket) => {  console.log("initial transport", socket.conn.transport.name); // prints "polling"  socket.conn.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log("upgraded transport", socket.conn.transport.name); // prints "websocket"  });  socket.conn.on("packet", ({ type, data }) => {    // called for each packet received  });  socket.conn.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  socket.conn.on("drain", () => {    // called when the write buffer is drained  });  socket.conn.on("heartbeat", () => {    // called after each round trip of the heartbeat mechanism    console.log("heartbeat");  });  socket.conn.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
fetchSockets()
```

```js
io.on("connection", (socket) => {  socket.data.username = "alice";});const sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
<Object>
```

```js
IncomingHttpHeaders
```

```js
<string>
```

```js
<string>
```

```js
<boolean>
```

```js
<boolean>
```

```js
<number>
```

```js
<string>
```

```js
Record<string, string or string[]>
```

```js
Record<string, any>
```

```js
io.use((socket, next) => {  let handshake = socket.handshake;  // ...});io.on("connection", (socket) => {  let handshake = socket.handshake;  // ...});
```

```js
const handshake = {  headers: {    "user-agent": "node-XMLHttpRequest",    accept: "*/*",    host: "localhost:3000",    connection: "close"  },  time: "Wed Jan 01 2020 01:00:00 GMT+0100 (Central European Standard Time)",  address: "::ffff:127.0.0.1",  xdomain: false,  secure: false,  issued: 1577836800000,  url: "/socket.io/?EIO=4&transport=polling&t=OPAfXv5&b64=1",  query: {    EIO: "4",    transport: "polling",    t: "OPAfXv5",    b64: "1"  },  auth: {}}
```

```js
headers
```

```js
io.on("connection", (socket) => {  console.log(socket.handshake.headers === socket.request.headers); // prints "true"});
```

```js
<string>
```

```js
Client
```

```js
auth
```

```js
<boolean>
```

```js
io.on("connection", (socket) => {  if (socket.recovered) {    // recovery was successful: socket.id, socket.rooms and socket.data were restored  } else {    // new or unrecoverable session  }});
```

```js
<http.IncomingMessage>
```

```js
request
```

```js
Client
```

```js
Cookie
```

```js
User-Agent
```

```js
import { parse } from "cookie";io.on("connection", (socket) => {  const cookies = parse(socket.request.headers.cookie || "");});
```

```js
socket.request
```

```js
io.on("connection", (socket) => {  console.log(socket.request.headers === socket.handshake.headers); // prints "true"});
```

```js
io.on("connection", (socket) => {  delete socket.conn.request;});
```

```js
Set<string>
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
value
```

```js
<boolean>
```

```js
Socket
```

```js
true
```

```js
true
```

```js
io.on("connection", (socket) => {  socket.compress(false).emit("uncompressed", "that's rough");});
```

```js
close
```

```js
<boolean>
```

```js
Socket
```

```js
true
```

```js
io.on("connection", (socket) => {  setTimeout(() => socket.disconnect(true), 5000);});
```

```js
EventEmitter.emit
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
true
```

```js
Buffer
```

```js
io.on("connection", () => {  socket.emit("hello", "world");  socket.emit("with-binary", 1, "2", { 3: "4", 5: Buffer.from([6]) });});
```

```js
ack
```

```js
io.on("connection", (socket) => {  socket.emit("hello", "world", (response) => {    console.log(response); // "got it"  });});
```

```js
socket.on("hello", (arg, callback) => {  console.log(arg); // "world"  callback("got it");});
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
args
```

```js
any[]
```

```js
Promise<any>
```

```js
io.on("connection", async (socket) => {  // without timeout  const response = await socket.emitWithAck("hello", "world");  // with a specific timeout  try {    const response = await socket.timeout(10000).emitWithAck("hello", "world");  } catch (err) {    // the client did not acknowledge the event in the given delay  }});
```

```js
io.on("connection", (socket) => {  // without timeout  socket.emit("hello", "world", (val) => {    // ...  });  // with a specific timeout  socket.timeout(10000).emit("hello", "world", (err, val) => {    // ...  });});
```

```js
socket.on("hello", (arg1, callback) => {  callback("got it"); // only one argument is expected});
```

```js
EventEmitter
```

```js
rooms
```

```js
<string>
```

```js
<string[]>
```

```js
BroadcastOperator
```

```js
rooms
```

```js
// to all clients except the ones in "room1" and the sendersocket.broadcast.except("room1").emit(/* ... */);// same as abovesocket.except("room1").emit(/* ... */);// to all clients in "room4" except the ones in "room5" and the sendersocket.to("room4").except("room5").emit(/* ... */);
```

```js
room
```

```js
<string>
```

```js
<string[]>
```

```js
void
```

```js
Promise
```

```js
room
```

```js
io.on("connection", (socket) => {  socket.join("room 237");    console.log(socket.rooms); // Set { <socket.id>, "room 237" }  socket.join(["room 237", "room 238"]);  io.to("room 237").emit("a new user has joined the room"); // broadcast to everyone in the room});
```

```js
Adapter
```

```js
Server#adapter
```

```js
Socket#id
```

```js
io.on("connection", (socket) => {  socket.on("say to someone", (id, msg) => {    // send a private message to the socket with the given id    socket.to(id).emit("my message", msg);  });});
```

```js
room
```

```js
<string>
```

```js
void
```

```js
Promise
```

```js
room
```

```js
io.on("connection", (socket) => {  socket.leave("room 237");  io.to("room 237").emit(`user ${socket.id} has left the room`);});
```

```js
<Function[]>
```

```js
const listeners = socket.listenersAny();
```

```js
<Function[]>
```

```js
const listeners = socket.listenersAnyOutgoing();
```

```js
listener
```

```js
<Function>
```

```js
const myListener = () => { /* ... */ };socket.onAny(myListener);// then, latersocket.offAny(myListener);socket.offAny();
```

```js
listener
```

```js
<Function>
```

```js
const myListener = () => { /* ... */ };socket.onAnyOutgoing(myListener);// remove a single listenersocket.offAnyOutgoing(myListener);// remove all listenerssocket.offAnyOutgoing();
```

```js
eventName
```

```js
<string>
```

```js
<symbol>
```

```js
callback
```

```js
<Function>
```

```js
<Socket>
```

```js
socket.on("news", (data) => {  console.log(data);});// with several argumentssocket.on("news", (arg1, arg2, arg3) => {  // ...});// or with acknowledgementsocket.on("news", (data, callback) => {  callback(0);});
```

```js
callback
```

```js
<Function>
```

```js
socket.onAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.emit("foo", (value) => {  // ...});socket.onAnyOutgoing(() => {  // triggered when the event is sent});socket.onAny(() => {  // not triggered when the acknowledgement is received});
```

```js
callback
```

```js
<Function>
```

```js
socket.onAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
socket.on("foo", (value, callback) => {  callback("OK");});socket.onAny(() => {  // triggered when the event is received});socket.onAnyOutgoing(() => {  // not triggered when the acknowledgement is sent});
```

```js
EventEmitter
```

```js
callback
```

```js
<Function>
```

```js
socket.prependAny((event, ...args) => {  console.log(`got ${event}`);});
```

```js
callback
```

```js
<Function>
```

```js
socket.prependAnyOutgoing((event, ...args) => {  console.log(`got ${event}`);});
```

```js
EventEmitter
```

```js
EventEmitter
```

```js
args
```

```js
<any[]>
```

```js
ack
```

```js
<Function>
```

```js
Socket
```

```js
message
```

```js
value
```

```js
<number>
```

```js
<Socket>
```

```js
socket.timeout(5000).emit("my-event", (err) => {  if (err) {    // the client did not acknowledge the event in the given delay  }});
```

```js
room
```

```js
<string>
```

```js
<string[]>
```

```js
Socket
```

```js
room
```

```js
io.on("connection", (socket) => {  // to one room  socket.to("others").emit("an event", { some: "data" });  // to multiple rooms  socket.to("room1").to("room2").emit("hello");  // or with an array  socket.to(["room1", "room2"]).emit("hello");  // a private message to another socket  socket.to(/* another socket id */).emit("hey");  // WARNING: `socket.to(socket.id).emit()` will NOT work  // Please use `io.to(socket.id).emit()` instead.});
```

```js
socket.onAny()
```

```js
error
```

```js
<Function>
```

```js
Packet
```

```js
error
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    // do not forget to call next    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
io.on("connection", (socket) => {  socket.broadcast.emit("an event", { some: "data" }); // everyone gets it but the sender});
```

```js
io.on("connection", (socket) => {  socket.volatile.emit("an event", { some: "data" }); // the client may or may not receive it});
```

```js
Client
```

```js
Client
```

```js
Socket
```

```js
Namespace
```

```js
<engine.Socket>
```

```js
engine.io
```

```js
Socket
```

```js
<http.IncomingMessage>
```

```js
request
```

```js
Cookie
```

```js
User-Agent
```

```js
error
```

```js
<Error>
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
headers
```

```js
<Object>
```

```js
request
```

```js
<http.IncomingMessage>
```

```js
import { serialize, parse } from "cookie";io.engine.on("headers", (headers, request) => {  if (!request.headers.cookie) return;  const cookies = parse(request.headers.cookie);  if (!cookies.randomId) {    headers["set-cookie"] = serialize("randomId", "abc", { maxAge: 86400 });  }});
```

```js
headers
```

```js
<Object>
```

```js
request
```

```js
<http.IncomingMessage>
```

```js
import { serialize } from "cookie";io.engine.on("initial_headers", (headers, request) => {  headers["set-cookie"] = serialize("uid", "1234", { sameSite: "strict" });});
```

```js
allowRequest
```

```js
import { serialize } from "cookie";const io = new Server(httpServer, {  allowRequest: async (req, callback) => {    const session = await fetchSession(req);    req.session = session;    callback(null, true);  }});io.engine.on("initial_headers", (headers, req) => {  if (req.session) {    headers["set-cookie"] = serialize("sid", req.session.id, { sameSite: "strict" });  }});
```

```js
express-session
```

```js
<number>
```

```js
const count = io.engine.clientsCount;// may or may not be similar to the count of Socket instances in the main namespace, depending on your usageconst count2 = io.of("/").sockets.size;
```

```js
<Function>
```

```js
const uuid = require("uuid");io.engine.generateId = () => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
request
```

```js
<http.IncomingMessage>
```

```js
socket
```

```js
<stream.Duplex>
```

```js
head
```

```js
<Buffer>
```

```js
import { createServer } from "http";import { Server as WsServer } from "ws";import { Server } from "socket.io";const httpServer = createServer();const wss = new WsServer({ noServer: true });const io = new Server(httpServer);httpServer.removeAllListeners("upgrade");httpServer.on("upgrade", (req, socket, head) => {  if (req.url === "/") {    wss.handleUpgrade(req, socket, head, (ws) => {      wss.emit("connection", ws, req);    });  } else if (req.url.startsWith("/socket.io/")) {    io.engine.handleUpgrade(req, socket, head);  } else {    socket.destroy();  }});httpServer.listen(3000);
```

```js
<Function>
```

```js
io.engine.use((req, res, next) => {  // do something  next();});
```

```js
express-session
```

```js
import session from "express-session";io.engine.use(session({  secret: "keyboard cat",  resave: false,  saveUninitialized: true,  cookie: { secure: true }}));
```

```js
helmet
```

```js
import helmet from "helmet";io.engine.use(helmet());
```

# https://socket.io/docs/v4/server-application-structure

# Application structure

## Registering event handlers​

### Each file registers its own event handlers​

### All event handlers are registered in the index.js file​

You will find below two suggestions on how to register your event handlers.

Please note that these are merely suggestions and not strict guidelines that you must follow. Please adapt it to your own liking!

Here, the entrypoint is kept tidy, but the event listeners may be less discoverable (though strong naming convention/ctrl+f will help).

index.js

orderHandler.js

Here, each event name is located in the same place, which is great for discoverability, but could get out of hand in a medium/big application.

index.js

orderHandler.js

- Server
- Application structure
```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const registerOrderHandlers = require("./orderHandler");const registerUserHandlers = require("./userHandler");const onConnection = (socket) => {  registerOrderHandlers(io, socket);  registerUserHandlers(io, socket);}io.on("connection", onConnection);
```

```js
module.exports = (io, socket) => {  const createOrder = (payload) => {    // ...  }  const readOrder = (orderId, callback) => {    // ...  }  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);}
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const { createOrder, readOrder } = require("./orderHandler")(io);const { updatePassword } = require("./userHandler")(io);const onConnection = (socket) => {  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);  socket.on("user:update-password", updatePassword);}io.on("connection", onConnection);
```

```js
module.exports = (io) => {  const createOrder = function (payload) {    const socket = this; // hence the 'function' above, as an arrow function will not work    // ...  };  const readOrder = function (orderId, callback) {    // ...  };  return {    createOrder,    readOrder  }}
```

```js
index.js
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const registerOrderHandlers = require("./orderHandler");const registerUserHandlers = require("./userHandler");const onConnection = (socket) => {  registerOrderHandlers(io, socket);  registerUserHandlers(io, socket);}io.on("connection", onConnection);
```

```js
orderHandler.js
```

```js
module.exports = (io, socket) => {  const createOrder = (payload) => {    // ...  }  const readOrder = (orderId, callback) => {    // ...  }  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);}
```

```js
index.js
```

```js
index.js
```

```js
const httpServer = require("http").createServer();const io = require("socket.io")(httpServer);const { createOrder, readOrder } = require("./orderHandler")(io);const { updatePassword } = require("./userHandler")(io);const onConnection = (socket) => {  socket.on("order:create", createOrder);  socket.on("order:read", readOrder);  socket.on("user:update-password", updatePassword);}io.on("connection", onConnection);
```

```js
orderHandler.js
```

```js
module.exports = (io) => {  const createOrder = function (payload) {    const socket = this; // hence the 'function' above, as an arrow function will not work    // ...  };  const readOrder = function (orderId, callback) {    // ...  };  return {    createOrder,    readOrder  }}
```

# https://socket.io/docs/v4/server-initialization

# Server Initialization

## Initialization​

## Options​

### Standalone​

### With an HTTP server​

### With an HTTPS server​

### With an HTTP/2 server​

### With Express​

### With Koa​

### With Nest​

### With Fastify​

### With µWebSockets.js​

### With Hono (Node.js)​

Once you have installed the Socket.IO server library, you can now init the server. The complete list of options can be found here.

For TypeScript users, it is possible to provide type hints for the events. Please check this.

You can also pass the port as the first argument:

This implicitly starts a Node.js HTTP server, which can be accessed through io.httpServer.

See also: Node.js documentation

With client-certificate authentication:

Server

Client

See also: Node.js documentation

Using app.listen(3000) will not work here, as it creates a new HTTP server.

More information here.

More information here.

See the documentation here.

NestJS v7 and below relies on Socket.IO v2, while NestJS v8 relies on Socket.IO v4. Please use a compatible client.

You need to register the fastify-socket.io plugin:

Reference: https://github.com/uNetworking/uWebSockets.js

More information here.

The complete list of available options can be found here.

- Server
- Initialization
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
```js
const { Server } = require("socket.io");const io = new Server({ /* options */ });io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
import { Server } from "socket.io";const io = new Server({ /* options */ });io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
import { Server } from "socket.io";const io = new Server({ /* options */ });io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
const { Server } = require("socket.io");const io = new Server(3000, { /* options */ });io.on("connection", (socket) => {  // ...});
```

```js
import { Server } from "socket.io";const io = new Server(3000, { /* options */ });io.on("connection", (socket) => {  // ...});
```

```js
import { Server } from "socket.io";const io = new Server(3000, { /* options */ });io.on("connection", (socket) => {  // ...});
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const httpServer = createServer();const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
const { readFileSync } = require("fs");const { createServer } = require("https");const { Server } = require("socket.io");const httpsServer = createServer({  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpsServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpsServer = createServer({  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpsServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpsServer = createServer({  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpsServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpsServer = createServer({  key: readFileSync("/path/to/server-key.pem"),  cert: readFileSync("/path/to/server-cert.pem"),  requestCert: true,  ca: [    readFileSync("/path/to/client-cert.pem")  ]});const io = new Server(httpsServer, { /* options */ });io.engine.on("connection", (rawSocket) => {  // if you need the certificate details (it is no longer available once the handshake is completed)  rawSocket.peerCertificate = rawSocket.request.client.getPeerCertificate();});io.on("connection", (socket) => {  console.log(socket.conn.peerCertificate);  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { io } from "socket.io-client";const socket = io("https://example.com", {  key: readFileSync("/path/to/client-key.pem"),  cert: readFileSync("/path/to/client-cert.pem"),  ca: [    readFileSync("/path/to/server-cert.pem")  ]});
```

```js
const { readFileSync } = require("fs");const { createSecureServer } = require("http2");const { Server } = require("socket.io");const httpServer = createSecureServer({  allowHTTP1: true,  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createSecureServer } from "http2";import { Server } from "socket.io";const httpServer = createSecureServer({  allowHTTP1: true,  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createSecureServer } from "http2";import { Server } from "socket.io";const httpServer = createSecureServer({  allowHTTP1: true,  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
const express = require("express");const { createServer } = require("http");const { Server } = require("socket.io");const app = express();const httpServer = createServer(app);const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import express from "express";import { createServer } from "http";import { Server } from "socket.io";const app = express();const httpServer = createServer(app);const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import * as express from "express";import { createServer } from "http";import { Server } from "socket.io";const app = express();const httpServer = createServer(app);const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
const Koa = require("koa");const { createServer } = require("http");const { Server } = require("socket.io");const app = new Koa();const httpServer = createServer(app.callback());const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import Koa from "koa";import { createServer } from "http";import { Server } from "socket.io";const app = new Koa();const httpServer = createServer(app.callback());const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import * as Koa from "koa";import { createServer } from "http";import { Server } from "socket.io";const app = new Koa();const httpServer = createServer(app.callback());const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
const fastify = require("fastify");const fastifyIO = require("fastify-socket.io");const server = fastify();server.register(fastifyIO);server.get("/", (req, reply) => {  server.io.emit("hello");});server.ready().then(() => {  // we need to wait for the server to be ready, else `server.io` is undefined  server.io.on("connection", (socket) => {    // ...  });});server.listen({ port: 3000 });
```

```js
import fastify from "fastify";import fastifyIO from "fastify-socket.io";const server = fastify();server.register(fastifyIO);server.get("/", (req, reply) => {  server.io.emit("hello");});server.ready().then(() => {  // we need to wait for the server to be ready, else `server.io` is undefined  server.io.on("connection", (socket) => {    // ...  });});server.listen({ port: 3000 });
```

```js
import fastify from "fastify";import fastifyIO from "fastify-socket.io";const server = fastify();server.register(fastifyIO);server.get("/", (req, reply) => {  server.io.emit("hello");});server.ready().then(() => {  // we need to wait for the server to be ready, else `server.io` is undefined  server.io.on("connection", (socket) => {    // ...  });});server.listen({ port: 3000 });
```

```js
import { App } from "uWebSockets.js";import { Server } from "socket.io";const app = App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
const { Hono } = require("hono");const { serve } = require("@hono/node-server");const { Server } = require("socket.io");const app = new Hono();const httpServer = serve({    fetch: app.fetch,    port: 3000,});const io = new Server(httpServer, {    /* options */});io.on("connection", (socket) => {    // ...});
```

```js
import { Hono } from "hono";import { serve } from "@hono/node-server";import { Server } from "socket.io";const app = new Hono();const httpServer = serve({    fetch: app.fetch,    port: 3000,});const io = new Server(httpServer, {    /* options */});io.on("connection", (socket) => {    // ...});
```

```js
import { Hono } from "hono";import { serve } from "@hono/node-server";import { Server } from "socket.io";import type { Server as HTTPServer } from "node:http";const app = new Hono();const httpServer = serve({    fetch: app.fetch,    port: 3000,});const io = new Server(httpServer as HTTPServer, {    /* options */});io.on("connection", (socket) => {    // ...});
```

```js
const { Server } = require("socket.io");const io = new Server({ /* options */ });io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
import { Server } from "socket.io";const io = new Server({ /* options */ });io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
import { Server } from "socket.io";const io = new Server({ /* options */ });io.on("connection", (socket) => {  // ...});io.listen(3000);
```

```js
const { Server } = require("socket.io");const io = new Server(3000, { /* options */ });io.on("connection", (socket) => {  // ...});
```

```js
import { Server } from "socket.io";const io = new Server(3000, { /* options */ });io.on("connection", (socket) => {  // ...});
```

```js
import { Server } from "socket.io";const io = new Server(3000, { /* options */ });io.on("connection", (socket) => {  // ...});
```

```js
io.httpServer
```

```js
const { createServer } = require("http");const { Server } = require("socket.io");const httpServer = createServer();const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
const { readFileSync } = require("fs");const { createServer } = require("https");const { Server } = require("socket.io");const httpsServer = createServer({  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpsServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpsServer = createServer({  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpsServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpsServer = createServer({  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpsServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createServer } from "https";import { Server } from "socket.io";const httpsServer = createServer({  key: readFileSync("/path/to/server-key.pem"),  cert: readFileSync("/path/to/server-cert.pem"),  requestCert: true,  ca: [    readFileSync("/path/to/client-cert.pem")  ]});const io = new Server(httpsServer, { /* options */ });io.engine.on("connection", (rawSocket) => {  // if you need the certificate details (it is no longer available once the handshake is completed)  rawSocket.peerCertificate = rawSocket.request.client.getPeerCertificate();});io.on("connection", (socket) => {  console.log(socket.conn.peerCertificate);  // ...});httpsServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { io } from "socket.io-client";const socket = io("https://example.com", {  key: readFileSync("/path/to/client-key.pem"),  cert: readFileSync("/path/to/client-cert.pem"),  ca: [    readFileSync("/path/to/server-cert.pem")  ]});
```

```js
const { readFileSync } = require("fs");const { createSecureServer } = require("http2");const { Server } = require("socket.io");const httpServer = createSecureServer({  allowHTTP1: true,  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createSecureServer } from "http2";import { Server } from "socket.io";const httpServer = createSecureServer({  allowHTTP1: true,  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import { readFileSync } from "fs";import { createSecureServer } from "http2";import { Server } from "socket.io";const httpServer = createSecureServer({  allowHTTP1: true,  key: readFileSync("/path/to/my/key.pem"),  cert: readFileSync("/path/to/my/cert.pem")});const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
const express = require("express");const { createServer } = require("http");const { Server } = require("socket.io");const app = express();const httpServer = createServer(app);const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import express from "express";import { createServer } from "http";import { Server } from "socket.io";const app = express();const httpServer = createServer(app);const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import * as express from "express";import { createServer } from "http";import { Server } from "socket.io";const app = express();const httpServer = createServer(app);const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
app.listen(3000)
```

```js
const Koa = require("koa");const { createServer } = require("http");const { Server } = require("socket.io");const app = new Koa();const httpServer = createServer(app.callback());const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import Koa from "koa";import { createServer } from "http";import { Server } from "socket.io";const app = new Koa();const httpServer = createServer(app.callback());const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
import * as Koa from "koa";import { createServer } from "http";import { Server } from "socket.io";const app = new Koa();const httpServer = createServer(app.callback());const io = new Server(httpServer, { /* options */ });io.on("connection", (socket) => {  // ...});httpServer.listen(3000);
```

```js
fastify-socket.io
```

```js
const fastify = require("fastify");const fastifyIO = require("fastify-socket.io");const server = fastify();server.register(fastifyIO);server.get("/", (req, reply) => {  server.io.emit("hello");});server.ready().then(() => {  // we need to wait for the server to be ready, else `server.io` is undefined  server.io.on("connection", (socket) => {    // ...  });});server.listen({ port: 3000 });
```

```js
import fastify from "fastify";import fastifyIO from "fastify-socket.io";const server = fastify();server.register(fastifyIO);server.get("/", (req, reply) => {  server.io.emit("hello");});server.ready().then(() => {  // we need to wait for the server to be ready, else `server.io` is undefined  server.io.on("connection", (socket) => {    // ...  });});server.listen({ port: 3000 });
```

```js
import fastify from "fastify";import fastifyIO from "fastify-socket.io";const server = fastify();server.register(fastifyIO);server.get("/", (req, reply) => {  server.io.emit("hello");});server.ready().then(() => {  // we need to wait for the server to be ready, else `server.io` is undefined  server.io.on("connection", (socket) => {    // ...  });});server.listen({ port: 3000 });
```

```js
import { App } from "uWebSockets.js";import { Server } from "socket.io";const app = App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
const { Hono } = require("hono");const { serve } = require("@hono/node-server");const { Server } = require("socket.io");const app = new Hono();const httpServer = serve({    fetch: app.fetch,    port: 3000,});const io = new Server(httpServer, {    /* options */});io.on("connection", (socket) => {    // ...});
```

```js
import { Hono } from "hono";import { serve } from "@hono/node-server";import { Server } from "socket.io";const app = new Hono();const httpServer = serve({    fetch: app.fetch,    port: 3000,});const io = new Server(httpServer, {    /* options */});io.on("connection", (socket) => {    // ...});
```

```js
import { Hono } from "hono";import { serve } from "@hono/node-server";import { Server } from "socket.io";import type { Server as HTTPServer } from "node:http";const app = new Hono();const httpServer = serve({    fetch: app.fetch,    port: 3000,});const io = new Server(httpServer as HTTPServer, {    /* options */});io.on("connection", (socket) => {    // ...});
```

# https://socket.io/docs/v4/server-installation

# Server Installation

## Prerequisites​

## Installation​

## Additional packages​

## Other WebSocket server implementations​

## Usage with µWebSockets.js​

## Miscellaneous​

### Dependency tree​

### Transitive versions​

The latest release is currently 4.8.1, released in October 2024.

You can find the release notes here.

Please make sure that Node.js is installed on your system. The current Long Term Support (LTS) release is an ideal starting point, see here.

At least Node.js 10 is needed, older versions are not supported anymore.

To install the latest release:

To install a specific version:

By default, Socket.IO use the WebSocket server provided by the ws package.

There are 2 optional packages that can be installed alongside this package. These packages are binary add-ons which improve certain operations. Prebuilt binaries are available for the most popular platforms so you don't necessarily need to have a C++ compiler installed on your machine.

To install those packages:

Please note that these packages are optional, the WebSocket server will fallback to the Javascript implementation if they are not available. More information can be found here.

For example, you can use the eiows package, which is a fork of the (now deprecated) uws package:

And then use the wsEngine option:

This implementation "allows, but doesn't guarantee" significant performance and memory-usage improvements over the default implementation. As usual, please benchmark it against your own usage.

Starting with version 4.4.0, a Socket.IO server can now bind to a µWebSockets.js server.

Installation:

Usage:

A basic installation of the server includes 21 packages, of which 6 are maintained by our team:

The type declarations for 3rd party packages are included, in order to ease the use of the library for TypeScript users (but at the cost of a slightly-larger package).

See also: https://github.com/microsoft/types-publisher/issues/81#issuecomment-234051345

The engine.io package brings the engine that is responsible for managing the low-level connections (HTTP long-polling or WebSocket).  See also: How it works

- Server
- Installation
- NPM
- Yarn
- pnpm
- Bun
- NPM
- Yarn
- pnpm
- Bun
- bufferutil: Allows to efficiently perform operations such as masking and unmasking the data payload of the WebSocket frames.
- utf-8-validate: Allows to efficiently check if a message contains valid UTF-8 as required by the spec.
- NPM
- Yarn
- pnpm
- Bun
- NPM
- Yarn
- pnpm
- Bun
- NPM
- Yarn
- pnpm
- Bun
```js
npm install socket.io
```

```js
yarn add socket.io
```

```js
pnpm add socket.io
```

```js
bun add socket.io
```

```js
npm install socket.io@version
```

```js
yarn add socket.io@version
```

```js
pnpm add socket.io@version
```

```js
bun add socket.io@version
```

```js
npm install --save-optional bufferutil utf-8-validate
```

```js
yarn add --optional bufferutil utf-8-validate
```

```js
pnpm add -O bufferutil utf-8-validate
```

```js
bun add --optional bufferutil utf-8-validate
```

```js
npm install eiows
```

```js
yarn add eiows
```

```js
pnpm add eiows
```

```js
bun add eiows
```

```js
const { Server } = require("socket.io");const eiows = require("eiows");const io = new Server(3000, {  wsEngine: eiows.Server});
```

```js
npm install uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
yarn add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
pnpm add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
bun add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
const { App } = require("uWebSockets.js");const { Server } = require("socket.io");const app = App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
└─┬ socket.io@4.8.1  ├─┬ accepts@1.3.8  │ ├─┬ mime-types@2.1.35  │ │ └── mime-db@1.52.0  │ └── negotiator@0.6.3  ├── base64id@2.0.0  ├─┬ cors@2.8.5  │ ├── object-assign@4.1.1  │ └── vary@1.1.2  ├─┬ debug@4.3.7  │ └── ms@2.1.3  ├─┬ engine.io@6.6.4  │ ├─┬ @types/cors@2.8.17  │ │ └── @types/node@22.13.9 deduped  │ ├─┬ @types/node@22.13.9  │ │ └── undici-types@6.20.0  │ ├── accepts@1.3.8 deduped  │ ├── base64id@2.0.0 deduped  │ ├── cookie@0.7.2  │ ├── cors@2.8.5 deduped  │ ├── debug@4.3.7 deduped  │ ├── engine.io-parser@5.2.3  │ └─┬ ws@8.17.1  │   ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1  │   └── UNMET OPTIONAL DEPENDENCY utf-8-validate@>=5.0.2  ├─┬ socket.io-adapter@2.5.5  │ ├── debug@4.3.7 deduped  │ └── ws@8.17.1 deduped  └─┬ socket.io-parser@4.2.4    ├── @socket.io/component-emitter@3.1.2    └── debug@4.3.7 deduped
```

```js
4.8.1
```

```js
npm install socket.io
```

```js
yarn add socket.io
```

```js
pnpm add socket.io
```

```js
bun add socket.io
```

```js
npm install socket.io@version
```

```js
yarn add socket.io@version
```

```js
pnpm add socket.io@version
```

```js
bun add socket.io@version
```

```js
npm install --save-optional bufferutil utf-8-validate
```

```js
yarn add --optional bufferutil utf-8-validate
```

```js
pnpm add -O bufferutil utf-8-validate
```

```js
bun add --optional bufferutil utf-8-validate
```

```js
npm install eiows
```

```js
yarn add eiows
```

```js
pnpm add eiows
```

```js
bun add eiows
```

```js
wsEngine
```

```js
const { Server } = require("socket.io");const eiows = require("eiows");const io = new Server(3000, {  wsEngine: eiows.Server});
```

```js
µWebSockets.js
```

```js
µWebSockets.js
```

```js
npm install uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
yarn add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
pnpm add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
bun add uWebSockets.js@uNetworking/uWebSockets.js#v20.4.0
```

```js
const { App } = require("uWebSockets.js");const { Server } = require("socket.io");const app = App();const io = new Server();io.attachApp(app);io.on("connection", (socket) => {  // ...});app.listen(3000, (token) => {  if (!token) {    console.warn("port already in use");  }});
```

```js
└─┬ socket.io@4.8.1  ├─┬ accepts@1.3.8  │ ├─┬ mime-types@2.1.35  │ │ └── mime-db@1.52.0  │ └── negotiator@0.6.3  ├── base64id@2.0.0  ├─┬ cors@2.8.5  │ ├── object-assign@4.1.1  │ └── vary@1.1.2  ├─┬ debug@4.3.7  │ └── ms@2.1.3  ├─┬ engine.io@6.6.4  │ ├─┬ @types/cors@2.8.17  │ │ └── @types/node@22.13.9 deduped  │ ├─┬ @types/node@22.13.9  │ │ └── undici-types@6.20.0  │ ├── accepts@1.3.8 deduped  │ ├── base64id@2.0.0 deduped  │ ├── cookie@0.7.2  │ ├── cors@2.8.5 deduped  │ ├── debug@4.3.7 deduped  │ ├── engine.io-parser@5.2.3  │ └─┬ ws@8.17.1  │   ├── UNMET OPTIONAL DEPENDENCY bufferutil@^4.0.1  │   └── UNMET OPTIONAL DEPENDENCY utf-8-validate@>=5.0.2  ├─┬ socket.io-adapter@2.5.5  │ ├── debug@4.3.7 deduped  │ └── ws@8.17.1 deduped  └─┬ socket.io-parser@4.2.4    ├── @socket.io/component-emitter@3.1.2    └── debug@4.3.7 deduped
```

```js
engine.io
```

```js
socket.io
```

```js
engine.io
```

```js
4.8.x
```

```js
6.6.x
```

```js
8.17.x
```

```js
4.7.x
```

```js
6.5.x
```

```js
8.17.x
```

```js
4.6.x
```

```js
6.4.x
```

```js
8.11.x
```

```js
4.5.x
```

```js
6.2.x
```

```js
8.2.x
```

```js
4.4.x
```

```js
6.1.x
```

```js
8.2.x
```

```js
4.3.x
```

```js
6.0.x
```

```js
8.2.x
```

```js
4.2.x
```

```js
5.2.x
```

```js
7.4.x
```

```js
4.1.x
```

```js
5.1.x
```

```js
7.4.x
```

```js
4.0.x
```

```js
5.0.x
```

```js
7.4.x
```

```js
3.1.x
```

```js
4.1.x
```

```js
7.4.x
```

```js
3.0.x
```

```js
4.0.x
```

```js
7.4.x
```

```js
2.5.x
```

```js
3.6.x
```

```js
7.5.x
```

```js
2.4.x
```

```js
3.5.x
```

```js
7.4.x
```

# https://socket.io/docs/v4/server-instance

# The Server instance

## Server#engine​

## Utility methods​

## Events​

### socketsJoin​

### socketsLeave​

### disconnectSockets​

### fetchSockets​

### serverSideEmit​

### connection​

The Server instance (often called io in the code examples) has a few attributes that may be of use in your application.

It also inherits all the methods of the main namespace, like namespace.use() (see here) or namespace.allSockets().

A reference to the underlying Engine.IO server.

It can be used to fetch the number of currently connected clients:

Or to generate a custom session ID (the sid query parameter):

As of socket.io@4.1.0, the Engine.IO server emits three special events:

Here is the list of possible error codes:

Some utility methods were added in Socket.IO v4.0.0 to manage the Socket instances and their rooms:

The serverSideEmit method was added in Socket.IO v4.1.0.

Those methods share the same semantics as broadcasting, and the same filters apply:

Which makes all Socket instances of the "admin" namespace

disconnect.

Please note that they are also compatible with the Redis adapter (starting with socket.io-redis@6.1.0), which means that they will work across Socket.IO servers.

This method makes the matching Socket instances join the specified rooms:

This method makes the matching Socket instances leave the specified rooms:

This method makes the matching Socket instances disconnect:

This method returns the matching Socket instances:

The sockets variable in the example above is an array of objects exposing a subset of the usual Socket class:

The data attribute is an arbitrary object that can be used to share information between Socket.IO servers:

This method allows to emit events to the other Socket.IO servers of the cluster, in a multi-server setup.

Syntax:

And on the receiving side:

Acknowledgements are supported too:

Notes:

the connection, connect and new_namespace strings are reserved and cannot be used in your application.

you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)

Example:

The Server instance emits one single event (well, technically two, but connect is an alias for connection):

This event is fired upon a new connection. The first argument is a Socket instance.

- Server
- The Server instance
- initial_headers: will be emitted just before writing the response headers of the first HTTP request of the session (the handshake), allowing you to customize them.
- headers: will be emitted just before writing the response headers of each HTTP request of the session (including the WebSocket upgrade), allowing you to customize them.
- connection_error: will be emitted when a connection is abnormally closed
- socketsJoin: makes the matching socket instances join the specified rooms
- socketsLeave: makes the matching socket instances leave the specified rooms
- disconnectSockets: makes the matching socket instances disconnect
- fetchSockets: returns the matching socket instances
- in the "room1" room (in("room1") or to("room1"))
- except the ones in "room2" (except("room2"))
- and only on the current Socket.IO server (local)
- the connection, connect and new_namespace strings are reserved and cannot be used in your application.
- you can send any number of arguments, but binary structures are currently not supported (the array of arguments will be JSON.stringify-ed)
- the acknowledgement callback might be called with an error, if the other Socket.IO servers do not respond after a given delay
- connection
```js
const count = io.engine.clientsCount;// may or may not be similar to the count of Socket instances in the main namespace, depending on your usageconst count2 = io.of("/").sockets.size;
```

```js
const uuid = require("uuid");io.engine.generateId = (req) => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
io.engine.on("initial_headers", (headers, req) => {  headers["test"] = "123";  headers["set-cookie"] = "mycookie=456";});
```

```js
io.engine.on("headers", (headers, req) => {  headers["test"] = "789";});
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
io.of("/admin").in("room1").except("room2").local.disconnectSockets();
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");// this also works with a single socket IDio.in(theSocketId).socketsJoin("room1");
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsio.in("room1").socketsLeave(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");// this also works with a single socket IDio.in(theSocketId).socketsLeave("room1");
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and discard the low-level connection)io.in("room1").disconnectSockets(true);// make all Socket instances in the "room1" room of the "admin" namespace disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
// return all Socket instances of the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances in the "room1" room of the main namespaceconst sockets = await io.in("room1").fetchSockets();// return all Socket instances in the "room1" room of the "admin" namespaceconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  console.log(socket.data);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
// server Aio.on("connection", (socket) => {  socket.data.username = "alice";});// server Bconst sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
io.serverSideEmit("ping", (err, responses) => {  if (err) {    // at least one Socket.IO server has not responded    // the 'responses' array contains all the responses already received though  } else {    // success! the 'responses' array contains one object per other Socket.IO server in the cluster  }});
```

```js
io.on("connection", (socket) => {  // ...});
```

```js
namespace.use()
```

```js
namespace.allSockets()
```

```js
const count = io.engine.clientsCount;// may or may not be similar to the count of Socket instances in the main namespace, depending on your usageconst count2 = io.of("/").sockets.size;
```

```js
sid
```

```js
const uuid = require("uuid");io.engine.generateId = (req) => {  return uuid.v4(); // must be unique across all Socket.IO servers}
```

```js
socket.io@4.1.0
```

```js
initial_headers
```

```js
io.engine.on("initial_headers", (headers, req) => {  headers["test"] = "123";  headers["set-cookie"] = "mycookie=456";});
```

```js
headers
```

```js
io.engine.on("headers", (headers, req) => {  headers["test"] = "789";});
```

```js
connection_error
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
socketsJoin
```

```js
socketsLeave
```

```js
disconnectSockets
```

```js
fetchSockets
```

```js
serverSideEmit
```

```js
io.of("/admin").in("room1").except("room2").local.disconnectSockets();
```

```js
in("room1")
```

```js
to("room1")
```

```js
except("room2")
```

```js
local
```

```js
socket.io-redis@6.1.0
```

```js
socketsJoin
```

```js
// make all Socket instances join the "room1" roomio.socketsJoin("room1");// make all Socket instances in the "room1" room join the "room2" and "room3" roomsio.in("room1").socketsJoin(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace join the "room2" roomio.of("/admin").in("room1").socketsJoin("room2");// this also works with a single socket IDio.in(theSocketId).socketsJoin("room1");
```

```js
socketsLeave
```

```js
// make all Socket instances leave the "room1" roomio.socketsLeave("room1");// make all Socket instances in the "room1" room leave the "room2" and "room3" roomsio.in("room1").socketsLeave(["room2", "room3"]);// make all Socket instances in the "room1" room of the "admin" namespace leave the "room2" roomio.of("/admin").in("room1").socketsLeave("room2");// this also works with a single socket IDio.in(theSocketId).socketsLeave("room1");
```

```js
disconnectSockets
```

```js
// make all Socket instances disconnectio.disconnectSockets();// make all Socket instances in the "room1" room disconnect (and discard the low-level connection)io.in("room1").disconnectSockets(true);// make all Socket instances in the "room1" room of the "admin" namespace disconnectio.of("/admin").in("room1").disconnectSockets();// this also works with a single socket IDio.of("/admin").in(theSocketId).disconnectSockets();
```

```js
fetchSockets
```

```js
// return all Socket instances of the main namespaceconst sockets = await io.fetchSockets();// return all Socket instances in the "room1" room of the main namespaceconst sockets = await io.in("room1").fetchSockets();// return all Socket instances in the "room1" room of the "admin" namespaceconst sockets = await io.of("/admin").in("room1").fetchSockets();// this also works with a single socket IDconst sockets = await io.in(theSocketId).fetchSockets();
```

```js
sockets
```

```js
for (const socket of sockets) {  console.log(socket.id);  console.log(socket.handshake);  console.log(socket.rooms);  console.log(socket.data);  socket.emit(/* ... */);  socket.join(/* ... */);  socket.leave(/* ... */);  socket.disconnect(/* ... */);}
```

```js
data
```

```js
// server Aio.on("connection", (socket) => {  socket.data.username = "alice";});// server Bconst sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
serverSideEmit
```

```js
io.serverSideEmit("hello", "world");
```

```js
io.on("hello", (arg1) => {  console.log(arg1); // prints "world"});
```

```js
// server Aio.serverSideEmit("ping", (err, responses) => {  console.log(responses[0]); // prints "pong"});// server Bio.on("ping", (cb) => {  cb("pong");});
```

```js
connection
```

```js
connect
```

```js
new_namespace
```

```js
JSON.stringify
```

```js
io.serverSideEmit("hello", "world", 1, "2", { 3: "4" });
```

```js
io.serverSideEmit("ping", (err, responses) => {  if (err) {    // at least one Socket.IO server has not responded    // the 'responses' array contains all the responses already received though  } else {    // success! the 'responses' array contains one object per other Socket.IO server in the cluster  }});
```

```js
connect
```

```js
connection
```

```js
connection
```

```js
connection
```

```js
io.on("connection", (socket) => {  // ...});
```

# https://socket.io/docs/v4/server-options

# Server options

## Socket.IO server options​

## Low-level engine options​

### adapter​

### cleanupEmptyChildNamespaces​

### connectionStateRecovery​

### connectTimeout​

### parser​

### path​

### serveClient​

### addTrailingSlash​

### allowEIO3​

### allowRequest​

### allowUpgrades​

### cookie​

### cors​

### httpCompression​

### maxHttpBufferSize​

### perMessageDeflate​

### pingInterval​

### pingTimeout​

### transports​

### upgradeTimeout​

### wsEngine​

The following options affect the behavior of the Socket.IO server.

Default value: require("socket.io-adapter") (in-memory adapter, whose source code can be found here)

The "Adapter" to use.

Example with the Redis adapter:

Added in v4.6.0

Default value: false

Whether to remove child namespaces that have no sockets connected to them.

This option might be useful if you create a lot of dynamic namespaces, since each namespace creates its own adapter instance.

With this option enabled (disabled by default), when a socket disconnects from a dynamic namespace and if there are no other sockets connected to it then the namespace will be cleaned up and its adapter will be closed.

Added in v4.6.0

Default value: undefined

The option for the Connection state recovery feature:

If the skipMiddlewares option is set to true, then the middlewares will be skipped when the connection is successfully recovered:

Default value: 45000

The number of ms before disconnecting a client that has not successfully joined a namespace.

Default value: socket.io-parser

The parser to use. Please see the documentation here.

Default value: /socket.io/

It is the name of the path that is captured on the server side.

The server and the client values must match (unless you are using a path-rewriting proxy in between).

Server

Client

Default value: true

Whether to serve the client files. If true, the different bundles will be served at the following location:

(including their associated source maps)

See also here.

The following options affect the behavior of the underlying Engine.IO server.

Added in v4.6.0

Default value: true

The trailing slash which was added by default can now be disabled:

In the example above, the clients can omit the trailing slash and use /socket.io instead of /socket.io/.

Default value: false

Whether to enable compatibility with Socket.IO v2 clients.

See also: Migrating from 2.x to 3.0

Example:

Default: -

A function that receives a given handshake or upgrade request as its first parameter, and can decide whether to continue or not.

Example:

This can also be used in conjunction with the initial_headers event, to send a cookie to the client:

See also:

Default value: true

Whether to allow transport upgrades.

Default value: -

The list of options that will be forwarded to the cookie module. Available options:

Example:

Since Socket.IO v3, there is no cookie sent by default anymore (reference).

Default value: -

The list of options that will be forwarded to the cors module. More information can be found here.

Examples:

If you want the browser to send credentials such as cookies, authorization headers or TLS client certificates, you also need to set withCredentials option to true on the client side:

More information here.

Please note that in that case, you are basically disabling the security provided by Cross-Origin Resource Sharing (CORS), as any domain will be able to reach your server. Please use with caution.

Available options:

Possible values for the origin option:

The option is named origin (and not origins) even with multiple domains:

You can't use origin: "*" when setting credentials: true:

You will see an error like this in the browser console:

Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ‘.../socket.io/?EIO=4&transport=polling&t=NvQfU77’. (Reason: Credential is not supported if the CORS header ‘Access-Control-Allow-Origin’ is ‘*’)

You need to either provide a list of domains (recommended solution) or use the following method:

Please note that in that case, like with origin: "*" or origin: true, you are basically disabling the security provided by Cross-Origin Resource Sharing (CORS), as any domain will be able to reach your server. Please use with caution.

Added in v1.4.0

Default value: true

Whether to enable the compression for the HTTP long-polling transport.

Please note that if httpCompression is set to false, the compress flag used when emitting (socket.compress(true).emit(...)) will be ignored when the connection is established with HTTP long-polling requests.

All options from the Node.js zlib module are supported.

Example:

Default value: 1e6 (1 MB)

This defines how many bytes a single message can be, before closing the socket. You may increase or decrease this value depending on your needs.

It matches the maxPayload option of the ws package.

Default value: false

Whether to enable the permessage-deflate extension for the WebSocket transport. This extension is known to add a significant overhead in terms of performance and memory consumption, so we suggest to only enable it if it is really needed.

Please note that if perMessageDeflate is set to false (which is the default), the compress flag used when emitting (socket.compress(true).emit(...)) will be ignored when the connection is established with WebSockets, as the permessage-deflate extension cannot be enabled on a per-message basis.

All options from the ws module are supported:

Default value: 25000

This value is used in the heartbeat mechanism, which periodically checks if the connection is still alive between the server and the client.

The server sends a ping packet every pingInterval ms, and if the client does not answer with a pong within pingTimeout ms, the server considers that the connection is closed.

Similarly, if the client does not receive a ping packet from the server within pingInterval + pingTimeout ms, then the client also considers that the connection is closed.

In both cases, the disconnection reason will be: ping timeout

Using a small value like 1000 (one heartbeat per second) will incur some load on your server, which might become noticeable with a few thousands connected clients.

Default value: 20000

See above.

Using a smaller value means that a temporarily unresponsive server might trigger a lot of client reconnections.

On the contrary, using a bigger value means that a broken connection will take longer to get detected (and you might get a warning on React Native if pingInterval + pingTimeout is bigger than 60 seconds).

Default value: ["polling", "websocket"]

The low-level transports that are allowed on the server-side.

Example with WebTransport enabled:

Please check the WebTransport example here.

See also: client-side transports

Default value: 10000

This is the delay in milliseconds before an uncompleted transport upgrade is cancelled.

Default value: require("ws").Server (source code can be found here)

The WebSocket server implementation to use. Please see the documentation here.

Example:

- Options
- CommonJS
- ES modules
- TypeScript
- <url>/socket.io/socket.io.js
- <url>/socket.io/socket.io.min.js
- <url>/socket.io/socket.io.msgpack.min.js
- how to use with express-session
- how to deal with cookies
- domain
- encode
- expires
- httpOnly
- maxAge
- path
- sameSite
- secure
- allow a given origin
- allow a given origin for local development
- allow the given origins, headers and credentials (such as cookies, authorization headers or TLS client certificates)
- allow any origin
- Boolean - set origin to true to reflect the request origin, as defined by req.header('Origin'), or set it to false to disable CORS.
- String - set origin to a specific origin. For example if you set it to "http://example.com" only requests from "http://example.com" will be allowed.
- RegExp - set origin to a regular expression pattern which will be used to test the request origin. If it's a match, the request origin will be reflected. For example the pattern /example\.com$/ will reflect any request that is coming from an origin ending with "example.com".
- Array - set origin to an array of valid origins. Each origin can be a String or a RegExp. For example ["http://example1.com", /\.example2\.com$/] will accept any request from "http://example1.com" or from a subdomain of "example2.com".
- Function - set origin to a function implementing some custom logic. The function takes the request origin as the first parameter and a callback (which expects the signature err [object], allow [bool]) as the second.
```js
const { Server } = require("socket.io");const { createAdapter } = require("@socket.io/redis-adapter");const { createClient } = require("redis");const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";import { createClient } from "redis";const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";import { createClient } from "redis";const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
const io = new Server(httpServer, {  connectionStateRecovery: {    // the backup duration of the sessions and the packets    maxDisconnectionDuration: 2 * 60 * 1000,    // whether to skip middlewares upon successful recovery    skipMiddlewares: true,  }});
```

```js
function computeUserIdFromHeaders(headers) {  // to be implemented}// this middleware will be skipped if the connection is successfully recoveredio.use(async (socket, next) => {  socket.data.userId = await computeUserIdFromHeaders(socket.handshake.headers);  next();});io.on("connection", (socket) => {  // the userId attribute will either come:  // - from the middleware above (first connection or failed recovery)  // - from the recevery mechanism  console.log("userId", socket.data.userId);});
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {addTrailingSlash: false});
```

```js
const io = new Server(httpServer, {  allowEIO3: true // false by default});
```

```js
const io = new Server(httpServer, {  allowRequest: (req, callback) => {    const isOriginValid = check(req);    callback(null, isOriginValid);  }});
```

```js
import { serialize } from "cookie";const io = new Server(httpServer, {  allowRequest: async (req, callback) => {    const session = await fetchSession(req);    req.session = session;    callback(null, true);  }});io.engine.on("initial_headers", (headers, req) => {  if (req.session) {    headers["set-cookie"] = serialize("sid", req.session.id, { sameSite: "strict" });  }});
```

```js
import { Server } from "socket.io";const io = new Server(httpServer, {  cookie: {    name: "my-cookie",    httpOnly: true,    sameSite: "strict",    maxAge: 86400  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: ["https://example.com"]  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: process.env.NODE_ENV === "production" ? false : ["http://localhost:3000"]  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: ["https://example.com", "https://dev.example.com"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
import { io } from "socket.io-client";const socket = io("https://my-backend.com", {  withCredentials: true});
```

```js
const io = new Server(httpServer, {  cors: {    origin: "*"  }});
```

```js
const io = new Server(httpServer, {  cors: {    // BAD    origins: ["https://example.com"],    // GOOD    origin: ["https://example.com"],  }});
```

```js
// THIS WON'T WORKconst io = new Server(httpServer, {  cors: {    origin: "*",    credentials: true  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: (_req, callback) => {      callback(null, true);    },    credentials: true  }});
```

```js
const io = new Server(httpServer, {  httpCompression: {    // Engine.IO options    threshold: 2048, // defaults to 1024    // Node.js zlib options    chunkSize: 8 * 1024, // defaults to 16 * 1024    windowBits: 14, // defaults to 15    memLevel: 7, // defaults to 8  }});
```

```js
const io = new Server(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
const io = new Server(httpServer, {  perMessageDeflate: {    threshold: 2048, // defaults to 1024    zlibDeflateOptions: {      chunkSize: 8 * 1024, // defaults to 16 * 1024    },    zlibInflateOptions: {      windowBits: 14, // defaults to 15      memLevel: 7, // defaults to 8    },    clientNoContextTakeover: true, // defaults to negotiated value.    serverNoContextTakeover: true, // defaults to negotiated value.    serverMaxWindowBits: 10, // defaults to negotiated value.    concurrencyLimit: 20, // defaults to 10  }});
```

```js
socket.on("disconnect", (reason) => {  console.log(reason); // "ping timeout"});
```

```js
const io = new Server({  transports: ["polling", "websocket", "webtransport"]});
```

```js
const io = new Server(httpServer, {  wsEngine: require("eiows").Server});
```

```js
adapter
```

```js
require("socket.io-adapter")
```

```js
const { Server } = require("socket.io");const { createAdapter } = require("@socket.io/redis-adapter");const { createClient } = require("redis");const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";import { createClient } from "redis";const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
import { Server } from "socket.io";import { createAdapter } from "@socket.io/redis-adapter";import { createClient } from "redis";const pubClient = createClient({ host: "localhost", port: 6379 });const subClient = pubClient.duplicate();const io = new Server({  adapter: createAdapter(pubClient, subClient)});io.listen(3000);
```

```js
cleanupEmptyChildNamespaces
```

```js
false
```

```js
connectionStateRecovery
```

```js
undefined
```

```js
const io = new Server(httpServer, {  connectionStateRecovery: {    // the backup duration of the sessions and the packets    maxDisconnectionDuration: 2 * 60 * 1000,    // whether to skip middlewares upon successful recovery    skipMiddlewares: true,  }});
```

```js
skipMiddlewares
```

```js
true
```

```js
function computeUserIdFromHeaders(headers) {  // to be implemented}// this middleware will be skipped if the connection is successfully recoveredio.use(async (socket, next) => {  socket.data.userId = await computeUserIdFromHeaders(socket.handshake.headers);  next();});io.on("connection", (socket) => {  // the userId attribute will either come:  // - from the middleware above (first connection or failed recovery)  // - from the recevery mechanism  console.log("userId", socket.data.userId);});
```

```js
connectTimeout
```

```js
45000
```

```js
parser
```

```js
socket.io-parser
```

```js
path
```

```js
/socket.io/
```

```js
import { createServer } from "http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("https://example.com", {  path: "/my-custom-path/"});
```

```js
serveClient
```

```js
true
```

```js
true
```

```js
<url>/socket.io/socket.io.js
```

```js
<url>/socket.io/socket.io.min.js
```

```js
<url>/socket.io/socket.io.msgpack.min.js
```

```js
addTrailingSlash
```

```js
true
```

```js
import { createServer } from "node:http";import { Server } from "socket.io";const httpServer = createServer();const io = new Server(httpServer, {addTrailingSlash: false});
```

```js
/socket.io
```

```js
/socket.io/
```

```js
allowEIO3
```

```js
false
```

```js
const io = new Server(httpServer, {  allowEIO3: true // false by default});
```

```js
allowRequest
```

```js
const io = new Server(httpServer, {  allowRequest: (req, callback) => {    const isOriginValid = check(req);    callback(null, isOriginValid);  }});
```

```js
initial_headers
```

```js
import { serialize } from "cookie";const io = new Server(httpServer, {  allowRequest: async (req, callback) => {    const session = await fetchSession(req);    req.session = session;    callback(null, true);  }});io.engine.on("initial_headers", (headers, req) => {  if (req.session) {    headers["set-cookie"] = serialize("sid", req.session.id, { sameSite: "strict" });  }});
```

```js
express-session
```

```js
allowUpgrades
```

```js
true
```

```js
cookie
```

```js
cookie
```

```js
import { Server } from "socket.io";const io = new Server(httpServer, {  cookie: {    name: "my-cookie",    httpOnly: true,    sameSite: "strict",    maxAge: 86400  }});
```

```js
cors
```

```js
cors
```

```js
const io = new Server(httpServer, {  cors: {    origin: ["https://example.com"]  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: process.env.NODE_ENV === "production" ? false : ["http://localhost:3000"]  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: ["https://example.com", "https://dev.example.com"],    allowedHeaders: ["my-custom-header"],    credentials: true  }});
```

```js
withCredentials
```

```js
true
```

```js
import { io } from "socket.io-client";const socket = io("https://my-backend.com", {  withCredentials: true});
```

```js
const io = new Server(httpServer, {  cors: {    origin: "*"  }});
```

```js
origin
```

```js
methods
```

```js
['GET', 'PUT', 'POST']
```

```js
allowedHeaders
```

```js
['Content-Type', 'Authorization']
```

```js
exposedHeaders
```

```js
['Content-Range', 'X-Content-Range']
```

```js
credentials
```

```js
true
```

```js
maxAge
```

```js
preflightContinue
```

```js
optionsSuccessStatus
```

```js
OPTIONS
```

```js
204
```

```js
origin
```

```js
Boolean
```

```js
origin
```

```js
true
```

```js
req.header('Origin')
```

```js
false
```

```js
String
```

```js
origin
```

```js
"http://example.com"
```

```js
RegExp
```

```js
origin
```

```js
/example\.com$/
```

```js
Array
```

```js
origin
```

```js
String
```

```js
RegExp
```

```js
["http://example1.com", /\.example2\.com$/]
```

```js
Function
```

```js
origin
```

```js
err [object], allow [bool]
```

```js
origin
```

```js
origins
```

```js
const io = new Server(httpServer, {  cors: {    // BAD    origins: ["https://example.com"],    // GOOD    origin: ["https://example.com"],  }});
```

```js
origin: "*"
```

```js
credentials: true
```

```js
// THIS WON'T WORKconst io = new Server(httpServer, {  cors: {    origin: "*",    credentials: true  }});
```

```js
const io = new Server(httpServer, {  cors: {    origin: (_req, callback) => {      callback(null, true);    },    credentials: true  }});
```

```js
origin: "*"
```

```js
origin: true
```

```js
httpCompression
```

```js
true
```

```js
httpCompression
```

```js
false
```

```js
socket.compress(true).emit(...)
```

```js
zlib
```

```js
const io = new Server(httpServer, {  httpCompression: {    // Engine.IO options    threshold: 2048, // defaults to 1024    // Node.js zlib options    chunkSize: 8 * 1024, // defaults to 16 * 1024    windowBits: 14, // defaults to 15    memLevel: 7, // defaults to 8  }});
```

```js
maxHttpBufferSize
```

```js
1e6
```

```js
const io = new Server(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
perMessageDeflate
```

```js
false
```

```js
perMessageDeflate
```

```js
false
```

```js
socket.compress(true).emit(...)
```

```js
const io = new Server(httpServer, {  perMessageDeflate: {    threshold: 2048, // defaults to 1024    zlibDeflateOptions: {      chunkSize: 8 * 1024, // defaults to 16 * 1024    },    zlibInflateOptions: {      windowBits: 14, // defaults to 15      memLevel: 7, // defaults to 8    },    clientNoContextTakeover: true, // defaults to negotiated value.    serverNoContextTakeover: true, // defaults to negotiated value.    serverMaxWindowBits: 10, // defaults to negotiated value.    concurrencyLimit: 20, // defaults to 10  }});
```

```js
pingInterval
```

```js
25000
```

```js
pingInterval
```

```js
pingTimeout
```

```js
pingInterval + pingTimeout
```

```js
ping timeout
```

```js
socket.on("disconnect", (reason) => {  console.log(reason); // "ping timeout"});
```

```js
1000
```

```js
pingTimeout
```

```js
pingTimeout
```

```js
20000
```

```js
5000
```

```js
60000
```

```js
20000
```

```js
pingInterval + pingTimeout
```

```js
transports
```

```js
["polling", "websocket"]
```

```js
const io = new Server({  transports: ["polling", "websocket", "webtransport"]});
```

```js
transports
```

```js
upgradeTimeout
```

```js
10000
```

```js
wsEngine
```

```js
require("ws").Server
```

```js
const io = new Server(httpServer, {  wsEngine: require("eiows").Server});
```

# https://socket.io/docs/v4/server-socket-instance

# The Socket instance (server-side)

## Socket#id​

## Socket#handshake​

## Socket#rooms​

## Socket#data​

## Socket#conn​

## Additional attributes​

## Socket middlewares​

## Events​

### disconnect​

### disconnecting​

A Socket is the fundamental class for interacting with the client. It inherits all the methods of the Node.js EventEmitter, like emit, on, once or removeListener.

Besides:

The Socket instance has a few attributes that may be of use in your application:

Each new connection is assigned a random 20-characters identifier.

This identifier is synced with the value on the client-side.

Please note that, unless connection state recovery is enabled, the id attribute is an ephemeral ID that is not meant to be used in your application (or only for debugging purposes) because:

Please use a regular session ID instead (either sent in a cookie, or stored in the localStorage and sent in the auth payload).

See also:

Note: you can't overwrite this identifier, as it is used in several parts of the Socket.IO codebase.

This object contains some details about the handshake that happens at the beginning of the Socket.IO session.

Example:

This is a reference to the rooms the Socket is currently in.

An arbitrary object that can be used in conjunction with the fetchSockets() utility method:

More information here.

A reference to the underlying Engine.IO socket (see here).

As long as you do not overwrite any existing attribute, you can attach any attribute to the Socket instance and use it later:

Those middlewares look a lot like the usual middlewares, except that they are called for each incoming packet:

The next method can also be called with an error object. In that case, the event will not reach the registered event handlers and an error event will be emitted instead:

Note: this feature only exists on the server-side. For the client-side, you might be interested in catch-all listeners.

On the server-side, the Socket instance emits two special events:

This event is fired by the Socket instance upon disconnection.

Here is the list of possible reasons:

This event is similar to disconnect but is fired a bit earlier, when the Socket#rooms set is not empty yet

Note: those events, along with connect, connect_error, newListener and removeListener, are special events that shouldn't be used in your application:

- Server
- The Socket instance
- emitting and listening to events
- broadcasting events
- joining and leaving rooms
- this ID is regenerated after each reconnection (for example when the WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if the client is disconnected, the messages sent from the server to this ID are lost)
- Part II of our private message guide
- How to deal with cookies
- disconnect
- disconnecting
```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});// client-sidesocket.on("connect", () => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});
```

```js
{  headers: /* the headers of the initial request */  query: /* the query params of the initial request */  auth: /* the authentication payload */  time: /* the date of creation (as string) */  issued: /* the date of creation (unix timestamp) */  url: /* the request URL string */  address: /* the ip of the client */  xdomain: /* whether the connection is cross-domain */  secure: /* whether the connection is secure */}
```

```js
{  "headers": {    "user-agent": "xxxx",    "accept": "*/*",    "host": "example.com",    "connection": "close"  },  "query": {    "EIO": "4",    "transport": "polling",    "t": "NNjNltH"  },  "auth": {    "token": "123"  },  "time": "Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)",  "issued": 1606005226969,  "url": "/socket.io/?EIO=4&transport=polling&t=NNjNltH",  "address": "::ffff:1.2.3.4",  "xdomain": false,  "secure": true}
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
// server Aio.on("connection", (socket) => {  socket.data.username = "alice";});// server Bconst sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
io.on("connection", (socket) => {  console.log("initial transport", socket.conn.transport.name); // prints "polling"  socket.conn.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log("upgraded transport", socket.conn.transport.name); // prints "websocket"  });  socket.conn.on("packet", ({ type, data }) => {    // called for each packet received  });  socket.conn.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  socket.conn.on("drain", () => {    // called when the write buffer is drained  });  socket.conn.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
// in a middlewareio.use(async (socket, next) => {  try {    const user = await fetchUser(socket);    socket.user = user;  } catch (e) {    next(new Error("unknown user"));  }});io.on("connection", (socket) => {  console.log(socket.user);  // in a listener  socket.on("set username", (username) => {    socket.username = username;  });});
```

```js
socket.use(([event, ...args], next) => {  // do something with the packet (logging, authorization, rate limiting...)  // do not forget to call next() at the end  next();});
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    for (const room of socket.rooms) {      if (room !== socket.id) {        socket.to(room).emit("user has left", socket.id);      }    }  });});
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

```js
Socket
```

```js
// server-sideio.on("connection", (socket) => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});// client-sidesocket.on("connect", () => {  console.log(socket.id); // ojIckSD2jqNzOqIrAGzL});
```

```js
auth
```

```js
{  headers: /* the headers of the initial request */  query: /* the query params of the initial request */  auth: /* the authentication payload */  time: /* the date of creation (as string) */  issued: /* the date of creation (unix timestamp) */  url: /* the request URL string */  address: /* the ip of the client */  xdomain: /* whether the connection is cross-domain */  secure: /* whether the connection is secure */}
```

```js
{  "headers": {    "user-agent": "xxxx",    "accept": "*/*",    "host": "example.com",    "connection": "close"  },  "query": {    "EIO": "4",    "transport": "polling",    "t": "NNjNltH"  },  "auth": {    "token": "123"  },  "time": "Sun Nov 22 2020 01:33:46 GMT+0100 (Central European Standard Time)",  "issued": 1606005226969,  "url": "/socket.io/?EIO=4&transport=polling&t=NNjNltH",  "address": "::ffff:1.2.3.4",  "xdomain": false,  "secure": true}
```

```js
io.on("connection", (socket) => {  console.log(socket.rooms); // Set { <socket.id> }  socket.join("room1");  console.log(socket.rooms); // Set { <socket.id>, "room1" }});
```

```js
fetchSockets()
```

```js
// server Aio.on("connection", (socket) => {  socket.data.username = "alice";});// server Bconst sockets = await io.fetchSockets();console.log(sockets[0].data.username); // "alice"
```

```js
io.on("connection", (socket) => {  console.log("initial transport", socket.conn.transport.name); // prints "polling"  socket.conn.once("upgrade", () => {    // called when the transport is upgraded (i.e. from HTTP long-polling to WebSocket)    console.log("upgraded transport", socket.conn.transport.name); // prints "websocket"  });  socket.conn.on("packet", ({ type, data }) => {    // called for each packet received  });  socket.conn.on("packetCreate", ({ type, data }) => {    // called for each packet sent  });  socket.conn.on("drain", () => {    // called when the write buffer is drained  });  socket.conn.on("close", (reason) => {    // called when the underlying connection is closed  });});
```

```js
// in a middlewareio.use(async (socket, next) => {  try {    const user = await fetchUser(socket);    socket.user = user;  } catch (e) {    next(new Error("unknown user"));  }});io.on("connection", (socket) => {  console.log(socket.user);  // in a listener  socket.on("set username", (username) => {    socket.username = username;  });});
```

```js
socket.use(([event, ...args], next) => {  // do something with the packet (logging, authorization, rate limiting...)  // do not forget to call next() at the end  next();});
```

```js
next
```

```js
error
```

```js
io.on("connection", (socket) => {  socket.use(([event, ...args], next) => {    if (isUnauthorized(event)) {      return next(new Error("unauthorized event"));    }    next();  });  socket.on("error", (err) => {    if (err && err.message === "unauthorized event") {      socket.disconnect();    }  });});
```

```js
disconnect
```

```js
disconnecting
```

```js
disconnect
```

```js
io.on("connection", (socket) => {  socket.on("disconnect", (reason) => {    // ...  });});
```

```js
server namespace disconnect
```

```js
client namespace disconnect
```

```js
server shutting down
```

```js
ping timeout
```

```js
pingTimeout
```

```js
transport close
```

```js
transport error
```

```js
parse error
```

```js
forced close
```

```js
forced server close
```

```js
connectTimeout
```

```js
disconnecting
```

```js
disconnect
```

```js
io.on("connection", (socket) => {  socket.on("disconnecting", (reason) => {    for (const room of socket.rooms) {      if (room !== socket.id) {        socket.to(room).emit("user has left", socket.id);      }    }  });});
```

```js
connect
```

```js
connect_error
```

```js
newListener
```

```js
removeListener
```

```js
// BAD, will throw an errorsocket.emit("disconnect");
```

# https://socket.io/docs/v4/server-with-bundlers

# Usage with bundlers

## Webpack 5​

### Without serving the client files​

### Including serving the client files​

While less common than frontend bundling, it is totally possible to create a bundle for the server.

Installation:

index.js

webpack.config.js

Note: bufferutil and utf-8-validate are two optional dependencies from the ws package. You can also set them as "external" with:

Documentation: https://webpack.js.org/configuration/externals/

In that case, we'll have to use Asset modules and override the sendFile function of the Socket.IO server:

index.js

webpack.config.js

- Server
- Usage with bundlers
```js
npm install -D webpack webpack-cli socket.io bufferutil utf-8-validate
```

```js
const { Server } = require("socket.io");const io = new Server({  serveClient: false});io.on("connection", socket => {  console.log(`connect ${socket.id}`);  socket.on("disconnect", (reason) => {    console.log(`disconnect ${socket.id} due to ${reason}`);  });});io.listen(3000);
```

```js
const path = require("path");module.exports = {  entry: "./index.js",  target: "node",  mode: "production",  output: {    path: path.resolve(__dirname, "dist"),    filename: "index.js",  }};
```

```js
const path = require("path");module.exports = {  entry: "./index.js",  target: "node",  mode: "production",  output: {    path: path.resolve(__dirname, "dist"),    filename: "index.js",  },  externals: {    bufferutil: "bufferutil",    "utf-8-validate": "utf-8-validate",  },};
```

```js
const { Server } = require("socket.io");const clientFile = require("./node_modules/socket.io/client-dist/socket.io.min?raw");const clientMap = require("./node_modules/socket.io/client-dist/socket.io.min.js.map?raw");Server.sendFile = (filename, req, res) => {  res.end(filename.endsWith(".map") ? clientMap : clientFile);};const io = new Server();io.on("connection", socket => {  console.log(`connect ${socket.id}`);  socket.on("disconnect", (reason) => {    console.log(`disconnect ${socket.id} due to ${reason}`);  });});io.listen(3000);
```

```js
const path = require("path");module.exports = {  entry: "./index.js",  target: "node",  mode: "production",  output: {    path: path.resolve(__dirname, "dist"),    filename: "index.js",  },  module: {    rules: [      {        resourceQuery: /raw/,        type: "asset/source",      },    ],  },};
```

```js
npm install -D webpack webpack-cli socket.io bufferutil utf-8-validate
```

```js
index.js
```

```js
const { Server } = require("socket.io");const io = new Server({  serveClient: false});io.on("connection", socket => {  console.log(`connect ${socket.id}`);  socket.on("disconnect", (reason) => {    console.log(`disconnect ${socket.id} due to ${reason}`);  });});io.listen(3000);
```

```js
webpack.config.js
```

```js
const path = require("path");module.exports = {  entry: "./index.js",  target: "node",  mode: "production",  output: {    path: path.resolve(__dirname, "dist"),    filename: "index.js",  }};
```

```js
bufferutil
```

```js
utf-8-validate
```

```js
const path = require("path");module.exports = {  entry: "./index.js",  target: "node",  mode: "production",  output: {    path: path.resolve(__dirname, "dist"),    filename: "index.js",  },  externals: {    bufferutil: "bufferutil",    "utf-8-validate": "utf-8-validate",  },};
```

```js
sendFile
```

```js
index.js
```

```js
const { Server } = require("socket.io");const clientFile = require("./node_modules/socket.io/client-dist/socket.io.min?raw");const clientMap = require("./node_modules/socket.io/client-dist/socket.io.min.js.map?raw");Server.sendFile = (filename, req, res) => {  res.end(filename.endsWith(".map") ? clientMap : clientFile);};const io = new Server();io.on("connection", socket => {  console.log(`connect ${socket.id}`);  socket.on("disconnect", (reason) => {    console.log(`disconnect ${socket.id} due to ${reason}`);  });});io.listen(3000);
```

```js
webpack.config.js
```

```js
const path = require("path");module.exports = {  entry: "./index.js",  target: "node",  mode: "production",  output: {    path: path.resolve(__dirname, "dist"),    filename: "index.js",  },  module: {    rules: [      {        resourceQuery: /raw/,        type: "asset/source",      },    ],  },};
```

# https://socket.io/docs/v4/socket-io-protocol

# The Socket.IO protocol

## Introduction​

## Exchange protocol​

## Packet encoding​

## Sample session​

## History​

## Test suite​

### Connection to a namespace​

### Sending and receiving data​

### Acknowledgement​

### Disconnection from a namespace​

### Format​

### Examples​

### Difference between v5 and v4​

### Difference between v4 and v3​

### Difference between v3 and v2​

### Difference between v2 and v1​

### Initial revision​

This document describes the 5th version of the Socket.IO protocol.

The source of this document can be found here.

Table of content

The Socket.IO protocol enables full-duplex and low-overhead communication between a client and a server.

It is built on top of the Engine.IO protocol, which handles the low-level plumbing with WebSocket and HTTP long-polling.

The Socket.IO protocol adds the following features:

Server

Client

The reference implementation is written in TypeScript:

A Socket.IO packet contains the following fields:

Here is the list of available packet types:

At the beginning of a Socket.IO session, the client MUST send a CONNECT packet:

The server MUST respond with either:

If the server does not receive a CONNECT packet first, then it MUST close the connection immediately.

A client MAY be connected to multiple namespaces at the same time, with the same underlying WebSocket connection.

Examples:

Once the connection to a namespace is established, the client and the server can begin exchanging data:

The payload is mandatory and MUST be a non-empty array. If that's not the case, then the receiver MUST close the connection.

Examples:

The sender MAY include an event ID in order to request an acknowledgement from the receiver:

The receiver MUST respond with an ACK packet with the same event ID.

The payload is mandatory and MUST be an array (possibly empty).

Examples:

At any time, one side can end the connection to a namespace by sending a DISCONNECT packet:

No response is expected from the other side. The low-level connection MAY be kept alive if the client is connected to another namespace.

This section details the encoding used by the default parser which is included in Socket.IO server and client, and
whose source can be found here.

The JavaScript server and client implementations also supports custom parsers, which have different tradeoffs and may benefit to
certain kind of applications. Please see socket.io-json-parser
or socket.io-msgpack-parser for example.

Please also note that each Socket.IO packet is sent as a Engine.IO message packet (more information here),
so the encoded result will be prefixed by the character "4" when sent over the wire (in the request/response body with HTTP
long-polling, or in the WebSocket frame).

Note: the namespace is only included if it is different from the main namespace (/)

Packet

Encoded

Packet

Encoded

Packet

Encoded

Packet

Encoded

Packet

Encoded

Packet

Encoded

Packet

Encoded

Please remember that each Socket.IO packet is wrapped in a Engine.IO message packet, so they will be prefixed by the character "4" when sent over the wire.

Example: { type: EVENT, namespace: "/", data: ["foo"] } will be sent as 42["foo"]

Packet

Encoded

Packet

Encoded

Packet

Encoded

Packet

Encoded

Encoded

Here is an example of what is sent over the wire when combining both the Engine.IO and the Socket.IO protocols.

Details:

Note: the t query param is used to ensure that the request is not cached by the browser.

Details:

socket.emit('hey', 'Jude') is executed on the server:

Details:

socket.emit('hello'); socket.emit('world'); is executed on the client:

Details:

WebSocket frames:

The 5th revision (current) of the Socket.IO protocol is used in Socket.IO v3 and above (v3.0.0 was released in November 2020).

It is built on top of the 4th revision of the Engine.IO protocol (hence the EIO=4 query parameter).

List of changes:

In previous versions, a client was always connected to the default namespace, even if it requested access to another namespace.

This is not the case anymore, the client must send a CONNECT packet in any case.

Commits: 09b6f23 (server) and 249e0be (client)

The meaning and the code number (4) are not modified: this packet type is still used by the server when the connection to a namespace is refused. But we feel the name is more self-descriptive.

Commits: d16c035 (server) and 13e1db7c (client).

The client can send a payload for authentication/authorization purposes. Example:

In case of success, the server responds with a payload contain the ID of the Socket. Example:

This change means that the ID of the Socket.IO connection will now be different from the ID of the underlying Engine.IO connection (the one that is found in the query parameters of the HTTP requests).

Commits: 2875d2c (server) and bbe94ad (client)

Commits: 54bf4a4 (server) and 0939395 (client)

The 4th revision of the Socket.IO protocol is used in Socket.IO v1 (v1.0.3 was released in June 2014) and v2 (v2.0.0 was released in May 2017).

The details of the revision can be found here: https://github.com/socketio/socket.io-protocol/tree/v4

It is built on top of the 3rd revision of the Engine.IO protocol (hence the EIO=3 query parameter).

List of changes:

Previously, an ACK packet was always treated as if it may contain binary objects, with recursive search for such
objects, which could hurt performance.

Reference: https://github.com/socketio/socket.io-parser/commit/ca4f42a922ba7078e840b1bc09fe3ad618acc065

The 3rd revision of the Socket.IO protocol is used in early Socket.IO v1 versions (socket.io@1.0.0...1.0.2) (released in May 2014).

The details of the revision can be found here: https://github.com/socketio/socket.io-protocol/tree/v3

List of changes:

List of changes:

This was added during the work towards Socket.IO 1.0, in order to add support for binary objects. The BINARY_EVENT
packets were encoded with msgpack.

This first revision was the result of the split between the Engine.IO protocol (low-level plumbing with WebSocket / HTTP
long-polling, heartbeat) and the Socket.IO protocol. It was never included in a Socket.IO release, but paved the way for
the next iterations.

The test suite in the test-suite/ directory lets you check the compliance of a server implementation.

Usage:

For reference, here is expected configuration for the JavaScript server to pass all tests:

- Miscellaneous
- The Socket.IO protocol
- Introduction
- Exchange protocolConnection to a namespaceSending and receiving dataAcknowledgementDisconnection from a namespace
- Connection to a namespace
- Sending and receiving data
- Acknowledgement
- Disconnection from a namespace
- Packet encodingFormatExamplesConnection to a namespaceSending and receiving dataAcknowledgementDisconnection from a namespace
- Format
- ExamplesConnection to a namespaceSending and receiving dataAcknowledgementDisconnection from a namespace
- Connection to a namespace
- Sending and receiving data
- Acknowledgement
- Disconnection from a namespace
- Sample session
- HistoryDifference between v5 and v4Difference between v4 and v3Difference between v3 and v2Difference between v2 and v1Initial revision
- Difference between v5 and v4
- Difference between v4 and v3
- Difference between v3 and v2
- Difference between v2 and v1
- Initial revision
- Test suite
- multiplexing (referred as "namespace" in the Socket.IO jargon)
- acknowledgement of packets
- server: https://github.com/socketio/socket.io
- client: https://github.com/socketio/socket.io-client
- a packet type (integer)
- a namespace (string)
- optionally, a payload (Object | Array)
- optionally, an acknowledgment id (integer)
- a CONNECT packet if the connection is successful, with the session ID in the payload
- or a CONNECT_ERROR packet if the connection is not allowed
- with the main namespace (named "/")
- with a custom namespace
- with an additional payload
- in case the connection is refused
- with the main namespace
- with a custom namespace
- with binary data
- with the main namespace
- with a custom namespace
- with binary data
- with the main namespace
- with a custom namespace
- in case the connection is refused
- with the main namespace
- with a custom namespace
- with binary data
- with multiple attachments
- with the main namespace
- with a custom namespace
- with binary data
- with the main namespace
- with a custom namespace
- Request n°1 (open packet)
- Request n°2 (namespace connection request):
- Request n°3 (namespace connection approval)
- Request n°4
- Request n°5 (message out)
- Request n°6 (WebSocket upgrade)
- remove the implicit connection to the default namespace
- rename ERROR to CONNECT_ERROR
- the CONNECT packet now can contain a payload
- the payload CONNECT_ERROR packet is now an object instead of a plain string
- add a BINARY_ACK packet type
- remove the usage of msgpack to encode packets containing binary objects (see also 299849b)
- add a BINARY_EVENT packet type
- in Node.js: npm ci && npm test
- in a browser: simply open the index.html file in your browser
```js
// declare the namespaceconst namespace = io.of("/admin");// handle the connection to the namespacenamespace.on("connection", (socket) => {  // ...});
```

```js
// reach the main namespaceconst socket1 = io();// reach the "/admin" namespace (with the same underlying WebSocket connection)const socket2 = io("/admin");// handle the connection to the namespacesocket2.on("connect", () => {  // ...});
```

```js
// on one sidesocket.emit("hello", "foo", (arg) => {  console.log("received", arg);});// on the other sidesocket.on("hello", (arg, ack) => {  ack("bar");});
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │             { type: CONNECT, namespace: "/" }              │  │  ◄───────────────────────────────────────────────────────  │  │   { type: CONNECT, namespace: "/", data: { sid: "..." } }  │
```

```js
Client > { type: CONNECT, namespace: "/" }Server > { type: CONNECT, namespace: "/", data: { sid: "wZX3oN0bSVIhsaknAAAI" } }
```

```js
Client > { type: CONNECT, namespace: "/admin" }Server > { type: CONNECT, namespace: "/admin", data: { sid: "oSO0OpakMV_3jnilAAAA" } }
```

```js
Client > { type: CONNECT, namespace: "/admin", data: { "token": "123" } }Server > { type: CONNECT, namespace: "/admin", data: { sid: "iLnRaVGHY4B75TeVAAAB" } }
```

```js
Client > { type: CONNECT, namespace: "/" }Server > { type: CONNECT_ERROR, namespace: "/", data: { message: "Not authorized" } }
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │        { type: EVENT, namespace: "/", data: ["foo"] }      │  │                                                            │  │  ◄───────────────────────────────────────────────────────  │  │        { type: EVENT, namespace: "/", data: ["bar"] }      │
```

```js
Client > { type: EVENT, namespace: "/", data: ["foo"] }
```

```js
Server > { type: EVENT, namespace: "/admin", data: ["bar"] }
```

```js
Client > { type: BINARY_EVENT, namespace: "/", data: ["baz", <Buffer <01 02 03 04>> ] }
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │   { type: EVENT, namespace: "/", data: ["foo"], id: 12 }   │  │  ◄───────────────────────────────────────────────────────  │  │    { type: ACK, namespace: "/", data: ["bar"], id: 12 }    │
```

```js
Client > { type: EVENT, namespace: "/", data: ["foo"], id: 12 }Server > { type: ACK, namespace: "/", data: [], id: 12 }
```

```js
Server > { type: EVENT, namespace: "/admin", data: ["foo"], id: 13 }Client > { type: ACK, namespace: "/admin", data: ["bar"], id: 13 }
```

```js
Client > { type: BINARY_EVENT, namespace: "/", data: ["foo", <buffer <01 02 03 04> ], id: 14 }Server > { type: ACK, namespace: "/", data: ["bar"], id: 14 }orServer > { type: EVENT, namespace: "/", data: ["foo" ], id: 15 }Client > { type: BINARY_ACK, namespace: "/", data: ["bar", <buffer <01 02 03 04>], id: 15 }
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │           { type: DISCONNECT, namespace: "/" }             │
```

```js
<packet type>[<# of binary attachments>-][<namespace>,][<acknowledgment id>][JSON-stringified payload without binary]+ binary attachments extracted
```

```js
{ type: CONNECT, namespace: "/" }
```

```js
{ type: CONNECT, namespace: "/admin", data: { sid: "oSO0OpakMV_3jnilAAAA" } }
```

```js
0/admin,{"sid":"oSO0OpakMV_3jnilAAAA"}
```

```js
{ type: CONNECT_ERROR, namespace: "/", data: { message: "Not authorized" } }
```

```js
4{"message":"Not authorized"}
```

```js
{ type: EVENT, namespace: "/", data: ["foo"] }
```

```js
2["foo"]
```

```js
{ type: EVENT, namespace: "/admin", data: ["bar"] }
```

```js
2/admin,["bar"]
```

```js
{ type: BINARY_EVENT, namespace: "/", data: ["baz", <Buffer <01 02 03 04>> ] }
```

```js
51-["baz",{"_placeholder":true,"num":0}]+ <Buffer <01 02 03 04>>
```

```js
{ type: BINARY_EVENT, namespace: "/admin", data: ["baz", <Buffer <01 02>>, <Buffer <03 04>> ] }
```

```js
52-/admin,["baz",{"_placeholder":true,"num":0},{"_placeholder":true,"num":1}]+ <Buffer <01 02>>+ <Buffer <03 04>>
```

```js
{ type: EVENT, namespace: "/", data: ["foo"], id: 12 }
```

```js
212["foo"]
```

```js
{ type: ACK, namespace: "/admin", data: ["bar"], id: 13 }
```

```js
3/admin,13["bar"]`
```

```js
{ type: BINARY_ACK, namespace: "/", data: ["bar", <Buffer <01 02 03 04>>], id: 15 }
```

```js
61-15["bar",{"_placeholder":true,"num":0}]+ <Buffer <01 02 03 04>>
```

```js
{ type: DISCONNECT, namespace: "/" }
```

```js
{ type: DISCONNECT, namespace: "/admin" }
```

```js
1/admin,
```

```js
GET /socket.io/?EIO=4&transport=polling&t=N8hyd6w< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-80{"sid":"lv_VI97HAXpY6yYWAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000,"maxPayload":1000000}
```

```js
0           => Engine.IO "open" packet type{"sid":...  => the Engine.IO handshake data
```

```js
POST /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-840
```

```js
4           => Engine.IO "message" packet type0           => Socket.IO "CONNECT" packet type
```

```js
GET /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-840{"sid":"wZX3oN0bSVIhsaknAAAI"}
```

```js
GET /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-842["hey","Jude"]
```

```js
4           => Engine.IO "message" packet type2           => Socket.IO "EVENT" packet type[...]       => content
```

```js
POST /socket.io/?EIO=4&transport=polling&t=N8hzxke&sid=lv_VI97HAXpY6yYWAAAC> Content-Type: text/plain; charset=UTF-842["hello"]\x1e42["world"]< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-8ok
```

```js
4           => Engine.IO "message" packet type2           => Socket.IO "EVENT" packet type["hello"]   => the 1st content\x1e        => separator4           => Engine.IO "message" packet type2           => Socket.IO "EVENT" packet type["world"]   => the 2nd content
```

```js
GET /socket.io/?EIO=4&transport=websocket&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 101 Switching Protocols
```

```js
< 2probe                                        => Engine.IO probe request> 3probe                                        => Engine.IO probe response> 5                                             => Engine.IO "upgrade" packet type> 42["hello"]> 42["world"]> 40/admin,                                     => request access to the admin namespace (Socket.IO "CONNECT" packet)< 40/admin,{"sid":"-G5j-67EZFp-q59rADQM"}       => grant access to the admin namespace> 42/admin,1["tellme"]                          => Socket.IO "EVENT" packet with acknowledgement< 461-/admin,1[{"_placeholder":true,"num":0}]   => Socket.IO "BINARY_ACK" packet with a placeholder< <binary>                                      => the binary attachment (sent in the following frame)... after a while without message> 2                                             => Engine.IO "ping" packet type< 3                                             => Engine.IO "pong" packet type> 1                                             => Engine.IO "close" packet type
```

```js
{  "type": 0,  "nsp": "/admin",  "data": {    "token": "123"  }}
```

```js
{  "type": 0,  "nsp": "/admin",  "data": {    "sid": "CjdVH4TQvovi1VvgAC5Z"  }}
```

```js
import { Server } from "socket.io";const io = new Server(3000, {  pingInterval: 300,  pingTimeout: 200,  maxPayload: 1000000,  cors: {    origin: "*"  }});io.on("connection", (socket) => {  socket.emit("auth", socket.handshake.auth);  socket.on("message", (...args) => {    socket.emit.apply(socket, ["message-back", ...args]);  });  socket.on("message-with-ack", (...args) => {    const ack = args.pop();    ack(...args);  })});io.of("/custom").on("connection", (socket) => {  socket.emit("auth", socket.handshake.auth);});
```

```js
// declare the namespaceconst namespace = io.of("/admin");// handle the connection to the namespacenamespace.on("connection", (socket) => {  // ...});
```

```js
// reach the main namespaceconst socket1 = io();// reach the "/admin" namespace (with the same underlying WebSocket connection)const socket2 = io("/admin");// handle the connection to the namespacesocket2.on("connect", () => {  // ...});
```

```js
// on one sidesocket.emit("hello", "foo", (arg) => {  console.log("received", arg);});// on the other sidesocket.on("hello", (arg, ack) => {  ack("bar");});
```

```js
CONNECT
```

```js
CONNECT
```

```js
CONNECT_ERROR
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │             { type: CONNECT, namespace: "/" }              │  │  ◄───────────────────────────────────────────────────────  │  │   { type: CONNECT, namespace: "/", data: { sid: "..." } }  │
```

```js
CONNECT
```

```js
"/"
```

```js
Client > { type: CONNECT, namespace: "/" }Server > { type: CONNECT, namespace: "/", data: { sid: "wZX3oN0bSVIhsaknAAAI" } }
```

```js
Client > { type: CONNECT, namespace: "/admin" }Server > { type: CONNECT, namespace: "/admin", data: { sid: "oSO0OpakMV_3jnilAAAA" } }
```

```js
Client > { type: CONNECT, namespace: "/admin", data: { "token": "123" } }Server > { type: CONNECT, namespace: "/admin", data: { sid: "iLnRaVGHY4B75TeVAAAB" } }
```

```js
Client > { type: CONNECT, namespace: "/" }Server > { type: CONNECT_ERROR, namespace: "/", data: { message: "Not authorized" } }
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │        { type: EVENT, namespace: "/", data: ["foo"] }      │  │                                                            │  │  ◄───────────────────────────────────────────────────────  │  │        { type: EVENT, namespace: "/", data: ["bar"] }      │
```

```js
Client > { type: EVENT, namespace: "/", data: ["foo"] }
```

```js
Server > { type: EVENT, namespace: "/admin", data: ["bar"] }
```

```js
Client > { type: BINARY_EVENT, namespace: "/", data: ["baz", <Buffer <01 02 03 04>> ] }
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │   { type: EVENT, namespace: "/", data: ["foo"], id: 12 }   │  │  ◄───────────────────────────────────────────────────────  │  │    { type: ACK, namespace: "/", data: ["bar"], id: 12 }    │
```

```js
ACK
```

```js
Client > { type: EVENT, namespace: "/", data: ["foo"], id: 12 }Server > { type: ACK, namespace: "/", data: [], id: 12 }
```

```js
Server > { type: EVENT, namespace: "/admin", data: ["foo"], id: 13 }Client > { type: ACK, namespace: "/admin", data: ["bar"], id: 13 }
```

```js
Client > { type: BINARY_EVENT, namespace: "/", data: ["foo", <buffer <01 02 03 04> ], id: 14 }Server > { type: ACK, namespace: "/", data: ["bar"], id: 14 }orServer > { type: EVENT, namespace: "/", data: ["foo" ], id: 15 }Client > { type: BINARY_ACK, namespace: "/", data: ["bar", <buffer <01 02 03 04>], id: 15 }
```

```js
DISCONNECT
```

```js
CLIENT                                                      SERVER  │  ───────────────────────────────────────────────────────►  │  │           { type: DISCONNECT, namespace: "/" }             │
```

```js
message
```

```js
"4"
```

```js
<packet type>[<# of binary attachments>-][<namespace>,][<acknowledgment id>][JSON-stringified payload without binary]+ binary attachments extracted
```

```js
{ type: CONNECT, namespace: "/" }
```

```js
{ type: CONNECT, namespace: "/admin", data: { sid: "oSO0OpakMV_3jnilAAAA" } }
```

```js
0/admin,{"sid":"oSO0OpakMV_3jnilAAAA"}
```

```js
{ type: CONNECT_ERROR, namespace: "/", data: { message: "Not authorized" } }
```

```js
4{"message":"Not authorized"}
```

```js
{ type: EVENT, namespace: "/", data: ["foo"] }
```

```js
2["foo"]
```

```js
{ type: EVENT, namespace: "/admin", data: ["bar"] }
```

```js
2/admin,["bar"]
```

```js
{ type: BINARY_EVENT, namespace: "/", data: ["baz", <Buffer <01 02 03 04>> ] }
```

```js
51-["baz",{"_placeholder":true,"num":0}]+ <Buffer <01 02 03 04>>
```

```js
{ type: BINARY_EVENT, namespace: "/admin", data: ["baz", <Buffer <01 02>>, <Buffer <03 04>> ] }
```

```js
52-/admin,["baz",{"_placeholder":true,"num":0},{"_placeholder":true,"num":1}]+ <Buffer <01 02>>+ <Buffer <03 04>>
```

```js
message
```

```js
"4"
```

```js
{ type: EVENT, namespace: "/", data: ["foo"] }
```

```js
42["foo"]
```

```js
{ type: EVENT, namespace: "/", data: ["foo"], id: 12 }
```

```js
212["foo"]
```

```js
{ type: ACK, namespace: "/admin", data: ["bar"], id: 13 }
```

```js
3/admin,13["bar"]`
```

```js
{ type: BINARY_ACK, namespace: "/", data: ["bar", <Buffer <01 02 03 04>>], id: 15 }
```

```js
61-15["bar",{"_placeholder":true,"num":0}]+ <Buffer <01 02 03 04>>
```

```js
{ type: DISCONNECT, namespace: "/" }
```

```js
{ type: DISCONNECT, namespace: "/admin" }
```

```js
1/admin,
```

```js
GET /socket.io/?EIO=4&transport=polling&t=N8hyd6w< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-80{"sid":"lv_VI97HAXpY6yYWAAAC","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000,"maxPayload":1000000}
```

```js
0           => Engine.IO "open" packet type{"sid":...  => the Engine.IO handshake data
```

```js
POST /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-840
```

```js
4           => Engine.IO "message" packet type0           => Socket.IO "CONNECT" packet type
```

```js
GET /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-840{"sid":"wZX3oN0bSVIhsaknAAAI"}
```

```js
socket.emit('hey', 'Jude')
```

```js
GET /socket.io/?EIO=4&transport=polling&t=N8hyd7H&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-842["hey","Jude"]
```

```js
4           => Engine.IO "message" packet type2           => Socket.IO "EVENT" packet type[...]       => content
```

```js
socket.emit('hello'); socket.emit('world');
```

```js
POST /socket.io/?EIO=4&transport=polling&t=N8hzxke&sid=lv_VI97HAXpY6yYWAAAC> Content-Type: text/plain; charset=UTF-842["hello"]\x1e42["world"]< HTTP/1.1 200 OK< Content-Type: text/plain; charset=UTF-8ok
```

```js
4           => Engine.IO "message" packet type2           => Socket.IO "EVENT" packet type["hello"]   => the 1st content\x1e        => separator4           => Engine.IO "message" packet type2           => Socket.IO "EVENT" packet type["world"]   => the 2nd content
```

```js
GET /socket.io/?EIO=4&transport=websocket&sid=lv_VI97HAXpY6yYWAAAC< HTTP/1.1 101 Switching Protocols
```

```js
< 2probe                                        => Engine.IO probe request> 3probe                                        => Engine.IO probe response> 5                                             => Engine.IO "upgrade" packet type> 42["hello"]> 42["world"]> 40/admin,                                     => request access to the admin namespace (Socket.IO "CONNECT" packet)< 40/admin,{"sid":"-G5j-67EZFp-q59rADQM"}       => grant access to the admin namespace> 42/admin,1["tellme"]                          => Socket.IO "EVENT" packet with acknowledgement< 461-/admin,1[{"_placeholder":true,"num":0}]   => Socket.IO "BINARY_ACK" packet with a placeholder< <binary>                                      => the binary attachment (sent in the following frame)... after a while without message> 2                                             => Engine.IO "ping" packet type< 3                                             => Engine.IO "pong" packet type> 1                                             => Engine.IO "close" packet type
```

```js
v3.0.0
```

```js
EIO=4
```

```js
CONNECT
```

```js
ERROR
```

```js
CONNECT_ERROR
```

```js
CONNECT
```

```js
{  "type": 0,  "nsp": "/admin",  "data": {    "token": "123"  }}
```

```js
{  "type": 0,  "nsp": "/admin",  "data": {    "sid": "CjdVH4TQvovi1VvgAC5Z"  }}
```

```js
CONNECT_ERROR
```

```js
v1.0.3
```

```js
v2.0.0
```

```js
EIO=3
```

```js
BINARY_ACK
```

```js
ACK
```

```js
socket.io@1.0.0...1.0.2
```

```js
BINARY_EVENT
```

```js
BINARY_EVENT
```

```js
test-suite/
```

```js
npm ci && npm test
```

```js
index.html
```

```js
import { Server } from "socket.io";const io = new Server(3000, {  pingInterval: 300,  pingTimeout: 200,  maxPayload: 1000000,  cors: {    origin: "*"  }});io.on("connection", (socket) => {  socket.emit("auth", socket.handshake.auth);  socket.on("message", (...args) => {    socket.emit.apply(socket, ["message-back", ...args]);  });  socket.on("message-with-ack", (...args) => {    const ack = args.pop();    ack(...args);  })});io.of("/custom").on("connection", (socket) => {  socket.emit("auth", socket.handshake.auth);});
```

# https://socket.io/docs/v4/testing

# Testing

You will find below some code examples with common testing libraries:

Installation:

Test suite:

Installation:

Test suite:

Installation:

Test suite:

Reference: https://mochajs.org/

Installation:

Test suite:

Installation:

Test suite:

Installation:

Test suite:

Reference: https://jestjs.io/

Installation:

Test suite:

Installation:

Test suite:

Installation:

Test suite:

Reference: https://github.com/ljharb/tape

Installation:

Test suite:

Installation:

Test suite:

Installation:

Test suite:

Reference: https://vitest.dev/

- Documentation
- Testing
- mocha
- jest
- tape
- vitest
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
- CommonJS
- ES modules
- TypeScript
```js
npm install --save-dev mocha chai
```

```js
const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");const { assert } = require("chai");function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.disconnect();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    assert.equal(result, "bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev mocha chai
```

```js
import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";import { assert } from "chai";function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.disconnect();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    assert.equal(result, "bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev mocha chai @types/mocha @types/chai
```

```js
import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";import { assert } from "chai";function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = (httpServer.address() as AddressInfo).port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.disconnect();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    assert.equal(result, "bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev jest
```

```js
const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });  test("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toBe("bar");  });  test("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev jest
```

```js
import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });  test("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toBe("bar");  });  test("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev jest @types/jest
```

```js
import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = (httpServer.address() as AddressInfo).port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });  test("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toBe("bar");  });  test("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev tape
```

```js
const test = require("tape");const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");let io, serverSocket, clientSocket;function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = httpServer.address().port;    clientSocket = ioc(`http://localhost:${port}`);    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works with an acknowledgement", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test("it works with emitWithAck()", async (t) => {  t.plan(1);  serverSocket.on("foo", (cb) => {    cb("bar");  });  const result = await clientSocket.emitWithAck("foo");  t.equal(result, "bar");});test("it works with waitFor()", async (t) => {  t.plan(1);  clientSocket.emit("baz");  await waitFor(serverSocket, "baz");  t.pass();});test.onFinish(() => {  io.close();  clientSocket.disconnect();});
```

```js
npm install --save-dev tape
```

```js
import { test } from "tape";import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";let io, serverSocket, clientSocket;function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = httpServer.address().port;    clientSocket = ioc(`http://localhost:${port}`);    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works with an acknowledgement", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test("it works with emitWithAck()", async (t) => {  t.plan(1);  serverSocket.on("foo", (cb) => {    cb("bar");  });  const result = await clientSocket.emitWithAck("foo");  t.equal(result, "bar");});test("it works with waitFor()", async (t) => {  t.plan(1);  clientSocket.emit("baz");  await waitFor(serverSocket, "baz");  t.pass();});test.onFinish(() => {  io.close();  clientSocket.disconnect();});
```

```js
npm install --save-dev tape
```

```js
import { test } from "tape";import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = (httpServer.address() as AddressInfo).port;    clientSocket = ioc(`http://localhost:${port}`);    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works with an acknowledgement", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test("it works with emitWithAck()", async (t) => {  t.plan(1);  serverSocket.on("foo", (cb) => {    cb("bar");  });  const result = await clientSocket.emitWithAck("foo");  t.equal(result, "bar");});test("it works with waitFor()", async (t) => {  t.plan(1);  clientSocket.emit("baz");  await waitFor(serverSocket, "baz");  t.pass();});test.onFinish(() => {  io.close();  clientSocket.disconnect();});
```

```js
npm install --save-dev vitest
```

```js
const { beforeAll, afterAll, describe, it, expect } = require("vitest");const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll(() => {    return new Promise((resolve) => {      const httpServer = createServer();      io = new Server(httpServer);      httpServer.listen(() => {        const port = httpServer.address().port;        clientSocket = ioc(`http://localhost:${port}`);        io.on("connection", (socket) => {          serverSocket = socket;        });        clientSocket.on("connect", resolve);      });    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  it("should work", () => {    return new Promise((resolve) => {      clientSocket.on("hello", (arg) => {        expect(arg).toEqual("world");        resolve();      });      serverSocket.emit("hello", "world");    });  });  it("should work with an acknowledgement", () => {    return new Promise((resolve) => {      serverSocket.on("hi", (cb) => {        cb("hola");      });      clientSocket.emit("hi", (arg) => {        expect(arg).toEqual("hola");        resolve();      });    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toEqual("bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev vitest
```

```js
import { beforeAll, afterAll, describe, it, expect } from "vitest";import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll(() => {    return new Promise((resolve) => {      const httpServer = createServer();      io = new Server(httpServer);      httpServer.listen(() => {        const port = httpServer.address().port;        clientSocket = ioc(`http://localhost:${port}`);        io.on("connection", (socket) => {          serverSocket = socket;        });        clientSocket.on("connect", resolve);      });    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  it("should work", () => {    return new Promise((resolve) => {      clientSocket.on("hello", (arg) => {        expect(arg).toEqual("world");        resolve();      });      serverSocket.emit("hello", "world");    });  });  it("should work with an acknowledgement", () => {    return new Promise((resolve) => {      serverSocket.on("hi", (cb) => {        cb("hola");      });      clientSocket.emit("hi", (arg) => {        expect(arg).toEqual("hola");        resolve();      });    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toEqual("bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev vitest
```

```js
import { beforeAll, afterAll, describe, it, expect } from "vitest";import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;  beforeAll(() => {    return new Promise((resolve) => {      const httpServer = createServer();      io = new Server(httpServer);      httpServer.listen(() => {        const port = (httpServer.address() as AddressInfo).port;        clientSocket = ioc(`http://localhost:${port}`);        io.on("connection", (socket) => {          serverSocket = socket;        });        clientSocket.on("connect", resolve);      });    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  it("should work", () => {    return new Promise((resolve) => {      clientSocket.on("hello", (arg) => {        expect(arg).toEqual("world");        resolve();      });      serverSocket.emit("hello", "world");    });  });  it("should work with an acknowledgement", () => {    return new Promise((resolve) => {      serverSocket.on("hi", (cb) => {        cb("hola");      });      clientSocket.emit("hi", (arg) => {        expect(arg).toEqual("hola");        resolve();      });    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toEqual("bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev mocha chai
```

```js
const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");const { assert } = require("chai");function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.disconnect();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    assert.equal(result, "bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev mocha chai
```

```js
import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";import { assert } from "chai";function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.disconnect();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    assert.equal(result, "bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev mocha chai @types/mocha @types/chai
```

```js
import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";import { assert } from "chai";function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;  before((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = (httpServer.address() as AddressInfo).port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  after(() => {    io.close();    clientSocket.disconnect();  });  it("should work", (done) => {    clientSocket.on("hello", (arg) => {      assert.equal(arg, "world");      done();    });    serverSocket.emit("hello", "world");  });  it("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      assert.equal(arg, "hola");      done();    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    assert.equal(result, "bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev jest
```

```js
const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });  test("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toBe("bar");  });  test("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev jest
```

```js
import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = httpServer.address().port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });  test("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toBe("bar");  });  test("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev jest @types/jest
```

```js
import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll((done) => {    const httpServer = createServer();    io = new Server(httpServer);    httpServer.listen(() => {      const port = (httpServer.address() as AddressInfo).port;      clientSocket = ioc(`http://localhost:${port}`);      io.on("connection", (socket) => {        serverSocket = socket;      });      clientSocket.on("connect", done);    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  test("should work", (done) => {    clientSocket.on("hello", (arg) => {      expect(arg).toBe("world");      done();    });    serverSocket.emit("hello", "world");  });  test("should work with an acknowledgement", (done) => {    serverSocket.on("hi", (cb) => {      cb("hola");    });    clientSocket.emit("hi", (arg) => {      expect(arg).toBe("hola");      done();    });  });  test("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toBe("bar");  });  test("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev tape
```

```js
const test = require("tape");const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");let io, serverSocket, clientSocket;function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = httpServer.address().port;    clientSocket = ioc(`http://localhost:${port}`);    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works with an acknowledgement", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test("it works with emitWithAck()", async (t) => {  t.plan(1);  serverSocket.on("foo", (cb) => {    cb("bar");  });  const result = await clientSocket.emitWithAck("foo");  t.equal(result, "bar");});test("it works with waitFor()", async (t) => {  t.plan(1);  clientSocket.emit("baz");  await waitFor(serverSocket, "baz");  t.pass();});test.onFinish(() => {  io.close();  clientSocket.disconnect();});
```

```js
npm install --save-dev tape
```

```js
import { test } from "tape";import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";let io, serverSocket, clientSocket;function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = httpServer.address().port;    clientSocket = ioc(`http://localhost:${port}`);    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works with an acknowledgement", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test("it works with emitWithAck()", async (t) => {  t.plan(1);  serverSocket.on("foo", (cb) => {    cb("bar");  });  const result = await clientSocket.emitWithAck("foo");  t.equal(result, "bar");});test("it works with waitFor()", async (t) => {  t.plan(1);  clientSocket.emit("baz");  await waitFor(serverSocket, "baz");  t.pass();});test.onFinish(() => {  io.close();  clientSocket.disconnect();});
```

```js
npm install --save-dev tape
```

```js
import { test } from "tape";import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}test("setup", (t) => {  const httpServer = createServer();  io = new Server(httpServer);  httpServer.listen(() => {    const port = (httpServer.address() as AddressInfo).port;    clientSocket = ioc(`http://localhost:${port}`);    io.on("connection", (socket) => {      serverSocket = socket;    });    clientSocket.on("connect", t.end);  });});test("it works", (t) => {  t.plan(1);  clientSocket.on("hello", (arg) => {    t.equal(arg, "world");  });  serverSocket.emit("hello", "world");});test("it works with an acknowledgement", (t) => {  t.plan(1);  serverSocket.on("hi", (cb) => {    cb("hola");  });  clientSocket.emit("hi", (arg) => {    t.equal(arg, "hola");  });});test("it works with emitWithAck()", async (t) => {  t.plan(1);  serverSocket.on("foo", (cb) => {    cb("bar");  });  const result = await clientSocket.emitWithAck("foo");  t.equal(result, "bar");});test("it works with waitFor()", async (t) => {  t.plan(1);  clientSocket.emit("baz");  await waitFor(serverSocket, "baz");  t.pass();});test.onFinish(() => {  io.close();  clientSocket.disconnect();});
```

```js
npm install --save-dev vitest
```

```js
const { beforeAll, afterAll, describe, it, expect } = require("vitest");const { createServer } = require("node:http");const { Server } = require("socket.io");const ioc = require("socket.io-client");function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll(() => {    return new Promise((resolve) => {      const httpServer = createServer();      io = new Server(httpServer);      httpServer.listen(() => {        const port = httpServer.address().port;        clientSocket = ioc(`http://localhost:${port}`);        io.on("connection", (socket) => {          serverSocket = socket;        });        clientSocket.on("connect", resolve);      });    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  it("should work", () => {    return new Promise((resolve) => {      clientSocket.on("hello", (arg) => {        expect(arg).toEqual("world");        resolve();      });      serverSocket.emit("hello", "world");    });  });  it("should work with an acknowledgement", () => {    return new Promise((resolve) => {      serverSocket.on("hi", (cb) => {        cb("hola");      });      clientSocket.emit("hi", (arg) => {        expect(arg).toEqual("hola");        resolve();      });    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toEqual("bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev vitest
```

```js
import { beforeAll, afterAll, describe, it, expect } from "vitest";import { createServer } from "node:http";import { io as ioc } from "socket.io-client";import { Server } from "socket.io";function waitFor(socket, event) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io, serverSocket, clientSocket;  beforeAll(() => {    return new Promise((resolve) => {      const httpServer = createServer();      io = new Server(httpServer);      httpServer.listen(() => {        const port = httpServer.address().port;        clientSocket = ioc(`http://localhost:${port}`);        io.on("connection", (socket) => {          serverSocket = socket;        });        clientSocket.on("connect", resolve);      });    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  it("should work", () => {    return new Promise((resolve) => {      clientSocket.on("hello", (arg) => {        expect(arg).toEqual("world");        resolve();      });      serverSocket.emit("hello", "world");    });  });  it("should work with an acknowledgement", () => {    return new Promise((resolve) => {      serverSocket.on("hi", (cb) => {        cb("hola");      });      clientSocket.emit("hi", (arg) => {        expect(arg).toEqual("hola");        resolve();      });    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toEqual("bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

```js
npm install --save-dev vitest
```

```js
import { beforeAll, afterAll, describe, it, expect } from "vitest";import { createServer } from "node:http";import { type AddressInfo } from "node:net";import { io as ioc, type Socket as ClientSocket } from "socket.io-client";import { Server, type Socket as ServerSocket } from "socket.io";function waitFor(socket: ServerSocket | ClientSocket, event: string) {  return new Promise((resolve) => {    socket.once(event, resolve);  });}describe("my awesome project", () => {  let io: Server, serverSocket: ServerSocket, clientSocket: ClientSocket;  beforeAll(() => {    return new Promise((resolve) => {      const httpServer = createServer();      io = new Server(httpServer);      httpServer.listen(() => {        const port = (httpServer.address() as AddressInfo).port;        clientSocket = ioc(`http://localhost:${port}`);        io.on("connection", (socket) => {          serverSocket = socket;        });        clientSocket.on("connect", resolve);      });    });  });  afterAll(() => {    io.close();    clientSocket.disconnect();  });  it("should work", () => {    return new Promise((resolve) => {      clientSocket.on("hello", (arg) => {        expect(arg).toEqual("world");        resolve();      });      serverSocket.emit("hello", "world");    });  });  it("should work with an acknowledgement", () => {    return new Promise((resolve) => {      serverSocket.on("hi", (cb) => {        cb("hola");      });      clientSocket.emit("hi", (arg) => {        expect(arg).toEqual("hola");        resolve();      });    });  });  it("should work with emitWithAck()", async () => {    serverSocket.on("foo", (cb) => {      cb("bar");    });    const result = await clientSocket.emitWithAck("foo");    expect(result).toEqual("bar");  });  it("should work with waitFor()", () => {    clientSocket.emit("baz");    return waitFor(serverSocket, "baz");  });});
```

# https://socket.io/docs/v4/troubleshooting-connection-issues

# Troubleshooting connection issues

## Problem: the socket is not able to connect​

## Problem: the socket gets disconnected​

## Problem: the socket is stuck in HTTP long-polling​

## Other common gotchas​

### Troubleshooting steps​

### Possible explanations​

### Troubleshooting steps​

### Possible explanations​

### Troubleshooting steps​

### Possible explanations​

### Duplicate event registration​

### Delayed event handler registration​

### Usage of the socket.id attribute​

### Deployment on a serverless platform​

The Admin UI can give you additional insights about the status of your Socket.IO deployment.

Common/known issues:

Other common gotchas:

On the client side, the connect_error event provides additional information:

On the server side, the connection_error event may also provide some additional insights:

Here is the list of possible error codes:

As explained in the "What Socket.IO is not" section, the Socket.IO client is not a WebSocket implementation and thus will not be able to establish a connection with a WebSocket server, even with transports: ["websocket"]:

Please make sure the Socket.IO server is actually reachable at the given URL. You can test it with:

which should return something like this:

If that's not the case, please check that the Socket.IO server is running, and that there is nothing in between that prevents the connection.

v1/v2 servers (which implement the v3 of the protocol, hence the EIO=3) will return something like this:

Maintaining backward compatibility is a top priority for us, but in some particular cases we had to implement some breaking changes at the protocol level:

For example, reaching a v3/v4 server with a v1/v2 client will result in the following response:

Here is the compatibility table for the JS client:

[1] Yes, with allowEIO3: true

Here is the compatibility table for the Java client:

[1] Yes, with allowEIO3: true

Here is the compatibility table for the Swift client:

[1] Yes, with allowEIO3: true (server) and .connectParams(["EIO": "3"]) (client):

[2] Yes, allowEIO3: true (server)

[3] Yes, with .version(.two) (client):

If you see the following error in your console:

It probably means that:

Please see the documentation here.

When scaling to multiple Socket.IO servers, you need to make sure that all the requests of a given Socket.IO session reach the same Socket.IO server. The explanation can be found here.

Failure to do so will result in HTTP 400 responses with the code: {"code":1,"message":"Session ID unknown"}

Please see the documentation here.

By default, the client sends — and the server expects — HTTP requests with the "/socket.io/" request path.

This can be controlled with the path option:

Server

Client

In that case, the HTTP requests will look like <SERVER_URL>/my-custom-path/?EIO=4&transport=polling[&...].

means the client will try to reach the namespace named "/my-custom-path/", but the request path will still be "/socket.io/".

First and foremost, please note that disconnections are common and expected, even on a stable Internet connection:

That being said, the Socket.IO client will always try to reconnect, unless specifically told otherwise.

The disconnect event provides additional information:

The possible reasons are listed here.

If the disconnection happens at a regular interval, this might indicate that something between the server and the client is not properly configured and closes the connection:

The value of nginx's proxy_read_timeout (60 seconds by default) must be bigger than Socket.IO's pingInterval + pingTimeout (45 seconds by default), else it will forcefully close the connection if no data is sent after the given delay and the client will get a "transport close" error.

The value of httpd's ProxyTimeout (60 seconds by default) must be bigger than Socket.IO's pingInterval + pingTimeout (45 seconds by default), else it will forcefully close the connection if no data is sent after the given delay and the client will get a "transport close" error.

When a browser tab is not in focus, some browsers (like Chrome) throttle JavaScript timers, which could lead to a disconnection by ping timeout in Socket.IO v2, as the heartbeat mechanism relied on setTimeout function on the client side.

As a workaround, you can increase the pingTimeout value on the server side:

Please note that upgrading to Socket.IO v4 (at least socket.io-client@4.1.3, due to this) should prevent this kind of issues, as the heartbeat mechanism has been reversed (the server now sends PING packets).

Since the format of the packets sent over the WebSocket transport is similar in v2 and v3/v4, you might be able to connect with an incompatible client (see above), but the connection will eventually be closed after a given delay.

So if you are experiencing a regular disconnection after 30 seconds (which was the sum of the values of pingTimeout and pingInterval in Socket.IO v2), this is certainly due to a version incompatibility.

If you get disconnected while sending a huge payload, this may mean that you have reached the maxHttpBufferSize value, which defaults to 1 MB. Please adjust it according to your needs:

A huge payload taking more time to upload than the value of the pingTimeout option can also trigger a disconnection (since the heartbeat mechanism fails during the upload). Please adjust it according to your needs:

In most cases, you should see something like this:

If you don't see a HTTP 101 Switching Protocols response for the 4th request, that means that something between the server and your browser is preventing the WebSocket connection.

Please note that this is not necessarily blocking since the connection is still established with HTTP long-polling, but it is less efficient.

You can get the name of the current transport with:

Client-side

Server-side

If a proxy like nginx or Apache HTTPD is not properly configured to accept WebSocket connections, then you might get a TRANSPORT_MISMATCH error:

Which means that the Socket.IO server does not receive the necessary Connection: upgrade header (you can check the err.req.headers object).

Please see the documentation here.

Please see the solution here.

On the client side, the connect event will be emitted every time the socket reconnects, so the event listeners must be registered outside the connect event listener:

BAD ⚠️

GOOD 👍

If that's not the case, your event listener might be called multiple times.

BAD ⚠️

GOOD 👍

Please note that, unless connection state recovery is enabled, the id attribute is an ephemeral ID that is not meant to be used in your application (or only for debugging purposes) because:

Please use a regular session ID instead (either sent in a cookie, or stored in the localStorage and sent in the auth payload).

See also:

Since most serverless platforms (such as Vercel) bill by the duration of the request handler, maintaining a long-running connection with Socket.IO (or even plain WebSocket) is not recommended.

References:

- Documentation
- Troubleshooting
- the socket is not able to connect
- the socket gets disconnected
- the socket is stuck in HTTP long-polling
- Duplicate event registration
- Delayed event handler registration
- Usage of the socket.id attribute
- Deployment on a serverless platform
- from v1.x to v2.0.0 (released in May 2017), to improve the compatibility with non-Javascript clients (see here)
- from v2.x to v3.0.0 (released in November 2020), to fix some long-standing issues in the protocol once for all (see here)
- either you are not actually reaching the Socket.IO server (see above)
- or you didn't enable Cross-Origin Resource Sharing (CORS) on the server-side.
- anything between the user and the Socket.IO server may encounter a temporary failure or be restarted
- the server itself may be killed as part of an autoscaling policy
- the user may lose connection or switch from WiFi to 4G, in case of a mobile browser
- the browser itself may freeze an inactive tab
- nginx
- Apache HTTP Server
- the Engine.IO handshake (contains the session ID — here, zBjrh...AAAK — that is used in subsequent requests)
- the Socket.IO handshake request (contains the value of the auth option)
- the Socket.IO handshake response (contains the Socket#id)
- the WebSocket connection
- the first HTTP long-polling request, which is closed once the WebSocket connection is established
- this ID is regenerated after each reconnection (for example when the WebSocket connection is severed, or when the user refreshes the page)
- two different browser tabs will have two different IDs
- there is no message queue stored for a given ID on the server (i.e. if the client is disconnected, the messages sent from the server to this ID are lost)
- Part II of our private message guide
- How to deal with cookies
- https://vercel.com/guides/do-vercel-serverless-functions-support-websocket-connections
- https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-websocket-api.html
```js
socket.on("connect_error", (err) => {  // the reason of the error, for example "xhr poll error"  console.log(err.message);  // some additional description, for example the status code of the initial HTTP response  console.log(err.description);  // some additional context, for example the XMLHttpRequest object  console.log(err.context);});
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
const socket = io("ws://echo.websocket.org", {  transports: ["websocket"]});
```

```js
curl "<the server URL>/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}
```

```js
96:0{"sid":"ptzi_578ycUci8WLB9G1","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}2:40
```

```js
< HTTP/1.1 400 Bad Request< Content-Type: application/json{"code":5,"message":"Unsupported protocol version"}
```

```js
SocketManager(socketURL: URL(string:"http://localhost:8087/")!, config: [.connectParams(["EIO": "3"])])
```

```js
SocketManager(socketURL: URL(string:"http://localhost:8087/")!, config: [.version(.two)])
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ...
```

```js
import { Server } from "socket.io";const io = new Server({  path: "/my-custom-path/"});io.listen(3000);
```

```js
import { io } from "socket.io-client";const socket = io(SERVER_URL, {  path: "/my-custom-path/"});
```

```js
import { io } from "socket.io-client";const socket = io("/my-custom-path/");
```

```js
socket.on("disconnect", (reason, details) => {  // the reason of the disconnection, for example "transport error"  console.log(reason);  // the low-level reason of the disconnection, for example "xhr post error"  console.log(details.message);  // some additional description, for example the status code of the HTTP response  console.log(details.description);  // some additional context, for example the XMLHttpRequest object  console.log(details.context);});
```

```js
const io = new Server({  pingTimeout: 60000});
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
const io = require("socket.io")(httpServer, {  pingTimeout: 60000});
```

```js
socket.on("connect", () => {  const transport = socket.io.engine.transport.name; // in most cases, "polling"  socket.io.engine.on("upgrade", () => {    const upgradedTransport = socket.io.engine.transport.name; // in most cases, "websocket"  });});
```

```js
io.on("connection", (socket) => {  const transport = socket.conn.transport.name; // in most cases, "polling"  socket.conn.on("upgrade", () => {    const upgradedTransport = socket.conn.transport.name; // in most cases, "websocket"  });});
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.code);     // 3  console.log(err.message);  // "Bad request"  console.log(err.context);  // { name: 'TRANSPORT_MISMATCH', transport: 'websocket', previousTransport: 'polling' }});
```

```js
socket.on("connect", () => {  socket.on("foo", () => {    // ...  });});
```

```js
socket.on("connect", () => {  // ...});socket.on("foo", () => {  // ...});
```

```js
io.on("connection", async (socket) => {  await longRunningOperation();  // WARNING! Some packets might be received by the server but without handler  socket.on("hello", () => {    // ...  });});
```

```js
io.on("connection", async (socket) => {  socket.on("hello", () => {    // ...  });  await longRunningOperation();});
```

```js
socket.id
```

```js
connect_error
```

```js
socket.on("connect_error", (err) => {  // the reason of the error, for example "xhr poll error"  console.log(err.message);  // some additional description, for example the status code of the initial HTTP response  console.log(err.description);  // some additional context, for example the XMLHttpRequest object  console.log(err.context);});
```

```js
connection_error
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.req);      // the request object  console.log(err.code);     // the error code, for example 1  console.log(err.message);  // the error message, for example "Session ID unknown"  console.log(err.context);  // some additional error context});
```

```js
allowRequest()
```

```js
transports: ["websocket"]
```

```js
const socket = io("ws://echo.websocket.org", {  transports: ["websocket"]});
```

```js
curl "<the server URL>/socket.io/?EIO=4&transport=polling"
```

```js
0{"sid":"Lbo5JLzTotvW3g2LAAAA","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":20000}
```

```js
EIO=3
```

```js
96:0{"sid":"ptzi_578ycUci8WLB9G1","upgrades":["websocket"],"pingInterval":25000,"pingTimeout":5000}2:40
```

```js
v4.0.0
```

```js
< HTTP/1.1 400 Bad Request< Content-Type: application/json{"code":5,"message":"Unsupported protocol version"}
```

```js
.connectParams(["EIO": "3"])
```

```js
SocketManager(socketURL: URL(string:"http://localhost:8087/")!, config: [.connectParams(["EIO": "3"])])
```

```js
.version(.two)
```

```js
SocketManager(socketURL: URL(string:"http://localhost:8087/")!, config: [.version(.two)])
```

```js
Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at ...
```

```js
{"code":1,"message":"Session ID unknown"}
```

```js
path
```

```js
import { Server } from "socket.io";const io = new Server({  path: "/my-custom-path/"});io.listen(3000);
```

```js
import { io } from "socket.io-client";const socket = io(SERVER_URL, {  path: "/my-custom-path/"});
```

```js
<SERVER_URL>/my-custom-path/?EIO=4&transport=polling[&...]
```

```js
import { io } from "socket.io-client";const socket = io("/my-custom-path/");
```

```js
disconnect
```

```js
socket.on("disconnect", (reason, details) => {  // the reason of the disconnection, for example "transport error"  console.log(reason);  // the low-level reason of the disconnection, for example "xhr post error"  console.log(details.message);  // some additional description, for example the status code of the HTTP response  console.log(details.description);  // some additional context, for example the XMLHttpRequest object  console.log(details.context);});
```

```js
proxy_read_timeout
```

```js
pingInterval + pingTimeout
```

```js
ProxyTimeout
```

```js
pingInterval + pingTimeout
```

```js
setTimeout
```

```js
pingTimeout
```

```js
const io = new Server({  pingTimeout: 60000});
```

```js
socket.io-client@4.1.3
```

```js
maxHttpBufferSize
```

```js
const io = require("socket.io")(httpServer, {  maxHttpBufferSize: 1e8});
```

```js
pingTimeout
```

```js
const io = require("socket.io")(httpServer, {  pingTimeout: 60000});
```

```js
zBjrh...AAAK
```

```js
auth
```

```js
socket.on("connect", () => {  const transport = socket.io.engine.transport.name; // in most cases, "polling"  socket.io.engine.on("upgrade", () => {    const upgradedTransport = socket.io.engine.transport.name; // in most cases, "websocket"  });});
```

```js
io.on("connection", (socket) => {  const transport = socket.conn.transport.name; // in most cases, "polling"  socket.conn.on("upgrade", () => {    const upgradedTransport = socket.conn.transport.name; // in most cases, "websocket"  });});
```

```js
TRANSPORT_MISMATCH
```

```js
io.engine.on("connection_error", (err) => {  console.log(err.code);     // 3  console.log(err.message);  // "Bad request"  console.log(err.context);  // { name: 'TRANSPORT_MISMATCH', transport: 'websocket', previousTransport: 'polling' }});
```

```js
Connection: upgrade
```

```js
err.req.headers
```

```js
express-status-monitor
```

```js
connect
```

```js
connect
```

```js
socket.on("connect", () => {  socket.on("foo", () => {    // ...  });});
```

```js
socket.on("connect", () => {  // ...});socket.on("foo", () => {  // ...});
```

```js
io.on("connection", async (socket) => {  await longRunningOperation();  // WARNING! Some packets might be received by the server but without handler  socket.on("hello", () => {    // ...  });});
```

```js
io.on("connection", async (socket) => {  socket.on("hello", () => {    // ...  });  await longRunningOperation();});
```

```js
socket.id
```

```js
auth
```

# https://socket.io/docs/v4/tutorial/api-overview

### Basic emit​

### Acknowledgements​

### Catch-all listeners​

### Broadcasting​

### Rooms​

The following methods are available for both the client and the server.

As we have seen in step #4, you can send any data to the other side with socket.emit():

Client

Server

Server

Client

You can send any number of arguments, and all serializable data structures are supported, including binary objects like ArrayBuffer, TypedArray or Buffer (Node.js only):

Client

Server

Server

Client

Calling JSON.stringify() on objects is not needed:

It comes in two flavors:

You can add a callback as the last argument of the emit(), and this callback will be called once the other side has acknowledged the event:

Client

Server

Server

Client

The emitWithAck() method provides the same functionality, but returns a Promise which will resolve once the other side acknowledges the event:

Client

Server

Server

Client

Environments that do not support Promises (such as Internet Explorer) will need to add a polyfill or use a compiler like babel in order to use this feature (but this is out of the scope of this tutorial).

A catch-all listeners is a listener that will be called for any incoming event. This is useful for debugging your application:

Sender

Receiver

Similarly, for outgoing packets:

As we have seen in step #5, you can broadcast an event to all connected clients with io.emit():

In Socket.IO jargon, a room is an arbitrary channel that sockets can join and leave. It can be used to broadcast events to a subset of connected clients:

- From client to server
- From server to client
- From client to server
- From server to client
- From client to server
- From server to client
- From client to server
- From server to client
```js
socket.emit('hello', 'world');
```

```js
io.on('connection', (socket) => {  socket.on('hello', (arg) => {    console.log(arg); // 'world'  });});
```

```js
io.on('connection', (socket) => {  socket.emit('hello', 'world');});
```

```js
socket.on('hello', (arg) => {  console.log(arg); // 'world'});
```

```js
socket.emit('hello', 1, '2', { 3: '4', 5: Uint8Array.from([6]) });
```

```js
io.on('connection', (socket) => {  socket.on('hello', (arg1, arg2, arg3) => {    console.log(arg1); // 1    console.log(arg2); // '2'    console.log(arg3); // { 3: '4', 5: <Buffer 06> }  });});
```

```js
io.on('connection', (socket) => {  socket.emit('hello', 1, '2', { 3: '4', 5: Buffer.from([6]) });});
```

```js
socket.on('hello', (arg1, arg2, arg3) => {  console.log(arg1); // 1  console.log(arg2); // '2'  console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] }});
```

```js
// BADsocket.emit('hello', JSON.stringify({ name: 'John' }));// GOODsocket.emit('hello', { name: 'John' });
```

```js
socket.timeout(5000).emit('request', { foo: 'bar' }, 'baz', (err, response) => {  if (err) {    // the server did not acknowledge the event in the given delay  } else {    console.log(response.status); // 'ok'  }});
```

```js
io.on('connection', (socket) => {  socket.on('request', (arg1, arg2, callback) => {    console.log(arg1); // { foo: 'bar' }    console.log(arg2); // 'baz'    callback({      status: 'ok'    });  });});
```

```js
io.on('connection', (socket) => {  socket.timeout(5000).emit('request', { foo: 'bar' }, 'baz', (err, response) => {    if (err) {      // the client did not acknowledge the event in the given delay    } else {      console.log(response.status); // 'ok'    }  });});
```

```js
socket.on('request', (arg1, arg2, callback) => {  console.log(arg1); // { foo: 'bar' }  console.log(arg2); // 'baz'  callback({    status: 'ok'  });});
```

```js
try {  const response = await socket.timeout(5000).emitWithAck('request', { foo: 'bar' }, 'baz');  console.log(response.status); // 'ok'} catch (e) {  // the server did not acknowledge the event in the given delay}
```

```js
io.on('connection', (socket) => {  socket.on('request', (arg1, arg2, callback) => {    console.log(arg1); // { foo: 'bar' }    console.log(arg2); // 'baz'    callback({      status: 'ok'    });  });});
```

```js
io.on('connection', async (socket) => {  try {    const response = await socket.timeout(5000).emitWithAck('request', { foo: 'bar' }, 'baz');    console.log(response.status); // 'ok'  } catch (e) {    // the client did not acknowledge the event in the given delay  }});
```

```js
socket.on('request', (arg1, arg2, callback) => {  console.log(arg1); // { foo: 'bar' }  console.log(arg2); // 'baz'  callback({    status: 'ok'  });});
```

```js
socket.emit('hello', 1, '2', { 3: '4', 5: Uint8Array.from([6]) });
```

```js
socket.onAny((eventName, ...args) => {  console.log(eventName); // 'hello'  console.log(args); // [ 1, '2', { 3: '4', 5: ArrayBuffer (1) [ 6 ] } ]});
```

```js
socket.onAnyOutgoing((eventName, ...args) => {  console.log(eventName); // 'hello'  console.log(args); // [ 1, '2', { 3: '4', 5: ArrayBuffer (1) [ 6 ] } ]});
```

```js
io.emit('hello', 'world');
```

```js
io.on('connection', (socket) => {  // join the room named 'some room'  socket.join('some room');    // broadcast to all connected clients in the room  io.to('some room').emit('hello', 'world');  // broadcast to all connected clients except those in the room  io.except('some room').emit('hello', 'world');  // leave the room  socket.leave('some room');});
```

```js
socket.emit()
```

```js
socket.emit('hello', 'world');
```

```js
io.on('connection', (socket) => {  socket.on('hello', (arg) => {    console.log(arg); // 'world'  });});
```

```js
io.on('connection', (socket) => {  socket.emit('hello', 'world');});
```

```js
socket.on('hello', (arg) => {  console.log(arg); // 'world'});
```

```js
socket.emit('hello', 1, '2', { 3: '4', 5: Uint8Array.from([6]) });
```

```js
io.on('connection', (socket) => {  socket.on('hello', (arg1, arg2, arg3) => {    console.log(arg1); // 1    console.log(arg2); // '2'    console.log(arg3); // { 3: '4', 5: <Buffer 06> }  });});
```

```js
io.on('connection', (socket) => {  socket.emit('hello', 1, '2', { 3: '4', 5: Buffer.from([6]) });});
```

```js
socket.on('hello', (arg1, arg2, arg3) => {  console.log(arg1); // 1  console.log(arg2); // '2'  console.log(arg3); // { 3: '4', 5: ArrayBuffer (1) [ 6 ] }});
```

```js
JSON.stringify()
```

```js
// BADsocket.emit('hello', JSON.stringify({ name: 'John' }));// GOODsocket.emit('hello', { name: 'John' });
```

```js
emit()
```

```js
socket.timeout(5000).emit('request', { foo: 'bar' }, 'baz', (err, response) => {  if (err) {    // the server did not acknowledge the event in the given delay  } else {    console.log(response.status); // 'ok'  }});
```

```js
io.on('connection', (socket) => {  socket.on('request', (arg1, arg2, callback) => {    console.log(arg1); // { foo: 'bar' }    console.log(arg2); // 'baz'    callback({      status: 'ok'    });  });});
```

```js
io.on('connection', (socket) => {  socket.timeout(5000).emit('request', { foo: 'bar' }, 'baz', (err, response) => {    if (err) {      // the client did not acknowledge the event in the given delay    } else {      console.log(response.status); // 'ok'    }  });});
```

```js
socket.on('request', (arg1, arg2, callback) => {  console.log(arg1); // { foo: 'bar' }  console.log(arg2); // 'baz'  callback({    status: 'ok'  });});
```

```js
emitWithAck()
```

```js
try {  const response = await socket.timeout(5000).emitWithAck('request', { foo: 'bar' }, 'baz');  console.log(response.status); // 'ok'} catch (e) {  // the server did not acknowledge the event in the given delay}
```

```js
io.on('connection', (socket) => {  socket.on('request', (arg1, arg2, callback) => {    console.log(arg1); // { foo: 'bar' }    console.log(arg2); // 'baz'    callback({      status: 'ok'    });  });});
```

```js
io.on('connection', async (socket) => {  try {    const response = await socket.timeout(5000).emitWithAck('request', { foo: 'bar' }, 'baz');    console.log(response.status); // 'ok'  } catch (e) {    // the client did not acknowledge the event in the given delay  }});
```

```js
socket.on('request', (arg1, arg2, callback) => {  console.log(arg1); // { foo: 'bar' }  console.log(arg2); // 'baz'  callback({    status: 'ok'  });});
```

```js
socket.emit('hello', 1, '2', { 3: '4', 5: Uint8Array.from([6]) });
```

```js
socket.onAny((eventName, ...args) => {  console.log(eventName); // 'hello'  console.log(args); // [ 1, '2', { 3: '4', 5: ArrayBuffer (1) [ 6 ] } ]});
```

```js
socket.onAnyOutgoing((eventName, ...args) => {  console.log(eventName); // 'hello'  console.log(args); // [ 1, '2', { 3: '4', 5: ArrayBuffer (1) [ 6 ] } ]});
```

```js
io.emit()
```

```js
io.emit('hello', 'world');
```

```js
io.on('connection', (socket) => {  // join the room named 'some room'  socket.join('some room');    // broadcast to all connected clients in the room  io.to('some room').emit('hello', 'world');  // broadcast to all connected clients except those in the room  io.except('some room').emit('hello', 'world');  // leave the room  socket.leave('some room');});
```

# https://socket.io/docs/v4/tutorial/ending-notes

# Ending notes

## Final server code​

## Final client code​

## Homework​

## Getting this example​

## Next steps​

Here are some ideas to improve the application:

You can find it on GitHub here.

Please check out:

- Ending notes
- CommonJS
- ES modules
- ES6
- ES5
- Broadcast a message to connected users when someone connects or disconnects.
- Add support for nicknames.
- Don’t send the same message to the user that sent it. Instead, append the message directly as soon as they press enter.
- Add “{user} is typing” functionality.
- Show who’s online.
- Add private messaging.
- Share your improvements!
- our other examples
- our Troubleshooting guide
- the Emit cheatsheet
- the different sections of our guide
```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const sqlite3 = require('sqlite3');const { open } = require('sqlite');const { availableParallelism } = require('node:os');const cluster = require('node:cluster');const { createAdapter, setupPrimary } = require('@socket.io/cluster-adapter');if (cluster.isPrimary) {  const numCPUs = availableParallelism();  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }  return setupPrimary();}async function main() {  const db = await open({    filename: 'chat.db',    driver: sqlite3.Database  });  await db.exec(`    CREATE TABLE IF NOT EXISTS messages (      id INTEGER PRIMARY KEY AUTOINCREMENT,      client_offset TEXT UNIQUE,      content TEXT    );  `);  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    adapter: createAdapter()  });  app.get('/', (req, res) => {    res.sendFile(join(__dirname, 'index.html'));  });  io.on('connection', async (socket) => {    socket.on('chat message', async (msg, clientOffset, callback) => {      let result;      try {        result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);      } catch (e) {        if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {          callback();        } else {          // nothing to do, just let the client retry        }        return;      }      io.emit('chat message', msg, result.lastID);      callback();    });    if (!socket.recovered) {      try {        await db.each('SELECT id, content FROM messages WHERE id > ?',          [socket.handshake.auth.serverOffset || 0],          (_err, row) => {            socket.emit('chat message', row.content, row.id);          }        )      } catch (e) {        // something went wrong      }    }  });  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}main();
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';import { Server } from 'socket.io';import sqlite3 from 'sqlite3';import { open } from 'sqlite';import { availableParallelism } from 'node:os';import cluster from 'node:cluster';import { createAdapter, setupPrimary } from '@socket.io/cluster-adapter';if (cluster.isPrimary) {  const numCPUs = availableParallelism();  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }  setupPrimary();} else {  const db = await open({    filename: 'chat.db',    driver: sqlite3.Database  });  await db.exec(`    CREATE TABLE IF NOT EXISTS messages (      id INTEGER PRIMARY KEY AUTOINCREMENT,      client_offset TEXT UNIQUE,      content TEXT    );  `);  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    adapter: createAdapter()  });  const __dirname = dirname(fileURLToPath(import.meta.url));  app.get('/', (req, res) => {    res.sendFile(join(__dirname, 'index.html'));  });  io.on('connection', async (socket) => {    socket.on('chat message', async (msg, clientOffset, callback) => {      let result;      try {        result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);      } catch (e) {        if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {          callback();        } else {          // nothing to do, just let the client retry        }        return;      }      io.emit('chat message', msg, result.lastID);      callback();    });    if (!socket.recovered) {      try {        await db.each('SELECT id, content FROM messages WHERE id > ?',          [socket.handshake.auth.serverOffset || 0],          (_err, row) => {            socket.emit('chat message', row.content, row.id);          }        )      } catch (e) {        // something went wrong      }    }  });  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}
```

```js
<!DOCTYPE html><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1.0">    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>    <script src="/socket.io/socket.io.js"></script>    <script>      let counter = 0;        const socket = io({        ackTimeout: 10000,        retries: 3,        auth: {          serverOffset: 0        }      });        const form = document.getElementById('form');      const input = document.getElementById('input');      const messages = document.getElementById('messages');        form.addEventListener('submit', (e) => {        e.preventDefault();        if (input.value) {          const clientOffset = `${socket.id}-${counter++}`;          socket.emit('chat message', input.value, clientOffset);          input.value = '';        }      });        socket.on('chat message', (msg, serverOffset) => {        const item = document.createElement('li');        item.textContent = msg;        messages.appendChild(item);        window.scrollTo(0, document.body.scrollHeight);        socket.auth.serverOffset = serverOffset;      });    </script>  </body></html>
```

```js
<!DOCTYPE html><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1.0">    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>    <script src="/socket.io/socket.io.js"></script>    <script>      var counter = 0;        var socket = io({        ackTimeout: 10000,        retries: 3,        auth: {          serverOffset: 0        }      });        var form = document.getElementById('form');      var input = document.getElementById('input');      var messages = document.getElementById('messages');        form.addEventListener('submit', function(e) {        e.preventDefault();        if (input.value) {          const clientOffset = `${socket.id}-${counter++}`;          socket.emit('chat message', input.value, clientOffset);          input.value = '';        }      });        socket.on('chat message', function(msg, serverOffset) {        var item = document.createElement('li');        item.textContent = msg;        messages.appendChild(item);        window.scrollTo(0, document.body.scrollHeight);        socket.auth.serverOffset = serverOffset;      });    </script>  </body></html>
```

```js
git clone https://github.com/socketio/chat-example.git
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const sqlite3 = require('sqlite3');const { open } = require('sqlite');const { availableParallelism } = require('node:os');const cluster = require('node:cluster');const { createAdapter, setupPrimary } = require('@socket.io/cluster-adapter');if (cluster.isPrimary) {  const numCPUs = availableParallelism();  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }  return setupPrimary();}async function main() {  const db = await open({    filename: 'chat.db',    driver: sqlite3.Database  });  await db.exec(`    CREATE TABLE IF NOT EXISTS messages (      id INTEGER PRIMARY KEY AUTOINCREMENT,      client_offset TEXT UNIQUE,      content TEXT    );  `);  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    adapter: createAdapter()  });  app.get('/', (req, res) => {    res.sendFile(join(__dirname, 'index.html'));  });  io.on('connection', async (socket) => {    socket.on('chat message', async (msg, clientOffset, callback) => {      let result;      try {        result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);      } catch (e) {        if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {          callback();        } else {          // nothing to do, just let the client retry        }        return;      }      io.emit('chat message', msg, result.lastID);      callback();    });    if (!socket.recovered) {      try {        await db.each('SELECT id, content FROM messages WHERE id > ?',          [socket.handshake.auth.serverOffset || 0],          (_err, row) => {            socket.emit('chat message', row.content, row.id);          }        )      } catch (e) {        // something went wrong      }    }  });  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}main();
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';import { Server } from 'socket.io';import sqlite3 from 'sqlite3';import { open } from 'sqlite';import { availableParallelism } from 'node:os';import cluster from 'node:cluster';import { createAdapter, setupPrimary } from '@socket.io/cluster-adapter';if (cluster.isPrimary) {  const numCPUs = availableParallelism();  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }  setupPrimary();} else {  const db = await open({    filename: 'chat.db',    driver: sqlite3.Database  });  await db.exec(`    CREATE TABLE IF NOT EXISTS messages (      id INTEGER PRIMARY KEY AUTOINCREMENT,      client_offset TEXT UNIQUE,      content TEXT    );  `);  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    adapter: createAdapter()  });  const __dirname = dirname(fileURLToPath(import.meta.url));  app.get('/', (req, res) => {    res.sendFile(join(__dirname, 'index.html'));  });  io.on('connection', async (socket) => {    socket.on('chat message', async (msg, clientOffset, callback) => {      let result;      try {        result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);      } catch (e) {        if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {          callback();        } else {          // nothing to do, just let the client retry        }        return;      }      io.emit('chat message', msg, result.lastID);      callback();    });    if (!socket.recovered) {      try {        await db.each('SELECT id, content FROM messages WHERE id > ?',          [socket.handshake.auth.serverOffset || 0],          (_err, row) => {            socket.emit('chat message', row.content, row.id);          }        )      } catch (e) {        // something went wrong      }    }  });  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}
```

```js
<!DOCTYPE html><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1.0">    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>    <script src="/socket.io/socket.io.js"></script>    <script>      let counter = 0;        const socket = io({        ackTimeout: 10000,        retries: 3,        auth: {          serverOffset: 0        }      });        const form = document.getElementById('form');      const input = document.getElementById('input');      const messages = document.getElementById('messages');        form.addEventListener('submit', (e) => {        e.preventDefault();        if (input.value) {          const clientOffset = `${socket.id}-${counter++}`;          socket.emit('chat message', input.value, clientOffset);          input.value = '';        }      });        socket.on('chat message', (msg, serverOffset) => {        const item = document.createElement('li');        item.textContent = msg;        messages.appendChild(item);        window.scrollTo(0, document.body.scrollHeight);        socket.auth.serverOffset = serverOffset;      });    </script>  </body></html>
```

```js
<!DOCTYPE html><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1.0">    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>    <script src="/socket.io/socket.io.js"></script>    <script>      var counter = 0;        var socket = io({        ackTimeout: 10000,        retries: 3,        auth: {          serverOffset: 0        }      });        var form = document.getElementById('form');      var input = document.getElementById('input');      var messages = document.getElementById('messages');        form.addEventListener('submit', function(e) {        e.preventDefault();        if (input.value) {          const clientOffset = `${socket.id}-${counter++}`;          socket.emit('chat message', input.value, clientOffset);          input.value = '';        }      });        socket.on('chat message', function(msg, serverOffset) {        var item = document.createElement('li');        item.textContent = msg;        messages.appendChild(item);        window.scrollTo(0, document.body.scrollHeight);        socket.auth.serverOffset = serverOffset;      });    </script>  </body></html>
```

```js
git clone https://github.com/socketio/chat-example.git
```

# https://socket.io/docs/v4/tutorial/handling-disconnections

# Handling disconnections

Now, let's highlight two really important properties of Socket.IO:

Even over a stable network, it is not possible to maintain a connection alive forever.

Which means that your application needs to be able to synchronize the local state of the client with the global state on the server after a temporary disconnection.

The Socket.IO client will automatically try to reconnect after a small delay. However, any missed event during the disconnection period will effectively be lost for this client.

In the context of our chat application, this implies that a disconnected client might miss some messages:

We will see in the next steps how we can improve this.

- Handling disconnections
- a Socket.IO client is not always connected
- a Socket.IO server does not store any event
# https://socket.io/docs/v4/tutorial/introduction

# Getting started

## Introduction​

## How to use this tutorial​

### Tooling​

### Syntax settings​

Welcome to the Socket.IO tutorial!

In this tutorial we'll create a basic chat application. It requires almost no basic prior knowledge of Node.JS or Socket.IO, so it’s ideal for users of all knowledge levels.

Writing a chat application with popular web applications stacks like LAMP (PHP) has normally been very hard. It involves polling the server for changes, keeping track of timestamps, and it’s a lot slower than it should be.

Sockets have traditionally been the solution around which most real-time chat systems are architected, providing a bi-directional communication channel between a client and a server.

This means that the server can push messages to clients. Whenever you write a chat message, the idea is that the server will get it and push it to all other connected clients.

Any text editor (from a basic text editor to a complete IDE such as VS Code) should be sufficient to complete this tutorial.

Additionally, at the end of each step you will find a link to some online platforms (CodeSandbox and StackBlitz, namely), allowing you to run the code directly from your browser:

In the Node.js world, there are two ways to import modules:

Reference: https://nodejs.org/api/esm.html

Reference: https://nodejs.org/api/modules.html

Socket.IO supports both syntax.

We recommend using the ESM syntax in your project, though this might not always be feasible due to some packages not supporting this syntax.

For your convenience, throughout the tutorial, each code block allows you to select your preferred syntax:

Ready? Click "Next" to get started.

- Introduction
- the standard way: ECMAScript modules (or ESM)
- the legacy way: CommonJS
- CommonJS
- ES modules
```js
import { Server } from "socket.io";
```

```js
const { Server } = require("socket.io");
```

```js
const { Server } = require("socket.io");
```

```js
import { Server } from "socket.io";
```

```js
import { Server } from "socket.io";
```

```js
const { Server } = require("socket.io");
```

```js
const { Server } = require("socket.io");
```

```js
import { Server } from "socket.io";
```

# https://socket.io/docs/v4/tutorial/step-1

# Project initialization

The first goal is to set up a simple HTML webpage that serves out a form and a list of messages. We’re going to use the Node.JS web framework express to this end. Make sure Node.JS is installed.

First let’s create a package.json manifest file that describes our project. I recommend you place it in a dedicated empty directory (I’ll call mine socket-chat-example).

The "name" property must be unique, you cannot use a value like "socket.io" or "express", because npm will complain when installing the dependency.

Now, in order to easily populate the dependencies property with the things we need, we’ll use npm install:

Once it's installed we can create an index.js file that will set up our application.

This means that:

If you run node index.js you should see the following:

And if you point your browser to http://localhost:3000:

So far, so good!

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #1: Project initialization
- CommonJS
- ES modules
- CommonJS
- ES modules
- Express initializes app to be a function handler that you can supply to an HTTP server (as seen in line 5).
- We define a route handler / that gets called when we hit our website home.
- We make the http server listen on port 3000.
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
```js
{  "name": "socket-chat-example",  "version": "0.0.1",  "description": "my first socket.io app",  "type": "commonjs",  "dependencies": {}}
```

```js
{  "name": "socket-chat-example",  "version": "0.0.1",  "description": "my first socket.io app",  "type": "module",  "dependencies": {}}
```

```js
npm install express@4
```

```js
const express = require('express');const { createServer } = require('node:http');const app = express();const server = createServer(app);app.get('/', (req, res) => {  res.send('<h1>Hello world</h1>');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
import express from 'express';import { createServer } from 'node:http';const app = express();const server = createServer(app);app.get('/', (req, res) => {  res.send('<h1>Hello world</h1>');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
express
```

```js
package.json
```

```js
socket-chat-example
```

```js
{  "name": "socket-chat-example",  "version": "0.0.1",  "description": "my first socket.io app",  "type": "commonjs",  "dependencies": {}}
```

```js
{  "name": "socket-chat-example",  "version": "0.0.1",  "description": "my first socket.io app",  "type": "module",  "dependencies": {}}
```

```js
dependencies
```

```js
npm install
```

```js
npm install express@4
```

```js
index.js
```

```js
const express = require('express');const { createServer } = require('node:http');const app = express();const server = createServer(app);app.get('/', (req, res) => {  res.send('<h1>Hello world</h1>');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
import express from 'express';import { createServer } from 'node:http';const app = express();const server = createServer(app);app.get('/', (req, res) => {  res.send('<h1>Hello world</h1>');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
app
```

```js
node index.js
```

```js
http://localhost:3000
```

# https://socket.io/docs/v4/tutorial/step-2

# Serving HTML

So far in index.js we’re calling res.send and passing it a string of HTML. Our code would look very confusing if we just placed our entire application’s HTML there, so instead we're going to create a index.html file and serve that instead.

Let’s refactor our route handler to use sendFile instead.

Put the following in your index.html file:

If you restart the process (by hitting Control+C and running node index.js again) and refresh the page it should look like this:

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #2: Serving HTML
- CommonJS
- ES modules
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const app = express();const server = createServer(app);app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';const app = express();const server = createServer(app);const __dirname = dirname(fileURLToPath(import.meta.url));app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
<!DOCTYPE html><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1.0">    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>  </body></html>
```

```js
index.js
```

```js
res.send
```

```js
index.html
```

```js
sendFile
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const app = express();const server = createServer(app);app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';const app = express();const server = createServer(app);const __dirname = dirname(fileURLToPath(import.meta.url));app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
index.html
```

```js
<!DOCTYPE html><html>  <head>    <meta name="viewport" content="width=device-width,initial-scale=1.0">    <title>Socket.IO chat</title>    <style>      body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }      #form { background: rgba(0, 0, 0, 0.15); padding: 0.25rem; position: fixed; bottom: 0; left: 0; right: 0; display: flex; height: 3rem; box-sizing: border-box; backdrop-filter: blur(10px); }      #input { border: none; padding: 0 1rem; flex-grow: 1; border-radius: 2rem; margin: 0.25rem; }      #input:focus { outline: none; }      #form > button { background: #333; border: none; padding: 0 1rem; margin: 0.25rem; border-radius: 3px; outline: none; color: #fff; }      #messages { list-style-type: none; margin: 0; padding: 0; }      #messages > li { padding: 0.5rem 1rem; }      #messages > li:nth-child(odd) { background: #efefef; }    </style>  </head>  <body>    <ul id="messages"></ul>    <form id="form" action="">      <input id="input" autocomplete="off" /><button>Send</button>    </form>  </body></html>
```

```js
node index.js
```

# https://socket.io/docs/v4/tutorial/step-3

# Integrating Socket.IO

Socket.IO is composed of two parts:

During development, socket.io serves the client automatically for us, as we’ll see, so for now we only have to install one module:

That will install the module and add the dependency to package.json. Now let’s edit index.js to add it:

Notice that I initialize a new instance of socket.io by passing the server (the HTTP server) object. Then I listen on the connection event for incoming sockets and log it to the console.

Now in index.html add the following snippet before the </body> (end body tag):

That’s all it takes to load the socket.io-client, which exposes an io global (and the endpoint GET /socket.io/socket.io.js), and then connect.

If you would like to use the local version of the client-side JS file, you can find it at node_modules/socket.io/client-dist/socket.io.js.

You can also use a CDN instead of the local files (e.g. <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>).

Notice that I’m not specifying any URL when I call io(), since it defaults to trying to connect to the host that serves the page.

If you're behind a reverse proxy such as apache or nginx please take a look at the documentation for it.

If you're hosting your app in a folder that is not the root of your website (e.g., https://example.com/chatapp) then you also need to specify the path in both the server and the client.

If you now restart the process (by hitting Control+C and running node index.js again) and then refresh the webpage you should see the console print “a user connected”.

Try opening several tabs, and you’ll see several messages.

Each socket also fires a special disconnect event:

Then if you refresh a tab several times you can see it in action.

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #3: Integrating Socket.IO
- A server that integrates with (or mounts on) the Node.JS HTTP Server (the socket.io package)
- A client library that loads on the browser side (the socket.io-client package)
- CommonJS
- ES modules
- ES6
- ES5
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
```js
npm install socket.io
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const app = express();const server = createServer(app);const io = new Server(server);app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});io.on('connection', (socket) => {  console.log('a user connected');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';import { Server } from 'socket.io';const app = express();const server = createServer(app);const io = new Server(server);const __dirname = dirname(fileURLToPath(import.meta.url));app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});io.on('connection', (socket) => {  console.log('a user connected');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();</script>
```

```js
io.on('connection', (socket) => {  console.log('a user connected');  socket.on('disconnect', () => {    console.log('user disconnected');  });});
```

```js
socket.io
```

```js
socket.io-client
```

```js
socket.io
```

```js
npm install socket.io
```

```js
package.json
```

```js
index.js
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const app = express();const server = createServer(app);const io = new Server(server);app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});io.on('connection', (socket) => {  console.log('a user connected');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';import { Server } from 'socket.io';const app = express();const server = createServer(app);const io = new Server(server);const __dirname = dirname(fileURLToPath(import.meta.url));app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});io.on('connection', (socket) => {  console.log('a user connected');});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
socket.io
```

```js
server
```

```js
connection
```

```js
</body>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();</script>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();</script>
```

```js
socket.io-client
```

```js
GET /socket.io/socket.io.js
```

```js
node_modules/socket.io/client-dist/socket.io.js
```

```js
<script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
```

```js
io()
```

```js
https://example.com/chatapp
```

```js
node index.js
```

```js
disconnect
```

```js
io.on('connection', (socket) => {  console.log('a user connected');  socket.on('disconnect', () => {    console.log('user disconnected');  });});
```

# https://socket.io/docs/v4/tutorial/step-4

# Emitting events

The main idea behind Socket.IO is that you can send and receive any events you want, with any data you want. Any objects that can be encoded as JSON will do, and binary data is supported too.

Let’s make it so that when the user types in a message, the server gets it as a chat message event. The script section in index.html should now look as follows:

And in index.js we print out the chat message event:

The result should be like the following video:

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #4: Emitting events
- ES6
- ES5
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();  const form = document.getElementById('form');  const input = document.getElementById('input');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });</script>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var form = document.getElementById('form');  var input = document.getElementById('input');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });</script>
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    console.log('message: ' + msg);  });});
```

```js
chat message
```

```js
script
```

```js
index.html
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();  const form = document.getElementById('form');  const input = document.getElementById('input');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });</script>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var form = document.getElementById('form');  var input = document.getElementById('input');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });</script>
```

```js
index.js
```

```js
chat message
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    console.log('message: ' + msg);  });});
```

# https://socket.io/docs/v4/tutorial/step-5

# Broadcasting

The next goal is for us to emit the event from the server to the rest of the users.

In order to send an event to everyone, Socket.IO gives us the io.emit() method.

If you want to send a message to everyone except for a certain emitting socket, we have the broadcast flag for emitting from that socket:

In this case, for the sake of simplicity we’ll send the message to everyone, including the sender.

And on the client side when we capture a chat message event we’ll include it in the page.

Let's see it in action:

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #5: Broadcasting
- ES6
- ES5
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
```js
// this will emit the event to all connected socketsio.emit('hello', 'world');
```

```js
io.on('connection', (socket) => {  socket.broadcast.emit('hi');});
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    io.emit('chat message', msg);  });});
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();  const form = document.getElementById('form');  const input = document.getElementById('input');  const messages = document.getElementById('messages');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', (msg) => {    const item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);  });</script>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var form = document.getElementById('form');  var input = document.getElementById('input');  var messages = document.getElementById('messages');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', function(msg) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);  });</script>
```

```js
io.emit()
```

```js
// this will emit the event to all connected socketsio.emit('hello', 'world');
```

```js
broadcast
```

```js
io.on('connection', (socket) => {  socket.broadcast.emit('hi');});
```

```js
io.on('connection', (socket) => {  socket.on('chat message', (msg) => {    io.emit('chat message', msg);  });});
```

```js
chat message
```

```js
<script src="/socket.io/socket.io.js"></script><script>  const socket = io();  const form = document.getElementById('form');  const input = document.getElementById('input');  const messages = document.getElementById('messages');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', (msg) => {    const item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);  });</script>
```

```js
<script src="/socket.io/socket.io.js"></script><script>  var socket = io();  var form = document.getElementById('form');  var input = document.getElementById('input');  var messages = document.getElementById('messages');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', function(msg) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);  });</script>
```

# https://socket.io/docs/v4/tutorial/step-6

# Connection state recovery

First, let's handle disconnections by pretending that there was no disconnection: this feature is called "Connection state recovery".

This feature will temporarily store all the events that are sent by the server and will try to restore the state of a client when it reconnects:

It must be enabled on the server side:

Let's see it in action:

As you can see in the video above, the "realtime" message is eventually delivered when the connection is reestablished.

The "Disconnect" button was added for demonstration purposes.

Great! Now, you may ask:

But this is an awesome feature, why isn't this enabled by default?

There are several reasons for this:

That being said, it is indeed a great feature since you don't have to synchronize the state of the client after a temporary disconnection (for example, when the user switches from WiFi to 4G).

We will explore a more general solution in the next step.

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #6: Connection state recovery
- restore its rooms
- send any missed events
- ES6
- ES5
- it doesn't always work, for example if the server abruptly crashes or gets restarted, then the client state might not be saved
- it is not always possible to enable this feature when scaling up
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
```js
const io = new Server(server, {  connectionStateRecovery: {}});
```

```js
<form id="form" action="">  <input id="input" autocomplete="off" /><button>Send</button>  <button id="toggle-btn">Disconnect</button></form><script>  const toggleButton = document.getElementById('toggle-btn');  toggleButton.addEventListener('click', (e) => {    e.preventDefault();    if (socket.connected) {      toggleButton.innerText = 'Connect';      socket.disconnect();    } else {      toggleButton.innerText = 'Disconnect';      socket.connect();    }  });</script>
```

```js
<form id="form" action="">  <input id="input" autocomplete="off" /><button>Send</button>  <button id="toggle-btn">Disconnect</button></form><script>  var toggleButton = document.getElementById('toggle-btn');  toggleButton.addEventListener('click', function(e) {    e.preventDefault();    if (socket.connected) {      toggleButton.innerText = 'Connect';      socket.disconnect();    } else {      toggleButton.innerText = 'Disconnect';      socket.connect();    }  });</script>
```

```js
const io = new Server(server, {  connectionStateRecovery: {}});
```

```js
<form id="form" action="">  <input id="input" autocomplete="off" /><button>Send</button>  <button id="toggle-btn">Disconnect</button></form><script>  const toggleButton = document.getElementById('toggle-btn');  toggleButton.addEventListener('click', (e) => {    e.preventDefault();    if (socket.connected) {      toggleButton.innerText = 'Connect';      socket.disconnect();    } else {      toggleButton.innerText = 'Disconnect';      socket.connect();    }  });</script>
```

```js
<form id="form" action="">  <input id="input" autocomplete="off" /><button>Send</button>  <button id="toggle-btn">Disconnect</button></form><script>  var toggleButton = document.getElementById('toggle-btn');  toggleButton.addEventListener('click', function(e) {    e.preventDefault();    if (socket.connected) {      toggleButton.innerText = 'Connect';      socket.disconnect();    } else {      toggleButton.innerText = 'Disconnect';      socket.connect();    }  });</script>
```

# https://socket.io/docs/v4/tutorial/step-7

# Server delivery

There are two common ways to synchronize the state of the client upon reconnection:

Both are totally valid solutions and choosing one will depend on your use case. In this tutorial, we will go with the latter.

First, let's persist the messages of our chat application. Today there are plenty of great options, we will use SQLite here.

If you are not familiar with SQLite, there are plenty of tutorials available online, like this one.

Let's install the necessary packages:

We will simply store each message in a SQL table:

The client will then keep track of the offset:

And finally the server will send the missing messages upon (re)connection:

Let's see it in action:

As you can see in the video above, it works both after a temporary disconnection and a full page refresh.

The difference with the "Connection state recovery" feature is that a successful recovery might not need to hit your main database (it might fetch the messages from a Redis stream for example).

OK, now let's talk about the client delivery.

- Step #7: Server delivery
- either the server sends the whole state
- or the client keeps track of the last event it has processed and the server sends the missing pieces
- NPM
- Yarn
- pnpm
- Bun
- CommonJS
- ES modules
- ES6
- ES5
```js
npm install sqlite sqlite3
```

```js
yarn add sqlite sqlite3
```

```js
pnpm add sqlite sqlite3
```

```js
bun add sqlite sqlite3
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const sqlite3 = require('sqlite3');const { open } = require('sqlite');async function main() {  // open the database file  const db = await open({    filename: 'chat.db',    driver: sqlite3.Database  });  // create our 'messages' table (you can ignore the 'client_offset' column for now)  await db.exec(`    CREATE TABLE IF NOT EXISTS messages (        id INTEGER PRIMARY KEY AUTOINCREMENT,        client_offset TEXT UNIQUE,        content TEXT    );  `);  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {}  });  app.get('/', (req, res) => {    res.sendFile(join(__dirname, 'index.html'));  });  io.on('connection', (socket) => {    socket.on('chat message', async (msg) => {      let result;      try {        // store the message in the database        result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);      } catch (e) {        // TODO handle the failure        return;      }      // include the offset with the message      io.emit('chat message', msg, result.lastID);    });  });  server.listen(3000, () => {    console.log('server running at http://localhost:3000');  });}main();
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';import { Server } from 'socket.io';import sqlite3 from 'sqlite3';import { open } from 'sqlite';// open the database fileconst db = await open({  filename: 'chat.db',  driver: sqlite3.Database});// create our 'messages' table (you can ignore the 'client_offset' column for now)await db.exec(`  CREATE TABLE IF NOT EXISTS messages (      id INTEGER PRIMARY KEY AUTOINCREMENT,      client_offset TEXT UNIQUE,      content TEXT  );`);const app = express();const server = createServer(app);const io = new Server(server, {  connectionStateRecovery: {}});const __dirname = dirname(fileURLToPath(import.meta.url));app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});io.on('connection', (socket) => {  socket.on('chat message', async (msg) => {    let result;    try {      // store the message in the database      result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);    } catch (e) {      // TODO handle the failure      return;    }    // include the offset with the message    io.emit('chat message', msg, result.lastID);  });});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
<script>  const socket = io({    auth: {      serverOffset: 0    }  });  const form = document.getElementById('form');  const input = document.getElementById('input');  const messages = document.getElementById('messages');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', (msg, serverOffset) => {    const item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
<script>  var socket = io({    auth: {      serverOffset: 0    }  });  var form = document.getElementById('form');  var input = document.getElementById('input');  var messages = document.getElementById('messages');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', function(msg, serverOffset) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
// [...]io.on('connection', async (socket) => {  socket.on('chat message', async (msg) => {    let result;    try {      result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);    } catch (e) {      // TODO handle the failure      return;    }    io.emit('chat message', msg, result.lastID);  });  if (!socket.recovered) {    // if the connection state recovery was not successful    try {      await db.each('SELECT id, content FROM messages WHERE id > ?',        [socket.handshake.auth.serverOffset || 0],        (_err, row) => {          socket.emit('chat message', row.content, row.id);        }      )    } catch (e) {      // something went wrong    }  }});// [...]
```

```js
npm install sqlite sqlite3
```

```js
yarn add sqlite sqlite3
```

```js
pnpm add sqlite sqlite3
```

```js
bun add sqlite sqlite3
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const sqlite3 = require('sqlite3');const { open } = require('sqlite');async function main() {  // open the database file  const db = await open({    filename: 'chat.db',    driver: sqlite3.Database  });  // create our 'messages' table (you can ignore the 'client_offset' column for now)  await db.exec(`    CREATE TABLE IF NOT EXISTS messages (        id INTEGER PRIMARY KEY AUTOINCREMENT,        client_offset TEXT UNIQUE,        content TEXT    );  `);  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {}  });  app.get('/', (req, res) => {    res.sendFile(join(__dirname, 'index.html'));  });  io.on('connection', (socket) => {    socket.on('chat message', async (msg) => {      let result;      try {        // store the message in the database        result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);      } catch (e) {        // TODO handle the failure        return;      }      // include the offset with the message      io.emit('chat message', msg, result.lastID);    });  });  server.listen(3000, () => {    console.log('server running at http://localhost:3000');  });}main();
```

```js
import express from 'express';import { createServer } from 'node:http';import { fileURLToPath } from 'node:url';import { dirname, join } from 'node:path';import { Server } from 'socket.io';import sqlite3 from 'sqlite3';import { open } from 'sqlite';// open the database fileconst db = await open({  filename: 'chat.db',  driver: sqlite3.Database});// create our 'messages' table (you can ignore the 'client_offset' column for now)await db.exec(`  CREATE TABLE IF NOT EXISTS messages (      id INTEGER PRIMARY KEY AUTOINCREMENT,      client_offset TEXT UNIQUE,      content TEXT  );`);const app = express();const server = createServer(app);const io = new Server(server, {  connectionStateRecovery: {}});const __dirname = dirname(fileURLToPath(import.meta.url));app.get('/', (req, res) => {  res.sendFile(join(__dirname, 'index.html'));});io.on('connection', (socket) => {  socket.on('chat message', async (msg) => {    let result;    try {      // store the message in the database      result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);    } catch (e) {      // TODO handle the failure      return;    }    // include the offset with the message    io.emit('chat message', msg, result.lastID);  });});server.listen(3000, () => {  console.log('server running at http://localhost:3000');});
```

```js
<script>  const socket = io({    auth: {      serverOffset: 0    }  });  const form = document.getElementById('form');  const input = document.getElementById('input');  const messages = document.getElementById('messages');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', (msg, serverOffset) => {    const item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
<script>  var socket = io({    auth: {      serverOffset: 0    }  });  var form = document.getElementById('form');  var input = document.getElementById('input');  var messages = document.getElementById('messages');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      socket.emit('chat message', input.value);      input.value = '';    }  });  socket.on('chat message', function(msg, serverOffset) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
// [...]io.on('connection', async (socket) => {  socket.on('chat message', async (msg) => {    let result;    try {      result = await db.run('INSERT INTO messages (content) VALUES (?)', msg);    } catch (e) {      // TODO handle the failure      return;    }    io.emit('chat message', msg, result.lastID);  });  if (!socket.recovered) {    // if the connection state recovery was not successful    try {      await db.each('SELECT id, content FROM messages WHERE id > ?',        [socket.handshake.auth.serverOffset || 0],        (_err, row) => {          socket.emit('chat message', row.content, row.id);        }      )    } catch (e) {      // something went wrong    }  }});// [...]
```

# https://socket.io/docs/v4/tutorial/step-8

# Client delivery

## Buffered events​

## At least once​

## Exactly once​

Let's see how we can make sure that the server always receives the messages sent by the clients.

By default, Socket.IO provides an "at most once" guarantee of delivery (also known as "fire and forget"), which means that there will be no retry in case the message does not reach the server.

When a client gets disconnected, any call to socket.emit() is buffered until reconnection:

In the video above, the "realtime" message is buffered until the connection is reestablished.

This behavior might be totally sufficient for your application. However, there are a few cases where a message could be lost:

We can implement an "at least once" guarantee:

In both cases, the client will retry to send the message until it gets an acknowledgement from the server:

With the retries option, the order of the messages is guaranteed, as the messages are queued and sent one by one. This is not the case with the first option.

The problem with retries is that the server might now receive the same message multiple times, so it needs a way to uniquely identify each message, and only store it once in the database.

Let's see how we can implement an "exactly once" guarantee in our chat application.

We will start by assigning a unique identifier to each message on the client side:

The socket.id attribute is a random 20-characters identifier which is assigned to each connection.

We could also have used getRandomValues() to generate a unique offset.

And then we store this offset alongside the message on the server side:

This way, the UNIQUE constraint on the client_offset column prevents the duplication of the message.

Do not forget to acknowledge the event, or else the client will keep retrying (up to retries times).

Again, the default guarantee ("at most once") might be sufficient for your application, but now you know how it can be made more reliable.

In the next step, we will see how we can scale our application horizontally.

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #8: Client delivery
- the connection is severed while the event is being sent
- the server crashes or get restarted while processing the event
- the database is temporarily not available
- manually with an acknowledgement:
- or with the retries option:
- ES6
- ES5
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
```js
function emit(socket, event, arg) {  socket.timeout(5000).emit(event, arg, (err) => {    if (err) {      // no ack from the server, let's retry      emit(socket, event, arg);    }  });}emit(socket, 'hello', 'world');
```

```js
const socket = io({  ackTimeout: 10000,  retries: 3});socket.emit('hello', 'world');
```

```js
io.on('connection', (socket) => {  socket.on('hello', (value, callback) => {    // once the event is successfully handled    callback();  });})
```

```js
<script>  let counter = 0;  const socket = io({    auth: {      serverOffset: 0    },    // enable retries    ackTimeout: 10000,    retries: 3,  });  const form = document.getElementById('form');  const input = document.getElementById('input');  const messages = document.getElementById('messages');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      // compute a unique offset      const clientOffset = `${socket.id}-${counter++}`;      socket.emit('chat message', input.value, clientOffset);      input.value = '';    }  });  socket.on('chat message', (msg, serverOffset) => {    const item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
<script>  var counter = 0;  var socket = io({    auth: {      serverOffset: 0    },    // enable retries    ackTimeout: 10000,    retries: 3,  });  var form = document.getElementById('form');  var input = document.getElementById('input');  var messages = document.getElementById('messages');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      // compute a unique offset      var clientOffset = `${socket.id}-${counter++}`;      socket.emit('chat message', input.value, clientOffset);      input.value = '';    }  });  socket.on('chat message', function(msg, serverOffset) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
// [...]io.on('connection', async (socket) => {  socket.on('chat message', async (msg, clientOffset, callback) => {    let result;    try {      result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);    } catch (e) {      if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {        // the message was already inserted, so we notify the client        callback();      } else {        // nothing to do, just let the client retry      }      return;    }    io.emit('chat message', msg, result.lastID);    // acknowledge the event    callback();  });  if (!socket.recovered) {    try {      await db.each('SELECT id, content FROM messages WHERE id > ?',        [socket.handshake.auth.serverOffset || 0],        (_err, row) => {          socket.emit('chat message', row.content, row.id);        }      )    } catch (e) {      // something went wrong    }  }});// [...]
```

```js
socket.on('chat message', async (msg, clientOffset, callback) => {  // ... and finally  callback();});
```

```js
socket.emit()
```

```js
function emit(socket, event, arg) {  socket.timeout(5000).emit(event, arg, (err) => {    if (err) {      // no ack from the server, let's retry      emit(socket, event, arg);    }  });}emit(socket, 'hello', 'world');
```

```js
retries
```

```js
const socket = io({  ackTimeout: 10000,  retries: 3});socket.emit('hello', 'world');
```

```js
io.on('connection', (socket) => {  socket.on('hello', (value, callback) => {    // once the event is successfully handled    callback();  });})
```

```js
retries
```

```js
<script>  let counter = 0;  const socket = io({    auth: {      serverOffset: 0    },    // enable retries    ackTimeout: 10000,    retries: 3,  });  const form = document.getElementById('form');  const input = document.getElementById('input');  const messages = document.getElementById('messages');  form.addEventListener('submit', (e) => {    e.preventDefault();    if (input.value) {      // compute a unique offset      const clientOffset = `${socket.id}-${counter++}`;      socket.emit('chat message', input.value, clientOffset);      input.value = '';    }  });  socket.on('chat message', (msg, serverOffset) => {    const item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
<script>  var counter = 0;  var socket = io({    auth: {      serverOffset: 0    },    // enable retries    ackTimeout: 10000,    retries: 3,  });  var form = document.getElementById('form');  var input = document.getElementById('input');  var messages = document.getElementById('messages');  form.addEventListener('submit', function(e) {    e.preventDefault();    if (input.value) {      // compute a unique offset      var clientOffset = `${socket.id}-${counter++}`;      socket.emit('chat message', input.value, clientOffset);      input.value = '';    }  });  socket.on('chat message', function(msg, serverOffset) {    var item = document.createElement('li');    item.textContent = msg;    messages.appendChild(item);    window.scrollTo(0, document.body.scrollHeight);    socket.auth.serverOffset = serverOffset;  });</script>
```

```js
socket.id
```

```js
getRandomValues()
```

```js
// [...]io.on('connection', async (socket) => {  socket.on('chat message', async (msg, clientOffset, callback) => {    let result;    try {      result = await db.run('INSERT INTO messages (content, client_offset) VALUES (?, ?)', msg, clientOffset);    } catch (e) {      if (e.errno === 19 /* SQLITE_CONSTRAINT */ ) {        // the message was already inserted, so we notify the client        callback();      } else {        // nothing to do, just let the client retry      }      return;    }    io.emit('chat message', msg, result.lastID);    // acknowledge the event    callback();  });  if (!socket.recovered) {    try {      await db.each('SELECT id, content FROM messages WHERE id > ?',        [socket.handshake.auth.serverOffset || 0],        (_err, row) => {          socket.emit('chat message', row.content, row.id);        }      )    } catch (e) {      // something went wrong    }  }});// [...]
```

```js
client_offset
```

```js
retries
```

```js
socket.on('chat message', async (msg, clientOffset, callback) => {  // ... and finally  callback();});
```

# https://socket.io/docs/v4/tutorial/step-9

# Scaling horizontally

Now that our application is resilient to temporary network interruptions, let's see how we can horizontally scale it in order to be able to support thousands of concurrent clients.

First step: let's use all the available cores of the host. By default, Node.js runs your Javascript code in a single thread, which means that even with a 32-core CPU, only one core will be used. Fortunately, the Node.js cluster module provides a convenient way to create one worker thread per core.

We will also need a way to forward events between the Socket.IO servers. We call this component an "Adapter".

So let's install the cluster adapter:

Now we plug it in:

That's it! This will spawn one worker thread per CPU available on your machine. Let's see it in action:

As you can see in the address bar, each browser tab is connected to a different Socket.IO server, and the adapter is simply forwarding the chat message events between them.

There are currently 5 official adapter implementations:

So you can choose the one that best suits your needs. However, please note that some implementations do not support the Connection state recovery feature, you can find the compatibility matrix here.

In most cases, you would also need to ensure that all the HTTP requests of a Socket.IO session reach the same server (also known as "sticky session"). This is not needed here though, as each Socket.IO server has its own port.

More information here.

And that finally completes our chat application! In this tutorial, we have seen how to:

You should now have a better overview of the features provided by Socket.IO. Now it's your time to build your own realtime application!

You can run this example directly in your browser on:

You can run this example directly in your browser on:

- Step #9: Scaling horizontally
- Horizontal scaling (also known as "scaling out") means adding new servers to your infrastructure to cope with new demands
- Vertical scaling (also known as "scaling up") means adding more resources (processing power, memory, storage, ...) to your existing infrastructure
- NPM
- Yarn
- pnpm
- Bun
- CommonJS
- ES modules
- the Redis adapter
- the Redis Streams adapter
- the MongoDB adapter
- the Postgres adapter
- the Cluster adapter
- send an event between the client and the server
- broadcast an event to all or a subset of connected clients
- handle temporary disconnections
- scale out
- CommonJS
- ES modules
- CodeSandbox
- StackBlitz
- CodeSandbox
- StackBlitz
- Repl.it
```js
npm install @socket.io/cluster-adapter
```

```js
yarn add @socket.io/cluster-adapter
```

```js
pnpm add @socket.io/cluster-adapter
```

```js
bun add @socket.io/cluster-adapter
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const sqlite3 = require('sqlite3');const { open } = require('sqlite');const { availableParallelism } = require('node:os');const cluster = require('node:cluster');const { createAdapter, setupPrimary } = require('@socket.io/cluster-adapter');if (cluster.isPrimary) {  const numCPUs = availableParallelism();  // create one worker per available core  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }    // set up the adapter on the primary thread  return setupPrimary();}async function main() {  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    // set up the adapter on each worker thread    adapter: createAdapter()  });  // [...]  // each worker will listen on a distinct port  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}main();
```

```js
import express from 'express';import { createServer } from 'node:http';import { Server } from 'socket.io';import sqlite3 from 'sqlite3';import { open } from 'sqlite';import { availableParallelism } from 'node:os';import cluster from 'node:cluster';import { createAdapter, setupPrimary } from '@socket.io/cluster-adapter';if (cluster.isPrimary) {  const numCPUs = availableParallelism();  // create one worker per available core  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }    // set up the adapter on the primary thread  setupPrimary();} else {  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    // set up the adapter on each worker thread    adapter: createAdapter()  });  // [...]  // each worker will listen on a distinct port  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}
```

```js
cluster
```

```js
npm install @socket.io/cluster-adapter
```

```js
yarn add @socket.io/cluster-adapter
```

```js
pnpm add @socket.io/cluster-adapter
```

```js
bun add @socket.io/cluster-adapter
```

```js
const express = require('express');const { createServer } = require('node:http');const { join } = require('node:path');const { Server } = require('socket.io');const sqlite3 = require('sqlite3');const { open } = require('sqlite');const { availableParallelism } = require('node:os');const cluster = require('node:cluster');const { createAdapter, setupPrimary } = require('@socket.io/cluster-adapter');if (cluster.isPrimary) {  const numCPUs = availableParallelism();  // create one worker per available core  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }    // set up the adapter on the primary thread  return setupPrimary();}async function main() {  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    // set up the adapter on each worker thread    adapter: createAdapter()  });  // [...]  // each worker will listen on a distinct port  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}main();
```

```js
import express from 'express';import { createServer } from 'node:http';import { Server } from 'socket.io';import sqlite3 from 'sqlite3';import { open } from 'sqlite';import { availableParallelism } from 'node:os';import cluster from 'node:cluster';import { createAdapter, setupPrimary } from '@socket.io/cluster-adapter';if (cluster.isPrimary) {  const numCPUs = availableParallelism();  // create one worker per available core  for (let i = 0; i < numCPUs; i++) {    cluster.fork({      PORT: 3000 + i    });  }    // set up the adapter on the primary thread  setupPrimary();} else {  const app = express();  const server = createServer(app);  const io = new Server(server, {    connectionStateRecovery: {},    // set up the adapter on each worker thread    adapter: createAdapter()  });  // [...]  // each worker will listen on a distinct port  const port = process.env.PORT;  server.listen(port, () => {    console.log(`server running at http://localhost:${port}`);  });}
```

```js
chat message
```

# https://socket.io/docs/v4/typescript

# TypeScript

## Types for the server​

## Types for the client​

## Custom types for each namespace​

Starting with v3, Socket.IO now has first class support for TypeScript.

First, declare some types:

And use them when creating your server:

Then, profit from the help of your IDE!

The events declared in the ServerToClientEvents interface are used when sending and broadcasting events:

The ones declared in the ClientToServerEvents interface are used when receiving events:

The ones declared in the InterServerEvents interface are used for inter-server communication (added in socket.io@4.1.0):

And finally, the SocketData type is used to type the socket.data attribute (added in socket.io@4.4.0):

These type hints do not replace proper validation/sanitization of the input. As usual, never trust user input.

On the client side, you can reuse the same ServerToClientEvents and ClientToServerEvents interfaces:

Similarly, the events declared in the ClientToServerEvents interface are used when sending events:

And the ones declared in ServerToClientEvents are used when receiving events:

Since each Namespace can have its own set of events, you can also provide some types for
each one of them:

And on the client side:

- Documentation
- TypeScript
```js
interface ServerToClientEvents {  noArg: () => void;  basicEmit: (a: number, b: string, c: Buffer) => void;  withAck: (d: string, callback: (e: number) => void) => void;}interface ClientToServerEvents {  hello: () => void;}interface InterServerEvents {  ping: () => void;}interface SocketData {  name: string;  age: number;}
```

```js
const io = new Server<  ClientToServerEvents,  ServerToClientEvents,  InterServerEvents,  SocketData>();
```

```js
io.on("connection", (socket) => {  socket.emit("noArg");  socket.emit("basicEmit", 1, "2", Buffer.from([3]));  socket.emit("withAck", "4", (e) => {    // e is inferred as number  });  // works when broadcast to all  io.emit("noArg");  // works when broadcasting to a room  io.to("room1").emit("basicEmit", 1, "2", Buffer.from([3]));});
```

```js
io.on("connection", (socket) => {  socket.on("hello", () => {    // ...  });});
```

```js
io.serverSideEmit("ping");io.on("ping", () => {  // ...});
```

```js
io.on("connection", (socket) => {  socket.data.name = "john";  socket.data.age = 42;});
```

```js
import { io, Socket } from "socket.io-client";// please note that the types are reversedconst socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();
```

```js
socket.emit("hello");
```

```js
socket.on("noArg", () => {  // ...});socket.on("basicEmit", (a, b, c) => {  // a is inferred as number, b as string and c as buffer});socket.on("withAck", (d, callback) => {  // d is inferred as string and callback as a function that takes a number as argument});
```

```js
import { Server } from "socket.io";// types for the main namespaceconst io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>();// types for the namespace named "/my-namespace"interface NamespaceSpecificClientToServerEvents {  foo: (arg: string) => void}interface NamespaceSpecificServerToClientEvents {  bar: (arg: string) => void;}interface NamespaceSpecificInterServerEvents {  // ...}interface NamespaceSpecificSocketData {  // ...}const myNamespace: Namespace<  NamespaceSpecificClientToServerEvents,  NamespaceSpecificServerToClientEvents,  NamespaceSpecificInterServerEvents,  NamespaceSpecificSocketData  > = io.of("/my-namespace");myNamespace.on("connection", (socket) => {  socket.on("foo", () => {    // ...  });  socket.emit("bar", "123");});
```

```js
import { io, Socket } from "socket.io-client";const socket: Socket<  NamespaceSpecificServerToClientEvents,  NamespaceSpecificClientToServerEvents  > = io("/my-namespace");socket.on("bar", (arg) => {  console.log(arg); // "123"});
```

```js
interface ServerToClientEvents {  noArg: () => void;  basicEmit: (a: number, b: string, c: Buffer) => void;  withAck: (d: string, callback: (e: number) => void) => void;}interface ClientToServerEvents {  hello: () => void;}interface InterServerEvents {  ping: () => void;}interface SocketData {  name: string;  age: number;}
```

```js
const io = new Server<  ClientToServerEvents,  ServerToClientEvents,  InterServerEvents,  SocketData>();
```

```js
ServerToClientEvents
```

```js
io.on("connection", (socket) => {  socket.emit("noArg");  socket.emit("basicEmit", 1, "2", Buffer.from([3]));  socket.emit("withAck", "4", (e) => {    // e is inferred as number  });  // works when broadcast to all  io.emit("noArg");  // works when broadcasting to a room  io.to("room1").emit("basicEmit", 1, "2", Buffer.from([3]));});
```

```js
ClientToServerEvents
```

```js
io.on("connection", (socket) => {  socket.on("hello", () => {    // ...  });});
```

```js
InterServerEvents
```

```js
socket.io@4.1.0
```

```js
io.serverSideEmit("ping");io.on("ping", () => {  // ...});
```

```js
SocketData
```

```js
socket.data
```

```js
socket.io@4.4.0
```

```js
io.on("connection", (socket) => {  socket.data.name = "john";  socket.data.age = 42;});
```

```js
ServerToClientEvents
```

```js
ClientToServerEvents
```

```js
import { io, Socket } from "socket.io-client";// please note that the types are reversedconst socket: Socket<ServerToClientEvents, ClientToServerEvents> = io();
```

```js
ClientToServerEvents
```

```js
socket.emit("hello");
```

```js
ServerToClientEvents
```

```js
socket.on("noArg", () => {  // ...});socket.on("basicEmit", (a, b, c) => {  // a is inferred as number, b as string and c as buffer});socket.on("withAck", (d, callback) => {  // d is inferred as string and callback as a function that takes a number as argument});
```

```js
import { Server } from "socket.io";// types for the main namespaceconst io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>();// types for the namespace named "/my-namespace"interface NamespaceSpecificClientToServerEvents {  foo: (arg: string) => void}interface NamespaceSpecificServerToClientEvents {  bar: (arg: string) => void;}interface NamespaceSpecificInterServerEvents {  // ...}interface NamespaceSpecificSocketData {  // ...}const myNamespace: Namespace<  NamespaceSpecificClientToServerEvents,  NamespaceSpecificServerToClientEvents,  NamespaceSpecificInterServerEvents,  NamespaceSpecificSocketData  > = io.of("/my-namespace");myNamespace.on("connection", (socket) => {  socket.on("foo", () => {    // ...  });  socket.emit("bar", "123");});
```

```js
import { io, Socket } from "socket.io-client";const socket: Socket<  NamespaceSpecificServerToClientEvents,  NamespaceSpecificClientToServerEvents  > = io("/my-namespace");socket.on("bar", (arg) => {  console.log(arg); // "123"});
```

# https://socket.io/docs/v4/using-multiple-nodes

# Using multiple nodes

## Sticky load balancing​

## Passing events between nodes​

### Why is sticky-session required​

### Enabling sticky-session​

### nginx configuration​

### nginx Ingress (Kubernetes)​

### Apache HTTPD configuration​

### HAProxy configuration​

### Traefik​

### Using Node.js Cluster​

When deploying multiple Socket.IO servers, there are two things to take care of:

If you plan to distribute the load of connections among different processes or machines, you have to make sure that all requests associated with a particular session ID reach the process that originated them.

This is because the HTTP long-polling transport sends multiple HTTP requests during the lifetime of the Socket.IO session.

In fact, Socket.IO could technically work without sticky sessions, with the following synchronization (in dashed lines):

While obviously possible to implement, we think that this synchronization process between the Socket.IO servers would result in a big performance hit for your application.

Remarks:

Documentation: transports

To achieve sticky-session, there are two main solutions:

You will find below some examples with common load-balancing solutions:

For other platforms, please refer to the relevant documentation:

Important note: if you are in a CORS situation (the front domain is different from the server domain) and session affinity is achieved with a cookie, you need to allow credentials:

Server

Client

Without it, the cookie will not be sent by the browser and you will experience HTTP 400 "Session ID unknown" responses. More information here.

Within the http { } section of your nginx.conf file, you can declare a upstream section with a list of Socket.IO process you want to balance load between:

Notice the hash instruction that indicates the connections will be sticky.

Make sure you also configure worker_processes in the topmost level to indicate how many workers nginx should use. You might also want to look into tweaking the worker_connections setting within the events { } block.

Links:

The value of nginx's proxy_read_timeout (60 seconds by default) must be bigger than Socket.IO's pingInterval + pingTimeout (45 seconds by default), else nginx will forcefully close the connection if no data is sent after the given delay and the client will get a "transport close" error.

Within the annotations section of your Ingress configuration, you can declare an upstream hashing based on the client's IP address, so that the Ingress controller always assigns the requests from a given IP address to the same pod:

Notes:

This annotation instructs the NGINX Ingress Controller to use the client's IP address for routing incoming traffic to a specific Pod in your Kubernetes cluster. This is crucial for maintaining sticky sessions.

This custom NGINX configuration snippet serves a dual purpose:

In the absence of such proxies or gateways, the snippet simply uses the remote_addr, which is the IP address of the client directly connected to the ingress.

Links:

Links:

Links:

Using container labels:

With the File provider:

Links:

Just like nginx, Node.js comes with built-in clustering support through the cluster module.

There are several solutions, depending on your use case:

Example with @socket.io/sticky:

Now that you have multiple Socket.IO nodes accepting connections, if you want to broadcast events to all clients (or to the clients in a certain room) you’ll need some way of passing messages between processes or computers.

The interface in charge of routing messages is what we call the Adapter.

- Server
- Using multiple nodes
- enabling sticky session, if HTTP long-polling is enabled (which is the default): see below
- using a compatible adapter, see here
- without enabling sticky-session, you will experience HTTP 400 errors due to "Session ID unknown"
- the WebSocket transport does not have this limitation, since it relies on a single TCP connection for the whole session. Which means that if you disable the HTTP long-polling transport (which is a perfectly valid choice in 2021), you won't need sticky sessions:
- routing clients based on a cookie (recommended solution)
- routing clients based on their originating address
- nginx (IP-based)
- nginx Ingress (Kubernetes) (IP-based)
- Apache HTTPD (cookie-based)
- HAProxy (cookie-based)
- Traefik (cookie-based)
- Node.js cluster module
- Kubernetes: https://kubernetes.github.io/ingress-nginx/examples/affinity/cookie/
- AWS (Application Load Balancers): https://docs.aws.amazon.com/elasticloadbalancing/latest/application/sticky-sessions.html
- GCP: https://cloud.google.com/load-balancing/docs/backend-service#session_affinity
- Heroku: https://devcenter.heroku.com/articles/session-affinity
- Example
- nginx Documentation
- nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip"
- nginx.ingress.kubernetes.io/configuration-snippet
- In the absence of such proxies or gateways, the snippet simply uses the remote_addr, which is the IP address of the client directly connected to the ingress.
- Ingress Nginx Documentation
- X-Forwarded-For Header
- Example
- Documentation
- Example
- Documentation
- Example
- Documentation
```js
const socket = io("https://io.yourhost.com", {  // WARNING: in that case, there is no fallback to long-polling  transports: [ "websocket" ] // or [ "websocket", "polling" ] (the order matters)});
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://front-domain.com",    methods: ["GET", "POST"],    credentials: true  }});
```

```js
const io = require("socket.io-client");const socket = io("https://server-domain.com", {  withCredentials: true});
```

```js
http {  server {    listen 3000;    server_name io.yourhost.com;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://nodes;      # enable WebSockets      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }  upstream nodes {    # enable sticky session with either "hash" (uses the complete IP address)    hash $remote_addr consistent;    # or "ip_hash" (uses the first three octets of the client IPv4 address, or the entire IPv6 address)    # ip_hash;    # or "sticky" (needs commercial subscription)    # sticky cookie srv_id expires=1h domain=.example.com path=/;    server app01:3000;    server app02:3000;    server app03:3000;  }}
```

```js
apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: your-ingress  namespace: your-namespace  annotations:    nginx.ingress.kubernetes.io/configuration-snippet: |      set $forwarded_client_ip "";      if ($http_x_forwarded_for ~ "^([^,]+)") {        set $forwarded_client_ip $1;      }      set $client_ip $remote_addr;      if ($forwarded_client_ip != "") {        set $client_ip $forwarded_client_ip;      }    nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip"spec:  ingressClassName: nginx  rules:    - host: io.yourhost.com      http:        paths:          - path: /            pathType: Prefix            backend:              service:                name: your-service                port:                  number: 80
```

```js
Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED<Proxy "balancer://nodes_polling">    BalancerMember "http://app01:3000" route=app01    BalancerMember "http://app02:3000" route=app02    BalancerMember "http://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy><Proxy "balancer://nodes_ws">    BalancerMember "ws://app01:3000" route=app01    BalancerMember "ws://app02:3000" route=app02    BalancerMember "ws://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy>RewriteEngine OnRewriteCond %{HTTP:Upgrade} =websocket [NC]RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]RewriteCond %{HTTP:Upgrade} !=websocket [NC]RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]# must be bigger than pingInterval (25s by default) + pingTimeout (20s by default)ProxyTimeout 60
```

```js
# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03
```

```js
# docker-compose.ymlservices:  traefik:    image: traefik:2.4    volumes:      - /var/run/docker.sock:/var/run/docker.sock    links:      - server  server:    image: my-image:latest    labels:      - "traefik.http.routers.my-service.rule=PathPrefix(`/`)"      - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id      - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true
```

```js
## Dynamic configurationhttp:  services:    my-service:      rule: "PathPrefix(`/`)"      loadBalancer:        sticky:          cookie:            name: server_id            httpOnly: true
```

```js
const cluster = require("cluster");const http = require("http");const { Server } = require("socket.io");const numCPUs = require("os").cpus().length;const { setupMaster, setupWorker } = require("@socket.io/sticky");const { createAdapter, setupPrimary } = require("@socket.io/cluster-adapter");if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  const httpServer = http.createServer();  // setup sticky sessions  setupMaster(httpServer, {    loadBalancingMethod: "least-connection",  });  // setup connections between the workers  setupPrimary();  // needed for packets containing buffers (you can ignore it if you only send plaintext objects)  // Node.js < 16.0.0  cluster.setupMaster({    serialization: "advanced",  });  // Node.js > 16.0.0  // cluster.setupPrimary({  //   serialization: "advanced",  // });  httpServer.listen(3000);  for (let i = 0; i < numCPUs; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });} else {  console.log(`Worker ${process.pid} started`);  const httpServer = http.createServer();  const io = new Server(httpServer);  // use the cluster adapter  io.adapter(createAdapter());  // setup connection with the primary process  setupWorker(io);  io.on("connection", (socket) => {    /* ... */  });}
```

```js
const socket = io("https://io.yourhost.com", {  // WARNING: in that case, there is no fallback to long-polling  transports: [ "websocket" ] // or [ "websocket", "polling" ] (the order matters)});
```

```js
transports
```

```js
cluster
```

```js
const io = require("socket.io")(httpServer, {  cors: {    origin: "https://front-domain.com",    methods: ["GET", "POST"],    credentials: true  }});
```

```js
const io = require("socket.io-client");const socket = io("https://server-domain.com", {  withCredentials: true});
```

```js
http { }
```

```js
nginx.conf
```

```js
upstream
```

```js
http {  server {    listen 3000;    server_name io.yourhost.com;    location / {      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;      proxy_set_header Host $host;      proxy_pass http://nodes;      # enable WebSockets      proxy_http_version 1.1;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection "upgrade";    }  }  upstream nodes {    # enable sticky session with either "hash" (uses the complete IP address)    hash $remote_addr consistent;    # or "ip_hash" (uses the first three octets of the client IPv4 address, or the entire IPv6 address)    # ip_hash;    # or "sticky" (needs commercial subscription)    # sticky cookie srv_id expires=1h domain=.example.com path=/;    server app01:3000;    server app02:3000;    server app03:3000;  }}
```

```js
hash
```

```js
worker_processes
```

```js
worker_connections
```

```js
events { }
```

```js
proxy_read_timeout
```

```js
pingInterval + pingTimeout
```

```js
annotations
```

```js
apiVersion: networking.k8s.io/v1kind: Ingressmetadata:  name: your-ingress  namespace: your-namespace  annotations:    nginx.ingress.kubernetes.io/configuration-snippet: |      set $forwarded_client_ip "";      if ($http_x_forwarded_for ~ "^([^,]+)") {        set $forwarded_client_ip $1;      }      set $client_ip $remote_addr;      if ($forwarded_client_ip != "") {        set $client_ip $forwarded_client_ip;      }    nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip"spec:  ingressClassName: nginx  rules:    - host: io.yourhost.com      http:        paths:          - path: /            pathType: Prefix            backend:              service:                name: your-service                port:                  number: 80
```

```js
nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip"
```

```js
nginx.ingress.kubernetes.io/configuration-snippet
```

```js
X-Forwarded-For
```

```js
nginx.ingress.kubernetes.io/upstream-hash-by: "$client_ip"
```

```js
Header add Set-Cookie "SERVERID=sticky.%{BALANCER_WORKER_ROUTE}e; path=/" env=BALANCER_ROUTE_CHANGED<Proxy "balancer://nodes_polling">    BalancerMember "http://app01:3000" route=app01    BalancerMember "http://app02:3000" route=app02    BalancerMember "http://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy><Proxy "balancer://nodes_ws">    BalancerMember "ws://app01:3000" route=app01    BalancerMember "ws://app02:3000" route=app02    BalancerMember "ws://app03:3000" route=app03    ProxySet stickysession=SERVERID</Proxy>RewriteEngine OnRewriteCond %{HTTP:Upgrade} =websocket [NC]RewriteRule /(.*) balancer://nodes_ws/$1 [P,L]RewriteCond %{HTTP:Upgrade} !=websocket [NC]RewriteRule /(.*) balancer://nodes_polling/$1 [P,L]# must be bigger than pingInterval (25s by default) + pingTimeout (20s by default)ProxyTimeout 60
```

```js
# Reference: http://blog.haproxy.com/2012/11/07/websockets-load-balancing-with-haproxy/listen chat  bind *:80  default_backend nodesbackend nodes  option httpchk HEAD /health  http-check expect status 200  cookie io prefix indirect nocache # using the `io` cookie set upon handshake  server app01 app01:3000 check cookie app01  server app02 app02:3000 check cookie app02  server app03 app03:3000 check cookie app03
```

```js
# docker-compose.ymlservices:  traefik:    image: traefik:2.4    volumes:      - /var/run/docker.sock:/var/run/docker.sock    links:      - server  server:    image: my-image:latest    labels:      - "traefik.http.routers.my-service.rule=PathPrefix(`/`)"      - traefik.http.services.my-service.loadBalancer.sticky.cookie.name=server_id      - traefik.http.services.my-service.loadBalancer.sticky.cookie.httpOnly=true
```

```js
## Dynamic configurationhttp:  services:    my-service:      rule: "PathPrefix(`/`)"      loadBalancer:        sticky:          cookie:            name: server_id            httpOnly: true
```

```js
cluster
```

```js
@socket.io/sticky
```

```js
sid
```

```js
sticky-session
```

```js
connection.remoteAddress
```

```js
socketio-sticky-session
```

```js
x-forwarded-for
```

```js
@socket.io/sticky
```

```js
const cluster = require("cluster");const http = require("http");const { Server } = require("socket.io");const numCPUs = require("os").cpus().length;const { setupMaster, setupWorker } = require("@socket.io/sticky");const { createAdapter, setupPrimary } = require("@socket.io/cluster-adapter");if (cluster.isMaster) {  console.log(`Master ${process.pid} is running`);  const httpServer = http.createServer();  // setup sticky sessions  setupMaster(httpServer, {    loadBalancingMethod: "least-connection",  });  // setup connections between the workers  setupPrimary();  // needed for packets containing buffers (you can ignore it if you only send plaintext objects)  // Node.js < 16.0.0  cluster.setupMaster({    serialization: "advanced",  });  // Node.js > 16.0.0  // cluster.setupPrimary({  //   serialization: "advanced",  // });  httpServer.listen(3000);  for (let i = 0; i < numCPUs; i++) {    cluster.fork();  }  cluster.on("exit", (worker) => {    console.log(`Worker ${worker.process.pid} died`);    cluster.fork();  });} else {  console.log(`Worker ${process.pid} started`);  const httpServer = http.createServer();  const io = new Server(httpServer);  // use the cluster adapter  io.adapter(createAdapter());  // setup connection with the primary process  setupWorker(io);  io.on("connection", (socket) => {    /* ... */  });}
```

# https://socket.io

### Performant

### Reliable

### Scalable

### Basic example

### Latest blog posts

### Our sponsors

In most cases, the connection will be established with WebSocket, providing a low-overhead communication channel between the server and the client.

Rest assured! In case the WebSocket connection is not possible, it will fall back to HTTP long-polling. And if the connection is lost, the client will automatically try to reconnect.

Scale to multiple servers and send events to all connected clients with ease.

Run this example on Replit / StackBlitz / CodeSandbox

- July 25, 2024 - npm package provenance
- July 12, 2024 - Socket.IO monorepo
- March 29, 2024 - Three new adapters
- January 12, 2024 - Chat platform
